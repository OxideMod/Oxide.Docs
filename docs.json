{
  "Hooks": [
    {
      "Type": 0,
      "Name": "OnTick",
      "HookName": "OnTick",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "DoTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void DoTick()\r\n{\r\n\tInterface.CallHook(\"OnTick\");\r\n\tRCon.Update();\r\n\tCompanionServer.Server.Update();\r\n\tNexusServer.Update();\r\n\tfor (int i = 0; i < Network.Net.sv.connections.Count; i++)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDisconnected",
      "HookName": "OnPlayerDisconnected",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "strReason": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnDisconnected",
        "ReturnType": "void",
        "Arguments": {
          "strReason": "string",
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tEACServer.OnLeaveGame(connection);\r\n\tBasePlayer basePlayer = connection.player as BasePlayer;\r\n\tif (basePlayer != null)\r\n\t{\r\n\t\tInterface.CallHook(\"OnPlayerDisconnected\", basePlayer, strReason);\r\n\t\tbasePlayer.OnDisconnected();\r\n\t}\r\n\tif (connection.authStatusNexus == \"ok\")\r\n\t{\r\n\t\tNexusServer.Logout(connection.userid);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRemovedFromContainer",
      "HookName": "OnItemRemovedFromContainer",
      "HookParameters": {
        "instance": "ItemContainer",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Remove",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (itemContainer != null && itemContainer.onItemContentsChanged != null)\r\n\t{\r\n\t\titemContainer.onItemContentsChanged(item, false);\r\n\t}\r\n\tthis.MarkDirty();\r\n\tInterface.CallHook(\"OnItemRemovedFromContainer\", this, item);\r\n\treturn true;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemAddedToContainer",
      "HookName": "OnItemAddedToContainer",
      "HookParameters": {
        "instance": "ItemContainer",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Insert",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "//---\r\n\tItemContainer itemContainer = (expr_5A != null) ? expr_5A.parent : null;\r\n\tif (itemContainer != null && itemContainer.onItemContentsChanged != null)\r\n\t{\r\n\t\titemContainer.onItemContentsChanged(item, true);\r\n\t}\r\n\tInterface.CallHook(\"OnItemAddedToContainer\", this, item);\r\n\treturn true;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntitySpawned",
      "HookName": "OnEntitySpawned",
      "HookParameters": {
        "instance": "BaseNetworkable"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Spawn",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tthis.ServerInit();\r\n\tthis.PostInitShared();\r\n\tthis.UpdateNetworkGroup();\r\n\tthis.ServerInitPostNetworkGroupAssign();\r\n\tthis.isSpawned = true;\r\n\tInterface.CallHook(\"OnEntitySpawned\", this);\r\n\tthis.SendNetworkUpdateImmediate(true);\r\n\tbase.Invoke(new Action(this.SendGlobalNetworkUpdate), 0f);\r\n\tif (Rust.Application.isLoading && !Rust.Application.isLoadingSave)\r\n\t{\r\n\t\tbase.gameObject.SendOnSendNetworkUpdate(this as BaseEntity);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [CodeLock, open]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToOpen",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToOpen(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!base.IsLocked())\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [CodeLock, close]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToClose",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToClose(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!base.IsLocked())\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [KeyLock, close]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "KeyLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToClose",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToClose(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.HasLockPermission(player) || !base.IsLocked();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseLockedEntity [KeyLock, open]",
      "HookName": "CanUseLockedEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "KeyLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnTryToOpen",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool OnTryToOpen(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseLockedEntity\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.HasLockPermission(player) || !base.IsLocked();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraft",
      "HookName": "OnItemCraft",
      "HookParameters": {
        "itemCraftTask": "ItemCraftTask",
        "owner": "BasePlayer",
        "fromTempBlueprint": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CraftItem",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "owner": "BasePlayer",
          "instanceData": "ProtoBuf.Item/InstanceData",
          "amount": "int",
          "skinID": "int",
          "fromTempBlueprint": "Item",
          "free": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tfromTempBlueprint.RemoveFromContainer();\r\n\t\titemCraftTask.takenItems.Add(fromTempBlueprint);\r\n\t\titemCraftTask.conditionScale = 0.5f;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemCraft\", itemCraftTask, owner, fromTempBlueprint);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tthis.queue.AddLast(itemCraftTask);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntity",
      "HookName": "OnLootEntity",
      "HookParameters": {
        "instance": "PlayerLoot",
        "targetEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingEntity",
        "ReturnType": "bool",
        "Arguments": {
          "targetEntity": "BaseEntity",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tAssert.IsTrue(targetEntity.isServer, \"Assure is server\");\r\n\tthis.PositionChecks = doPositionChecks;\r\n\tthis.entitySource = targetEntity;\r\n\tthis.itemSource = null;\r\n\tInterface.CallHook(\"OnLootEntity\", this, targetEntity);\r\n\tthis.MarkDirty();\r\n\tILootableEntity lootableEntity = targetEntity as ILootableEntity;\r\n\tif (lootableEntity != null)\r\n\t{\r\n\t\tlootableEntity.LastLootedBy = base.baseEntity.userID;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootItem",
      "HookName": "OnLootItem",
      "HookParameters": {
        "instance": "PlayerLoot",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingItem",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "//---\r\n\tthis.PositionChecks = true;\r\n\tthis.containers.Add(item.contents);\r\n\titem.contents.onDirty += new Action(this.MarkDirty);\r\n\tthis.itemSource = item;\r\n\tthis.entitySource = item.GetWorldEntity();\r\n\tInterface.CallHook(\"OnLootItem\", this, item);\r\n\tthis.MarkDirty();\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityEnter",
      "HookName": "OnEntityEnter",
      "HookParameters": {
        "instance": "TriggerBase",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggerBase",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnEntityEnter",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.entityContents == null)\r\n\t{\r\n\t\tthis.entityContents = new HashSet<BaseEntity>();\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityEnter\", this, ent) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.entityContents.Add(ent);\r\n\tAction<BaseNetworkable> expr_40 = this.OnEntityEnterTrigger;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityLeave",
      "HookName": "OnEntityLeave",
      "HookParameters": {
        "instance": "TriggerBase",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggerBase",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnEntityLeave",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.entityContents == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityLeave\", this, ent) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.entityContents.Remove(ent);\r\n\tAction<BaseNetworkable> expr_2C = this.OnEntityLeaveTrigger;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDeployed [Regular]",
      "HookName": "OnItemDeployed",
      "HookParameters": {
        "instance": "Deployer",
        "modDeployable": "ItemModDeployable",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "Deployer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoDeploy_Regular",
        "ReturnType": "void",
        "Arguments": {
          "deployable": "Deployable",
          "ray": "UnityEngine.Ray"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbaseEntity.skinID = ownerItem.skin;\r\n\tbaseEntity.SendMessage(\"SetDeployedBy\", ownerPlayer, SendMessageOptions.DontRequireReceiver);\r\n\tbaseEntity.OwnerID = ownerPlayer.userID;\r\n\tbaseEntity.Spawn();\r\n\tmodDeployable.OnDeployed(baseEntity, ownerPlayer);\r\n\tInterface.CallHook(\"OnItemDeployed\", this, modDeployable, baseEntity);\r\n\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity, ownerPlayer);\r\n\tbase.UseItemAmount(1, true);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDeployed [Slot]",
      "HookName": "OnItemDeployed",
      "HookParameters": {
        "instance": "Deployer",
        "baseEntity": "BaseEntity",
        "modDeployable": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "Deployer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoDeploy_Slot",
        "ReturnType": "void",
        "Arguments": {
          "deployable": "Deployable",
          "ray": "UnityEngine.Ray",
          "entityID": "NetworkableId"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tIntIdentifier = base.GetOwnerItemDefinition().itemid\r\n\t\t\t}, 1f);\r\n\t\t}\r\n\t}\r\n\tmodDeployable.OnDeployed(baseEntity2, ownerPlayer);\r\n\tInterface.CallHook(\"OnItemDeployed\", this, baseEntity, baseEntity2);\r\n\tFacepunch.Rust.Analytics.Azure.OnEntityBuilt(baseEntity2, ownerPlayer);\r\n\tif (!ownerPlayer.IsInCreativeMode || !Creative.freeBuild)\r\n\t{\r\n\t\tbase.UseItemAmount(1, true);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBaseCombatEntityHurt",
      "HookName": "IOnBaseCombatEntityHurt",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tinfo.damageTypes.Scale(DamageType.Bleeding, ConVar.Server.bleedingdamage);\r\n\t\tif (!(this is BasePlayer))\r\n\t\t{\r\n\t\t\tinfo.damageTypes.Scale(DamageType.Fun_Water, 0f);\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"IOnBaseCombatEntityHurt\", this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.DebugHurt(info);\r\n\t\tfloat num = info.damageTypes.Total();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDispenserGather",
      "HookName": "OnDispenserGather",
      "HookParameters": {
        "instance": "ResourceDispenser",
        "entity": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "GiveResourceFromItem",
        "ReturnType": "void",
        "Arguments": {
          "entity": "BasePlayer",
          "itemAmt": "ItemAmount",
          "gatherDamage": "float",
          "destroyFraction": "float",
          "attackWeapon": "AttackEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (num3 >= 1f)\r\n\t{\r\n\t\tint num6 = this.CalculateGatherBonus(entity, itemAmt, num3);\r\n\t\tint iAmount = Mathf.FloorToInt(num3) + num6;\r\n\t\tItem item = ItemManager.CreateByItemID(itemAmt.itemid, iAmount, 0uL);\r\n\t\tif (Interface.CallHook(\"OnDispenserGather\", this, entity, item) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (item == null)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerAttack [Melee]",
      "HookName": "OnPlayerAttack",
      "HookParameters": {
        "instance": "BaseMelee",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMelee",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual void DoAttackShared(HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerAttack\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.GetAttackStats(info);\r\n\tif (info.HitEntity != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerAttack [Projectile]",
      "HookName": "OnPlayerAttack",
      "HookParameters": {
        "instance": "BasePlayer",
        "hitInfo": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnProjectileAttack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (flag6)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tthis.stats.Add(firedProjectile.itemMod.category + \"_hit_\" + hitEntity.Categorize(), 1, Stats.Steam);\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (Interface.CallHook(\"OnPlayerAttack\", this, hitInfo) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (firedProjectile.integrity <= 0f)\r\n\t\t\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRunPlayerMetabolism",
      "HookName": "OnRunPlayerMetabolism",
      "HookParameters": {
        "instance": "PlayerMetabolism",
        "ownerEntity": "BaseCombatEntity",
        "delta": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerMetabolism",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RunMetabolism",
        "ReturnType": "void",
        "Arguments": {
          "ownerEntity": "BaseCombatEntity",
          "delta": "float"
        }
      },
      "CodeAfterInjection": "protected override void RunMetabolism(BaseCombatEntity ownerEntity, float delta)\r\n{\r\n\tif (Interface.CallHook(\"OnRunPlayerMetabolism\", this, ownerEntity, delta) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.owner.IsConnected)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnUserApprove",
      "HookName": "IOnUserApprove",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionAuth",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnNewConnection",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (DeveloperList.Contains(connection.userid))\r\n\t{\r\n\t\tDebugEx.Log(connection.ToString() + \" is a developer\", StackTraceLogType.None);\r\n\t\tconnection.authLevel = 3u;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnUserApprove\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tConnectionAuth.m_AuthConnection.Add(connection);\r\n\tbase.StartCoroutine(this.AuthorisationRoutine(connection));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWallpaperSet",
      "HookName": "OnWallpaperSet",
      "HookDescription": "",
      "HookParameters": {
        "instance": "BuildingBlock",
        "id": "ulong",
        "side": "int",
        "rotation": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "SetWallpaper",
        "ReturnType": "void",
        "Arguments": {
          "id": "ulong",
          "side": "int",
          "rotation": "float"
        }
      },
      "CodeAfterInjection": "public void SetWallpaper(ulong id, int side = 0, float rotation = 0f)\r\n{\r\n\tif (Interface.CallHook(\"OnWallpaperSet\", this, id, side, rotation) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (side == 0)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWallpaperRemove",
      "HookName": "OnWallpaperRemove",
      "HookDescription": "",
      "HookParameters": {
        "instance": "BuildingBlock",
        "side": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RemoveWallpaper",
        "ReturnType": "void",
        "Arguments": {
          "side": "int"
        }
      },
      "CodeAfterInjection": "public void RemoveWallpaper(int side)\r\n{\r\n\tif (Interface.CallHook(\"OnWallpaperRemove\", this, side) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (side == 0)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureUpgrade",
      "HookName": "OnStructureUpgrade",
      "HookParameters": {
        "instance": "BuildingBlock",
        "player": "BasePlayer",
        "type": "Enum",
        "skin": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoUpgradeToGrade",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureUpgrade\", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanAffordUpgrade(constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin, msg.player))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureDemolish [immediate = true]",
      "HookName": "OnStructureDemolish",
      "HookParameters": {
        "instance": "DecayEntity",
        "player": "BasePlayer",
        "Unknown": "Unknown"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoImmediateDemolish",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!msg.player.IsAdmin)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureDemolish\", this, msg.player, true) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tStabilityEntity stabilityEntity = this as StabilityEntity;\r\n\tif (stabilityEntity != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureRotate",
      "HookName": "OnStructureRotate",
      "HookParameters": {
        "instance": "BuildingBlock",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoRotation",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.blockDefinition.canRotateAfterPlacement)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureRotate\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.transform.localRotation *= Quaternion.Euler(this.blockDefinition.rotationAmount);\r\n\tbase.RefreshEntityLinks();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelConsume",
      "HookName": "OnFuelConsume",
      "HookParameters": {
        "instance": "BaseOven",
        "fuel": "Item",
        "burnable": "ItemModBurnable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "ConsumeFuel",
        "ReturnType": "void",
        "Arguments": {
          "fuel": "Item",
          "burnable": "ItemModBurnable"
        }
      },
      "CodeAfterInjection": "private void ConsumeFuel(Item fuel, ItemModBurnable burnable)\r\n{\r\n\tif (Interface.CallHook(\"OnFuelConsume\", this, fuel, burnable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.allowByproductCreation && burnable.byproductItem != null && UnityEngine.Random.Range(0f, 1f) > burnable.byproductChance)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [Signage]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "Signage"
      },
      "ReturnBehavior": 1,
      "TargetType": "Signage",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanUpdateSign(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (player.IsAdmin || player.IsDeveloper)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignLocked [Signage]",
      "HookName": "OnSignLocked",
      "HookParameters": {
        "instance": "Signage",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Signage",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "LockSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(BaseEntity.Flags.Locked, true, false, true);\r\n\tbase.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);\r\n\tbase.OwnerID = msg.player.userID;\r\n\tInterface.CallHook(\"OnSignLocked\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [Signage]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "instance": "Signage",
        "player": "BasePlayer",
        "num": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "Signage",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tthis.textureIDs[num] = FileStorage.server.Store(array, FileStorage.Type.png, this.net.ID, (uint)num);\r\n\t}\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player, num);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnLoseCondition",
      "HookName": "IOnLoseCondition",
      "HookParameters": {
        "instance": "Item",
        "amount": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LoseCondition",
        "ReturnType": "void",
        "Arguments": {
          "amount": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (Debugging.disablecondition)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnLoseCondition\", this, amount) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat condition = this.condition;\r\n\tthis.condition -= amount;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleepEnd",
      "HookName": "OnPlayerSleepEnd",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EndSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!this.IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSleepEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsRestrained)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityGroundMissing",
      "HookName": "OnEntityGroundMissing",
      "HookParameters": {
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "DestroyOnGroundMissing",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnGroundMissing",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void OnGroundMissing()\r\n{\r\n\tBaseEntity baseEntity = base.gameObject.ToBaseEntity(false);\r\n\tif (baseEntity != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnEntityGroundMissing\", baseEntity) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tBaseCombatEntity baseCombatEntity = baseEntity as BaseCombatEntity;\r\n\t\tif (Stability.log_ground_missing_death)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorOpened",
      "HookName": "OnDoorOpened",
      "HookParameters": {
        "instance": "Door",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_OpenDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tthis.StartCheckingForBlockages(true);\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBaseInteract(rpc.player, this);\r\n\tthis.OnPlayerOpenedDoor(rpc.player);\r\n\tInterface.CallHook(\"OnDoorOpened\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorClosed",
      "HookName": "OnDoorClosed",
      "HookParameters": {
        "instance": "Door",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_CloseDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tthis.SetNavMeshLinkEnabled(false);\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnBaseInteract(rpc.player, this);\r\n\tthis.StartCheckingForBlockages(false);\r\n\tInterface.CallHook(\"OnDoorClosed\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerTick",
      "HookName": "OnPlayerTick",
      "HookParameters": {
        "instance": "BasePlayer",
        "msg": "PlayerTick",
        "wasPlayerStalled": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnReceiveTick",
        "ReturnType": "void",
        "Arguments": {
          "msg": "PlayerTick",
          "wasPlayerStalled": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (msg.inputState != null)\r\n\t{\r\n\t\tthis.serverInput.Flip(msg.inputState);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerTick\", this, msg, wasPlayerStalled) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.serverInput.current.buttons != this.serverInput.previous.buttons)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBasePlayerAttacked",
      "HookName": "IOnBasePlayerAttacked",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"IOnBasePlayerAttacked\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat health = base.health;\r\n\tif (this.InSafeZone() && !this.IsHostile() && info.Initiator != null && info.Initiator != this)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnBasePlayerHurt",
      "HookName": "IOnBasePlayerHurt",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.IsImmortalTo(info) && info.damageTypes.Total() >= 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"IOnBasePlayerHurt\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool wasWounded = this.IsWounded();\r\n\tif (ConVar.Server.pve && !this.IsNpc && info.Initiator && info.Initiator is BasePlayer && info.Initiator != this)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExplosiveThrown",
      "HookName": "OnExplosiveThrown",
      "HookParameters": {
        "player": "BasePlayer",
        "baseEntity": "BaseEntity",
        "instance": "ThrownWeapon"
      },
      "ReturnBehavior": 0,
      "TargetType": "ThrownWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoThrow",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\ttimedExplosive.ItemOwnership = itemOwnership;\r\n\t\ttimedExplosive.SetCreator(msg.player);\r\n\t}\r\n\tthis.SetUpThrownWeapon(baseEntity);\r\n\tbase.StartAttackCooldown(this.repeatDelay);\r\n\tInterface.CallHook(\"OnExplosiveThrown\", msg.player, baseEntity, this);\r\n\tbase.UseItemAmount(1, false);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMeleeThrown",
      "HookName": "OnMeleeThrown",
      "HookParameters": {
        "player": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMelee",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tif (item.amount == 0)\r\n\t\t\t\t{\r\n\t\t\t\t\titem.SetParent(null);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tInterface.CallHook(\"OnMeleeThrown\", player, item);\r\n\t\t\tSingletonComponent<NpcNoiseManager>.Instance.OnWeaponThrown(player, this, this.canAiHearIt);\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraftFinished",
      "HookName": "OnItemCraftFinished",
      "HookParameters": {
        "task": "ItemCraftTask",
        "item": "Item",
        "instance": "ItemCrafter"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FinishCrafting",
        "ReturnType": "void",
        "Arguments": {
          "task": "ItemCraftTask"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\ttask.taskUID,\r\n\t\t1,\r\n\t\ttask.amount\r\n\t});\r\n\tInterface.CallHook(\"OnItemCraftFinished\", task, item, this);\r\n\tif (task.instanceData != null)\r\n\t{\r\n\t\titem.instanceData = task.instanceData;\r\n\t}\r\n\tif (!string.IsNullOrEmpty(task.blueprint.UnlockAchievment))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHealingItemUse",
      "HookName": "OnHealingItemUse",
      "HookParameters": {
        "instance": "MedicalTool",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MedicalTool",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GiveEffectsTo",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!component)\r\n\t{\r\n\t\tDebug.LogWarning(\"No consumable for medicaltool :\" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHealingItemUse\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanResearchItem",
      "HookName": "CanResearchItem",
      "HookParameters": {
        "player": "BasePlayer",
        "targetItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoResearch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tItem targetItem = this.GetTargetItem();\r\n\tif (targetItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanResearchItem\", player, targetItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targetItem.amount > 1)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemResearch",
      "HookName": "OnItemResearch",
      "HookParameters": {
        "instance": "ResearchTable",
        "targetItem": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoResearch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.IsItemResearchable(targetItem))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnItemResearch\", this, targetItem, player);\r\n\ttargetItem.CollectedForCrafting(player);\r\n\tthis.researchFinishedTime = Time.realtimeSinceStartup + this.researchDuration;\r\n\tbase.Invoke(new Action(this.ResearchAttemptFinished), this.researchDuration);\r\n\tbase.inventory.SetLocked(true, false);\r\n\tint scrapCost = ResearchTable.ScrapForResearch(targetItem);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemResearched",
      "HookName": "OnItemResearched",
      "HookParameters": {
        "instance": "ResearchTable",
        "num": "int"
      },
      "ReturnBehavior": 3,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ResearchAttemptFinished",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tItem targetItem = this.GetTargetItem();\r\n\tItem scrapItem = this.GetScrapItem();\r\n\tif (targetItem != null && scrapItem != null)\r\n\t{\r\n\t\tint num = ResearchTable.ScrapForResearch(targetItem);\r\n\t\tobject returnvar = Interface.CallHook(\"OnItemResearched\", this, num);\r\n\t\tif (returnvar is int)\r\n\t\t{\r\n\t\t\tnum = (int)returnvar;\r\n\t\t}\r\n\t\tif (scrapItem.amount >= num)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootPlayer",
      "HookName": "CanLootPlayer",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanBeLooted",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool CanBeLooted(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanLootPlayer\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !(player == this) && ((this.IsWounded() || this.IsSleeping() || this.CurrentGestureIsSurrendering || this.IsRestrainedOrSurrendering) && !this.IsLoadingAfterTransfer()) && !base.IsTransferring();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeWounded",
      "HookName": "CanBeWounded",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EligibleForWounding",
        "ReturnType": "bool",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual bool EligibleForWounding(HitInfo info)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeWounded\", this, info);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!ConVar.Server.woundingenabled)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRocketLaunched",
      "HookName": "OnRocketLaunched",
      "HookParameters": {
        "player": "BasePlayer",
        "raycastHit": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseLauncher",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "SV_Launch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tcomponent2.InitializeVelocity(this.GetInheritedVelocity(player, vector2) + vector2 * component2.speed * this.initialSpeedMultiplier);\r\n\t}\r\n\tbaseEntity2.Spawn();\r\n\tthis.ProjectileLaunched_Server(component2);\r\n\tFacepunch.Rust.Analytics.Azure.OnExplosiveLaunched(player, baseEntity2, this);\r\n\tInterface.CallHook(\"OnRocketLaunched\", player, baseEntity2);\r\n\tbase.StartAttackCooldown(base.ScaleRepeatDelay(this.repeatDelay));\r\n\tItem ownerItem = base.GetOwnerItem();\r\n\tif (ownerItem == null)\r\n\t{\r\n\t\treturn;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWeaponFired",
      "HookName": "OnWeaponFired",
      "HookParameters": {
        "instance": "BaseProjectile",
        "player": "BasePlayer",
        "component": "ItemModProjectile",
        "projectileShoot": "ProjectileShoot"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tglobal::AntiHack.Log(player, AntiHackType.ProjectileHack, \"Count mismatch (\" + base.ShortPrefabName + \")\", true);\r\n\t\t\t\tplayer.stats.combat.LogInvalid(player, this, \"count_mismatch\");\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tInterface.CallHook(\"OnWeaponFired\", this, msg.player, component, projectileShoot);\r\n\t\t\t\tif (!player.InGesture)\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.SignalBroadcast(global::BaseEntity.Signal.Attack, string.Empty, msg.connection, this.GetAttackEffect());\r\n\t\t\t\t\tplayer.CleanupExpiredProjectiles();\r\n\t\t\t\t\tGuid projectileGroupId = Guid.NewGuid();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemUse",
      "HookName": "OnItemUse",
      "HookParameters": {
        "instance": "Item",
        "amountToConsume": "int"
      },
      "ReturnBehavior": 3,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "UseItem",
        "ReturnType": "void",
        "Arguments": {
          "amountToConsume": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (amountToConsume <= 0)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemUse\", this, amountToConsume);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\tamountToConsume = (int)returnvar;\r\n\t}\r\n\tthis.amount -= amountToConsume;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHammerHit",
      "HookName": "OnHammerHit",
      "HookParameters": {
        "ownerPlayer": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "Hammer",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tBasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tBaseCombatEntity baseCombatEntity = info.HitEntity as BaseCombatEntity;\r\n\tif (baseCombatEntity != null && ownerPlayer != null && base.isServer)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnHammerHit\", ownerPlayer, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tusing (TimeWarning.New(\"DoRepair\", 50))\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSurveyGather",
      "HookName": "OnSurveyGather",
      "HookParameters": {
        "instance": "SurveyCharge",
        "itemManager": "ItemManager"
      },
      "ReturnBehavior": 0,
      "TargetType": "SurveyCharge",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t}\r\n\t\t\tfor (int i = 0; i < num; i++)\r\n\t\t\t{\r\n\t\t\t\tItem OxideGen_15 = ItemManager.Create(current.type, iAmount, 0uL, true);\r\n\t\t\t\tItem arg_1B5_0 = OxideGen_15;\r\n\t\t\t\tInterface.CallHook(\"OnSurveyGather\", this, OxideGen_15);\r\n\t\t\t\tVector3 modifiedAimConeDirection = AimConeUtil.GetModifiedAimConeDirection(20f, Vector3.up, true);\r\n\t\t\t\targ_1B5_0.Drop(base.transform.position + Vector3.up * 1f, this.GetInheritedDropVelocity() + modifiedAimConeDirection * UnityEngine.Random.Range(5f, 10f), UnityEngine.Random.rotation).SetAngularVelocity(UnityEngine.Random.rotation.eulerAngles * 5f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAirdrop",
      "HookName": "OnAirdrop",
      "HookParameters": {
        "instance": "CargoPlane",
        "newDropPosition": "Vector3"
      },
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateDropPosition",
        "ReturnType": "void",
        "Arguments": {
          "newDropPosition": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\tthis.secondsToTake = Vector3.Distance(this.startPos, this.endPos) / 50f;\r\n\tthis.secondsToTake *= UnityEngine.Random.Range(0.95f, 1.05f);\r\n\tbase.transform.position = this.startPos;\r\n\tbase.transform.rotation = Quaternion.LookRotation(this.endPos - this.startPos);\r\n\tthis.dropPosition = newDropPosition;\r\n\tInterface.CallHook(\"OnAirdrop\", this, newDropPosition);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureRepair",
      "HookName": "OnStructureRepair",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoRepair",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tBasePlayer player = player2;\r\n\tif (!this.repair.enabled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureRepair\", this, player2) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = this.GetDamageRepairCooldown();\r\n\tif (player.IsInCreativeMode && Creative.freeRepair)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRepair",
      "HookName": "OnItemRepair",
      "HookParameters": {
        "player": "BasePlayer",
        "itemToRepair": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "RepairBench",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RepairAnItem",
        "ReturnType": "void",
        "Arguments": {
          "itemToRepair": "Item",
          "player": "BasePlayer",
          "repairBenchEntity": "BaseEntity",
          "maxConditionLostOnRepair": "float",
          "mustKnowBlueprint": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemRepair\", player, itemToRepair) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = RepairBench.RepairCostFraction(itemToRepair);\r\n\tbool flag2 = false;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapSnapped",
      "HookName": "OnTrapSnapped",
      "HookParameters": {
        "instance": "BaseTrapTrigger",
        "obj": "GameObject",
        "col": "Collider"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseTrapTrigger",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "OnObjectAdded",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject",
          "col": "UnityEngine.Collider"
        }
      },
      "CodeAfterInjection": "internal override void OnObjectAdded(GameObject obj, Collider col)\r\n{\r\n\tInterface.CallHook(\"OnTrapSnapped\", this, obj, col);\r\n\tbase.OnObjectAdded(obj, col);\r\n\tthis._trap.ObjectEntered(obj);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapDisarm",
      "HookName": "OnTrapDisarm",
      "HookParameters": {
        "instance": "Landmine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Landmine",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "RPC_Disarm",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.Armed())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTrapDisarm\", this, rpc.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.Triggered())\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapArm",
      "HookName": "OnTrapArm",
      "HookParameters": {
        "instance": "BearTrap",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BearTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "RPC_Arm",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.Armed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapArm\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Arm();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapImageUpdated",
      "HookName": "OnMapImageUpdated",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "MapEntity",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ImageUpdate",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (b == 1)\r\n\t{\r\n\t\tthis.paintImages[(int)b2] = num3;\r\n\t}\r\n\tbase.InvalidateNetworkCache();\r\n\tInterface.CallHook(\"OnMapImageUpdated\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraftCancelled",
      "HookName": "OnItemCraftCancelled",
      "HookParameters": {
        "itemCraftTask": "ItemCraftTask",
        "instance": "ItemCrafter"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CancelTask",
        "ReturnType": "bool",
        "Arguments": {
          "iID": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\titemCraftTask.cancelled = true;\r\n\tif (this.owner == null)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tInterface.CallHook(\"OnItemCraftCancelled\", itemCraftTask, this);\r\n\tthis.owner.Command(\"note.craft_done\", new object[]\r\n\t{\r\n\t\titemCraftTask.taskUID,\r\n\t\t0\r\n\t});\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResourceDepositCreated",
      "HookName": "OnResourceDepositCreated",
      "HookParameters": {
        "arg_360_0": "ResourceDeposit"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResourceDepositManager",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "CreateFromPosition",
        "ReturnType": "ResourceDepositManager/ResourceDeposit",
        "Arguments": {
          "pos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tresourceDeposit.Add(ItemManager.FindItemDefinition(\"hq.metal.ore\"), 1f, UnityEngine.Random.Range(5000, 10000), UnityEngine.Random.Range(30f, 50f), ResourceDepositManager.ResourceDeposit.surveySpawnType.ITEM, false);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tthis._deposits.Add(indexFrom, resourceDeposit);\r\n\tInterface.CallHook(\"OnResourceDepositCreated\", resourceDeposit);\r\n\tUnityEngine.Random.state = arg_360_0;\r\n\treturn resourceDeposit;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemUpgrade",
      "HookName": "OnItemUpgrade",
      "HookParameters": {
        "item": "Item",
        "item2": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemModUpgrade",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tif (UnityEngine.Random.Range(0f, 1f) <= this.upgradeSuccessChance)\r\n\t\t{\r\n\t\t\titem.UseItem(this.numForUpgrade);\r\n\t\t\tItem item2 = ItemManager.Create(this.upgradedItem, this.numUpgradedItem, 0uL, true);\r\n\t\t\tInterface.CallHook(\"OnItemUpgrade\", item, item2, player);\r\n\t\t\titem2.SetItemOwnership(player, ItemOwnershipPhrases.UpgradeItem);\r\n\t\t\tif (!item2.MoveToContainer(player.inventory.containerMain, -1, true, false, null, true))\r\n\t\t\t{\r\n\t\t\t\titem2.Drop(player.GetDropPosition(), player.GetDropVelocity(), default(Quaternion));\r\n\t\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardDeauthorize",
      "HookName": "OnCupboardDeauthorize",
      "HookParameters": {
        "instance": "BuildingPrivlidge",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingPrivlidge",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RemoveSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanAdministrate(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCupboardDeauthorize\", this, rpc2.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == rpc.player.userID);\r\n\tglobal::BasePlayer arg_B1_1 = rpc.player;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNetworkTo",
      "HookName": "CanNetworkTo",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "ShouldNetworkTo",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool ShouldNetworkTo(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanNetworkTo\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.net.group == null || player.net.subscriber.IsSubscribed(this.net.group);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretTarget",
      "HookName": "OnTurretTarget",
      "HookParameters": {
        "instance": "AutoTurret",
        "targ": "BaseCombatEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "targ": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public void SetTarget(BaseCombatEntity targ)\r\n{\r\n\tif (Interface.CallHook(\"OnTurretTarget\", this, targ) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (targ != this.target || targ.IsRealNull() != this.target.IsRealNull())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [AutoTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "obj": "BaseCombatEntity",
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ObjectVisible",
        "ReturnType": "bool",
        "Arguments": {
          "obj": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public bool ObjectVisible(BaseCombatEntity obj)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", obj, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tVector3 position = this.eyePos.transform.position;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterTarget",
      "HookName": "OnHelicopterTarget",
      "HookParameters": {
        "instance": "HelicopterTurret",
        "newTarget": "BaseCombatEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "HelicopterTurret",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "newTarget": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public void SetTarget(BaseCombatEntity newTarget)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterTarget\", this, newTarget) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis._target = newTarget;\r\n\tthis.UpdateTargetVisibility();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [HelicopterTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "potentialtarget": "BaseCombatEntity",
        "instance": "HelicopterTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "HelicopterTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "InFiringArc",
        "ReturnType": "bool",
        "Arguments": {
          "potentialtarget": "BaseCombatEntity"
        }
      },
      "CodeAfterInjection": "public bool InFiringArc(BaseCombatEntity potentialtarget)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", potentialtarget, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.AngleToTarget(potentialtarget) < 80f;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBuild",
      "HookName": "CanBuild",
      "HookParameters": {
        "instance": "Planner",
        "construction": "Construction",
        "deployable": "Target"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoBuild",
        "ReturnType": "void",
        "Arguments": {
          "msg": "ProtoBuf.CreateBuilding"
        }
      },
      "CodeAfterInjection": "//---\r\n\ttarget.normal = msg.normal;\r\n\ttarget.rotation = msg.rotation;\r\n\ttarget.player = ownerPlayer;\r\n\ttarget.isHoldingShift = msg.isHoldingShift;\r\n\ttarget.valid = true;\r\n\tif (Interface.CallHook(\"CanBuild\", this, construction, target) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.ShouldParent(target.entity, deployable))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEquipItem",
      "HookName": "CanEquipItem",
      "HookParameters": {
        "instance": "PlayerInventory",
        "item": "Item",
        "targetSlot": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanEquipItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "private bool CanEquipItem(Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEquipItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif ((item.info.flags & ItemDefinition.Flag.NotAllowedInBelt) != (ItemDefinition.Flag)0)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanWearItem",
      "HookName": "CanWearItem",
      "HookParameters": {
        "instance": "PlayerInventory",
        "item": "Item",
        "targetSlot": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanWearItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "private bool CanWearItem(Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanWearItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.CanWearItem(item, true, targetSlot);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAcceptItem",
      "HookName": "CanAcceptItem",
      "HookParameters": {
        "instance": "ItemContainer",
        "item": "Item",
        "targetPos": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanAcceptItem",
        "ReturnType": "ItemContainer/CanAcceptResult",
        "Arguments": {
          "item": "Item",
          "targetPos": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tif (!flag)\r\n\t\t{\r\n\t\t\treturn ItemContainer.CanAcceptResult.CannotAccept;\r\n\t\t}\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAcceptItem\", this, item, targetPos);\r\n\tif (returnvar is ItemContainer.CanAcceptResult)\r\n\t{\r\n\t\treturn (ItemContainer.CanAcceptResult)returnvar;\r\n\t}\r\n\tif (this.blockedItems != null && this.blockedItems.Contains(item.info))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLootEnd",
      "HookName": "OnPlayerLootEnd",
      "HookParameters": {
        "instance": "PlayerLoot"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!this.IsLooting())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerLootEnd\", this);\r\n\tbase.baseEntity.HasClosedLoot();\r\n\tthis.MarkDirty();\r\n\tif (this.entitySource)\r\n\t{\r\n\t\tthis.entitySource.SendMessage(\"PlayerStoppedLooting\", base.baseEntity, SendMessageOptions.DontRequireReceiver);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemSplit",
      "HookName": "OnItemSplit",
      "HookParameters": {
        "instance": "Item",
        "split_Amount": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SplitItem",
        "ReturnType": "Item",
        "Arguments": {
          "split_Amount": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (split_Amount >= this.amount)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnItemSplit\", this, split_Amount);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tthis.amount -= split_Amount;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardClearList",
      "HookName": "OnCupboardClearList",
      "HookParameters": {
        "instance": "BuildingPrivlidge",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingPrivlidge",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "ClearList",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanAdministrate(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCupboardClearList\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.Clear();\r\n\tthis.UpdateMaxAuthCapacity();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [LootableCorpse]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "LootableCorpse"
      },
      "ReturnBehavior": 0,
      "TargetType": "LootableCorpse",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.ResetRemovalTime();\r\n\tbase.SetFlag(BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [StorageContainer]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "StorageContainer"
      },
      "ReturnBehavior": 0,
      "TargetType": "StorageContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void PlayerStoppedLooting(BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.SetFlag(BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureDemolish [immediate = false]",
      "HookName": "OnStructureDemolish",
      "HookParameters": {
        "instance": "DecayEntity",
        "player": "BasePlayer",
        "Unknown": "Unknown"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoDemolish",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanDemolish(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnStructureDemolish\", this, msg.player, false) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tStabilityEntity stabilityEntity = this as StabilityEntity;\r\n\tif (stabilityEntity != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCreateWorldProjectile",
      "HookName": "CanCreateWorldProjectile",
      "HookParameters": {
        "info": "HitInfo",
        "itemDef": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CreateWorldProjectile",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo",
          "itemDef": "ItemDefinition",
          "itemMod": "ItemModProjectile",
          "projectilePrefab": "Projectile",
          "recycleItem": "Item"
        }
      },
      "CodeAfterInjection": "protected virtual void CreateWorldProjectile(HitInfo info, ItemDefinition itemDef, ItemModProjectile itemMod, Projectile projectilePrefab, Item recycleItem)\r\n{\r\n\tif (Interface.CallHook(\"CanCreateWorldProjectile\", info, itemDef) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 projectileVelocity = info.ProjectileVelocity;\r\n\tItem item = (recycleItem != null) ? recycleItem : ItemManager.Create(itemDef, 1, 0uL, true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemPickup",
      "HookName": "OnItemPickup",
      "HookParameters": {
        "item": "Item",
        "player": "BasePlayer",
        "instance": "WorldItem"
      },
      "ReturnBehavior": 1,
      "TargetType": "WorldItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Pickup",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.allowPickup)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemPickup\", this.item, msg.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanOpenInSafeZone(msg.player))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBypassQueue",
      "HookName": "CanBypassQueue",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanJumpQueue",
        "ReturnType": "bool",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "private bool CanJumpQueue(Connection connection)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBypassQueue\", connection);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (DeveloperList.Contains(connection.userid))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityKill",
      "HookName": "OnEntityKill",
      "HookParameters": {
        "instance": "BaseNetworkable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Kill",
        "ReturnType": "void",
        "Arguments": {
          "mode": "BaseNetworkable/DestroyMode"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (this.IsDestroyed)\r\n\t{\r\n\t\tDebug.LogWarning(\"Calling kill - but already IsDestroyed!? \" + ((this != null) ? this.ToString() : null));\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityKill\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tEntityProfiler.killed++;\r\n\tif (EntityProfiler.mode >= 2)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRespawned",
      "HookName": "OnPlayerRespawned",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RespawnAt",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion",
          "spawnPointEntity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.IsConnected)\r\n\t{\r\n\t\tEACServer.OnStartLoading(this.net.connection);\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerRespawned\", this);\r\n\tthis.ProcessMissionEvent(BaseMission.MissionEventType.RESPAWN, 0, 0f);\r\n\tthis.PlayerInjureState = this.GetInjureState();\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMessagePlayer",
      "HookName": "OnMessagePlayer",
      "HookParameters": {
        "msg": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Server",
      "MethodData": {
        "MethodName": "ChatMessage",
        "ReturnType": "void",
        "Arguments": {
          "msg": "string"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnMessagePlayer\", msg, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SendConsoleCommand(\"chat.add\", new object[]\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerMessage",
      "HookName": "OnServerMessage",
      "HookParameters": {
        "message": "string",
        "username": "string",
        "color": "string",
        "userid": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConVar.Chat",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Broadcast",
        "ReturnType": "void",
        "Arguments": {
          "message": "string",
          "username": "string",
          "color": "string",
          "userid": "ulong"
        }
      },
      "CodeAfterInjection": "public static void Broadcast(string message, string username = \"SERVER\", string color = \"#eee\", ulong userid = 0uL)\r\n{\r\n\tif (Interface.CallHook(\"OnServerMessage\", message, username, color, userid) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = username.EscapeRichText(false);\r\n\tConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRconConnection [exp]",
      "HookName": "OnRconConnection",
      "HookParameters": {
        "Address": "IPAddress"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.RCon/RConListener",
      "Category": "Server",
      "MethodData": {
        "MethodName": "ProcessConnections",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (socket == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tIPEndPoint iPEndPoint = socket.RemoteEndPoint as IPEndPoint;\r\n\tif (Interface.CallHook(\"OnRconConnection\", iPEndPoint.Address) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (RCon.IsBanned(iPEndPoint.Address))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRconConnection [exp, patch]",
      "HookName": "OnRconConnection [exp, patch]",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.RCon/RConListener",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ProcessConnections",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnClientAuth",
      "HookName": "OnClientAuth",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnGiveUserInformation",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "//---\r\n\tstring branch = ConVar.Server.branch;\r\n\tif (packet.read.Unread >= 4)\r\n\t{\r\n\t\ttext = packet.read.String(128, false);\r\n\t}\r\n\tInterface.CallHook(\"OnClientAuth\", packet.connection);\r\n\tif (branch != string.Empty && branch != text)\r\n\t{\r\n\t\tstring[] expr_1BB = new string[7];\r\n\t\texpr_1BB[0] = \"Kicking \";\r\n\t\tint arg_1D7_1 = 1;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNewSave",
      "HookName": "OnNewSave",
      "HookParameters": {
        "strFilename": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Load",
        "ReturnType": "bool",
        "Arguments": {
          "strFilename": "string",
          "allowOutOfDateSaves": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tstrFilename = World.SaveFolderName + \"/\" + World.SaveFileName;\r\n\t\t}\r\n\t\tif (!File.Exists(strFilename))\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnNewSave\", strFilename);\r\n\t\t\tif (!File.Exists(\"TestSaves/\" + strFilename))\r\n\t\t\t{\r\n\t\t\t\tUnityEngine.Debug.LogWarning(\"Couldn't load \" + strFilename + \" - file doesn't exist\");\r\n\t\t\t\tresult = false;\r\n\t\t\t\treturn result;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerShutdown",
      "HookName": "IOnServerShutdown",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Shutdown",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "internal void Shutdown()\r\n{\r\n\tInterface.CallHook(\"IOnServerShutdown\");\r\n\tBasePlayer[] array = BasePlayer.activePlayerList.ToArray<BasePlayer>();\r\n\tfor (int i = 0; i < array.Length; i++)\r\n\t{\r\n\t\tarray[i].Kick(\"Server Shutting Down\", true);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSaveLoad",
      "HookName": "OnSaveLoad",
      "HookParameters": {
        "list": "Dictionary`2"
      },
      "ReturnBehavior": 1,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Load",
        "ReturnType": "bool",
        "Arguments": {
          "strFilename": "string",
          "allowOutOfDateSaves": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tcurrent.SpawnAsMapEntity();\r\n\t\t\t}\r\n\t\t}\r\n\t\tDebugEx.Log(\"\\tdone.\", StackTraceLogType.None);\r\n\t\tDebugEx.Log(\"Spawning \" + dictionary.Count.ToString() + \" entities from save\", StackTraceLogType.None);\r\n\t\tobject returnvar = Interface.CallHook(\"OnSaveLoad\", dictionary);\r\n\t\tif (returnvar is bool)\r\n\t\t{\r\n\t\t\treturn (bool)returnvar;\r\n\t\t}\r\n\t\tglobal::BaseNetworkable.LoadInfo info = default(global::BaseNetworkable.LoadInfo);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSpectate",
      "HookName": "OnPlayerSpectate",
      "HookParameters": {
        "instance": "BasePlayer",
        "spectateFilter": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartSpectating",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.IsSpectating())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSpectate\", this, this.spectateFilter) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, true);\r\n\tbase.gameObject.SetLayerRecursive(10);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSpectateEnd",
      "HookName": "OnPlayerSpectateEnd",
      "HookParameters": {
        "instance": "BasePlayer",
        "spectateFilter": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StopSpectating",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!this.IsSpectating())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerSpectateEnd\", this, this.spectateFilter) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetParent(null, false, false);\r\n\tthis.SetPlayerFlag(BasePlayer.PlayerFlags.Spectating, false);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerHealthChange",
      "HookName": "OnPlayerHealthChange",
      "HookParameters": {
        "instance": "BasePlayer",
        "oldvalue": "float",
        "newvalue": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnHealthChanged",
        "ReturnType": "void",
        "Arguments": {
          "oldvalue": "float",
          "newvalue": "float"
        }
      },
      "CodeAfterInjection": "public override void OnHealthChanged(float oldvalue, float newvalue)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerHealthChange\", this, oldvalue, newvalue) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.OnHealthChanged(oldvalue, newvalue);\r\n\tif (!base.isServer)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretStartup",
      "HookName": "OnTurretStartup",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "InitiateStartup",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.IsOnline() || this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretStartup\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tEffect.server.Run(this.onlineSound.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false, null);\r\n\tbase.Invoke(new Action(this.SetOnline), 2f);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretShutdown",
      "HookName": "OnTurretShutdown",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "InitiateShutdown",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.IsOffline() && !this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretShutdown\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.CancelInvoke(new Action(this.SetOnline));\r\n\tthis.booting = false;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretToggle",
      "HookName": "OnTurretToggle",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SetIsOnline",
        "ReturnType": "void",
        "Arguments": {
          "online": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (online == base.IsOn())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretToggle\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(BaseEntity.Flags.On, online, false, true);\r\n\tif (online)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleep",
      "HookName": "OnPlayerSleep",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.IsSleeping())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerSleep\", this);\r\n\tif (this.IsRestrained)\r\n\t{\r\n\t\tthis.inventory.SetLockedByRestraint(false);\r\n\t}\r\n\tif (this.InSafeZone() && !base.IsInvoking(new Action(this.ScheduledDeath)))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDeath",
      "HookName": "OnPlayerDeath",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Die",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tVector3 vector = new Vector3(UnityEngine.Random.Range(-2f, 2f), 0.2f, UnityEngine.Random.Range(-2f, 2f));\r\n\t\t\t\tthis.Belt.DropActive(this.GetDropPosition(), this.GetInheritedDropVelocity() + vector.normalized * 3f);\r\n\t\t\t}\r\n\t\t\tif (!this.WoundInsteadOfDying(info))\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnPlayerDeath\", this, info) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tSleepingBag.OnPlayerDeath(this);\r\n\t\t\t\tbase.Die(info);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRevive",
      "HookName": "OnPlayerRevive",
      "HookParameters": {
        "GetOwnerPlayer()": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MedicalTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveEffectsTo",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tBasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tFacepunch.Rust.Analytics.Azure.OnMedUsed(ownerItemDefinition.shortname, ownerPlayer, player);\r\n\tif (player != ownerPlayer)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnPlayerRevive\", this.GetOwnerPlayer(), player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (player.IsWounded() && this.canRevive)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenToggle",
      "HookName": "OnOvenToggle",
      "HookParameters": {
        "instance": "BaseOven",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[BaseEntity.RPC_Server, BaseEntity.RPC_Server.MaxDistance(3f)]\r\nprotected virtual void SVSwitch(BaseEntity.RPCMessage msg)\r\n{\r\n\tbool flag = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnOvenToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (flag == base.IsOn())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapTrigger [BearTrap]",
      "HookName": "OnTrapTrigger",
      "HookParameters": {
        "instance": "BearTrap",
        "obj": "GameObject"
      },
      "ReturnBehavior": 1,
      "TargetType": "BearTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "ObjectEntered",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!this.Armed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapTrigger\", this, obj) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.hurtTarget = obj;\r\n\tbase.Invoke(new Action(this.DelayedFire), 0.05f);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrapTrigger [Landmine]",
      "HookName": "OnTrapTrigger",
      "HookParameters": {
        "instance": "Landmine",
        "obj": "GameObject"
      },
      "ReturnBehavior": 1,
      "TargetType": "Landmine",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "ObjectEntered",
        "ReturnType": "void",
        "Arguments": {
          "obj": "UnityEngine.GameObject"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tbase.CancelInvoke(new Action(this.Arm));\r\n\t\tthis.blocked = true;\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrapTrigger\", this, obj) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBasePlayer ply = obj.ToBaseEntity(false) as BasePlayer;\r\n\tthis.Trigger(ply);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTerrainInitialized",
      "HookName": "OnTerrainInitialized",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "TerrainMeta",
      "Category": "World",
      "MethodData": {
        "MethodName": "PostSetupComponents",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tTerrainExtension[] components = base.GetComponents<TerrainExtension>();\r\n\tfor (int i = 0; i < components.Length; i++)\r\n\t{\r\n\t\tcomponents[i].PostSetup();\r\n\t}\r\n\tInterface.CallHook(\"OnTerrainInitialized\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [FlameTurret]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "component": "BasePlayer",
        "instance": "FlameTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "FlameTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\twhile (enumerator.MoveNext())\r\n\t\t\t{\r\n\t\t\t\tBasePlayer component = enumerator.Current.GetComponent<BasePlayer>();\r\n\t\t\t\tif (!component.IsSleeping())\r\n\t\t\t\t{\r\n\t\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t\t}\r\n\t\t\t\t\tif (component.IsAlive() && component.transform.position.y <= this.GetEyePosition().y + 0.5f && (cachedTc == null || !cachedTc.IsAuthed(component)))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFindBurnable",
      "HookName": "OnFindBurnable",
      "HookParameters": {
        "instance": "BaseOven"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindBurnable",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "public Item FindBurnable()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnFindBurnable\", this);\r\n\tif (returnvar is Item)\r\n\t{\r\n\t\treturn (Item)returnvar;\r\n\t}\r\n\tif (base.inventory == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanStackItem",
      "HookName": "CanStackItem",
      "HookParameters": {
        "instance": "Item",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "CanStack",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "public bool CanStack(Item item)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanStackItem\", this, item);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (item == this)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExplosiveDropped",
      "HookName": "OnExplosiveDropped",
      "HookParameters": {
        "player": "BasePlayer",
        "baseEntity": "BaseEntity",
        "instance": "ThrownWeapon"
      },
      "ReturnBehavior": 0,
      "TargetType": "ThrownWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoDrop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbaseEntity.creatorEntity = msg.player;\r\n\tbaseEntity.skinID = this.skinID;\r\n\tbaseEntity.Spawn();\r\n\tthis.SetUpThrownWeapon(baseEntity);\r\n\tbase.StartAttackCooldown(this.repeatDelay);\r\n\tInterface.CallHook(\"OnExplosiveDropped\", msg.player, baseEntity, this);\r\n\tbase.UseItemAmount(1, true);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuyVendingItem",
      "HookName": "OnBuyVendingItem",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer",
        "num": "int",
        "num2": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "BuyItem",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (this.IsVending())\r\n\t{\r\n\t\trpc.player.ShowToast(GameTip.Styles.Red_Normal, VendingMachine.WaitForVendingMessage, false, Array.Empty<string>());\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBuyVendingItem\", this, rpc.player, num, num2) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num3 = 0;\r\n\tfor (int i = 0; i < this.sellOrders.sellOrders.Count; i++)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseVending",
      "HookName": "CanUseVending",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "VendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanOpenLootPanel",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelName": "string"
        }
      },
      "CodeAfterInjection": "public override bool CanOpenLootPanel(BasePlayer player, string panelName)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseVending\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn panelName == this.customerPanel || (base.CanOpenLootPanel(player, panelName) && this.CanPlayerAdmin(player));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAdministerVending",
      "HookName": "CanAdministerVending",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "VendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanPlayerAdmin",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanPlayerAdmin(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAdministerVending\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.PlayerBehind(player) && base.OccupiedCheck(player);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRefreshVendingStock",
      "HookName": "OnRefreshVendingStock",
      "HookParameters": {
        "instance": "VendingMachine",
        "itemDef": "ItemDefinition"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RefreshSellOrderStockLevel",
        "ReturnType": "void",
        "Arguments": {
          "itemDef": "ItemDefinition"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tFunc<global::Item, int> arg_BD_1;\r\n\t\t\t\tif ((arg_BD_1 = global::VendingMachine.<>c.<>9__33_0) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\targ_BD_1 = (global::VendingMachine.<>c.<>9__33_0 = new Func<global::Item, int>(global::VendingMachine.<>c.<>9.<RefreshSellOrderStockLevel>b__33_0));\r\n\t\t\t\t}\r\n\t\t\t\tInterface.CallHook(\"OnRefreshVendingStock\", this, itemDef);\r\n\t\t\t\targ_C5_1 = arg_BD_0.Sum(arg_BD_1) / num2;\r\n\t\t\t}\r\n\t\t\targ_C5_0.inStock = arg_C5_1;\r\n\t\t\tfloat itemCondition = 0f;\r\n\t\t\tfloat itemConditionMax = 0f;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnToggleVendingBroadcast",
      "HookName": "OnToggleVendingBroadcast",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_Broadcast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tBasePlayer player = msg.player;\r\n\tbool b = msg.read.Bit();\r\n\tif (this.CanPlayerAdmin(player))\r\n\t{\r\n\t\tbase.SetFlag(BaseEntity.Flags.Reserved4, b, false, true);\r\n\t\tInterface.CallHook(\"OnToggleVendingBroadcast\", this, player);\r\n\t\tthis.UpdateMapMarker(false);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDeleteVendingOffer",
      "HookName": "OnDeleteVendingOffer",
      "HookParameters": {
        "instance": "VendingMachine",
        "num": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_DeleteSellOrder",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.CanPlayerAdmin(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tInterface.CallHook(\"OnDeleteVendingOffer\", this, num);\r\n\tif (num >= 0 && num < this.sellOrders.sellOrders.Count)\r\n\t{\r\n\t\tProtoBuf.VendingMachine.SellOrder sellOrder = this.sellOrders.sellOrders[num];\r\n\t\tFacepunch.Rust.Analytics.Azure.OnVendingMachineOrderChanged(msg.player, this, sellOrder.itemToSellID, sellOrder.itemToSellAmount, sellOrder.itemToSellIsBP, sellOrder.currencyID, sellOrder.currencyAmountPerItem, sellOrder.currencyIsBP, false);\r\n\t\tthis.sellOrders.sellOrders.RemoveAt(num);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOpenVendingAdmin",
      "HookName": "OnOpenVendingAdmin",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenAdmin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.OpenShop(player);\r\n\tbase.ClientRPC(RpcTarget.Player(\"CLIENT_OpenAdminMenu\", player));\r\n\tInterface.CallHook(\"OnOpenVendingAdmin\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpen [VendingMachine]",
      "HookName": "OnVendingShopOpen",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenShop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!base.OccupiedCheck(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnVendingShopOpen\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.OpenShop(msg.player);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRotateVendingMachine",
      "HookName": "OnRotateVendingMachine",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_RotateVM",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[BaseEntity.RPC_Server, BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_RotateVM(BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnRotateVendingMachine\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanRotate())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPickupEntity",
      "HookName": "CanPickupEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseCombatEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanCompletePickup",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "protected virtual bool CanCompletePickup(BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanPickupEntity\", player, this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerUserSet",
      "HookName": "OnServerUserSet",
      "HookParameters": {
        "uid": "ulong",
        "group": "UserGroup",
        "username": "string",
        "notes": "string",
        "expiry": "long"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerUsers",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Set",
        "ReturnType": "void",
        "Arguments": {
          "uid": "ulong",
          "group": "ServerUsers/UserGroup",
          "username": "string",
          "notes": "string",
          "expiry": "long"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tgroup = group,\r\n\t\tusername = username,\r\n\t\tnotes = notes,\r\n\t\texpiry = expiry\r\n\t};\r\n\tInterface.CallHook(\"OnServerUserSet\", uid, group, username, notes, expiry);\r\n\tServerUsers.users.Add(uid, value);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerSave",
      "HookName": "OnServerSave",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "SaveRestore",
      "Category": "Server",
      "MethodData": {
        "MethodName": "DoAutomatedSave",
        "ReturnType": "System.Collections.IEnumerator",
        "Arguments": {
          "AndWait": "bool"
        }
      },
      "CodeAfterInjection": "[IteratorStateMachine(typeof(SaveRestore.<DoAutomatedSave>d__20))]\r\nprivate IEnumerator DoAutomatedSave(bool AndWait = false)\r\n{\r\n\tInterface.CallHook(\"OnServerSave\");\r\n\tSaveRestore.<DoAutomatedSave>d__20 expr_11 = new SaveRestore.<DoAutomatedSave>d__20(0);\r\n\texpr_11.<>4__this = this;\r\n\texpr_11.AndWait = AndWait;\r\n\treturn expr_11;\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemAction",
      "HookName": "OnItemAction",
      "HookParameters": {
        "item": "Item",
        "text": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ItemCmd",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tItem item = this.FindItemByUID(id);\r\n\tif (item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemAction\", item, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity entityOwner = item.GetEntityOwner();\r\n\tif (entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAssignBed",
      "HookName": "CanAssignBed",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "SleepingBag",
        "num": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0uL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanAssignBed\", msg.player, this, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Server.max_sleeping_bags > 0)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCodeEntered",
      "HookName": "OnCodeEntered",
      "HookParameters": {
        "instance": "CodeLock",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UnlockWithCode",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (this.IsCodeEntryBlocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = rpc.read.String(256, false);\r\n\tif (Interface.CallHook(\"OnCodeEntered\", this, rpc.player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = text == this.guestCode;\r\n\tbool flag2 = text == this.code;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [CodeLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryUnlock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanUnlock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsCodeEntryBlocked())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLock [code]",
      "HookName": "CanLock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryLock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.code.Length != 4)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.whitelistPlayers.Contains(rpc.player.userID))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanChangeCode",
      "HookName": "CanChangeCode",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock",
        "text": "string",
        "flag": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "CodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_ChangeCode",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.hasCode & flag)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanChangeCode\", rpc.player, this, text, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.hasCode && !flag)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [KeyLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "KeyLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Unlock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanUnlock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasLockPermission(rpc.player))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRecyclerToggle",
      "HookName": "OnRecyclerToggle",
      "HookParameters": {
        "instance": "Recycler",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (msg.player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRecyclerToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!flag && this.onlyOneUser && msg.player.inventory.loot.entitySource != this)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanRecycle",
      "HookName": "CanRecycle",
      "HookParameters": {
        "instance": "Recycler",
        "slot": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "HasRecyclable",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tItem slot = base.inventory.GetSlot(i);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tobject returnvar = Interface.CallHook(\"CanRecycle\", this, slot);\r\n\t\t\tif (returnvar is bool)\r\n\t\t\t{\r\n\t\t\t\treturn (bool)returnvar;\r\n\t\t\t}\r\n\t\t\tif (slot.info.Blueprint != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRecycle",
      "HookName": "OnItemRecycle",
      "HookParameters": {
        "slot": "Item",
        "instance": "Recycler"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RecycleThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tItem slot = base.inventory.GetSlot(i);\r\n\t\tif (this.CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemRecycle\", slot, this) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (slot.hasCondition)\r\n\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretDeauthorize",
      "HookName": "OnTurretDeauthorize",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "RemoveSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BaseEntity.RPCMessage rpc = rpc2;\r\n\tif (this.booting || this.IsOnline() || !this.IsAuthed(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretDeauthorize\", this, rpc2.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == rpc.player.userID);\r\n\tthis.authDirty = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSetBedPublic",
      "HookName": "CanSetBedPublic",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "SleepingBag"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_MakePublic",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == this.IsPublic())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanSetBedPublic\", msg.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPublic(flag);\r\n\tif (!this.IsPublic())\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCraft [ItemCrafter]",
      "HookName": "CanCraft",
      "HookParameters": {
        "instance": "ItemCrafter",
        "bp": "ItemBlueprint",
        "amount": "int",
        "free": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanCraft",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "amount": "int",
          "free": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (num > 8f)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanCraft\", this, bp, amount, free);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (amount < 1 || amount > bp.targetItem.craftingStackable)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterStrafeTarget",
      "HookName": "CanHelicopterStrafeTarget",
      "HookParameters": {
        "instance": "PatrolHelicopterAI",
        "ply": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "ValidRocketTarget",
        "ReturnType": "bool",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool ValidRocketTarget(BasePlayer ply)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterStrafeTarget\", this, ply);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !(ply == null) && !ply.IsNearEnemyBase();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDropped",
      "HookName": "OnItemDropped",
      "HookParameters": {
        "instance": "Item",
        "arg_33_0": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Drop",
        "ReturnType": "BaseEntity",
        "Arguments": {
          "vPos": "UnityEngine.Vector3",
          "vVelocity": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\telse\r\n\t{\r\n\t\tthis.Remove(0f);\r\n\t}\r\n\tInterface.CallHook(\"OnItemDropped\", this, baseEntity);\r\n\tthis.RemoveFromContainer();\r\n\treturn baseEntity;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanMoveItem",
      "HookName": "CanMoveItem",
      "HookParameters": {
        "item": "Item",
        "instance": "PlayerInventory",
        "itemContainerId": "ItemContainerId",
        "num": "int",
        "num2": "int",
        "itemMoveModifier": "ItemMoveModifier"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MoveItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tmsg.player.ShowToast(GameTip.Styles.Error, PlayerInventoryErrors.InvalidItem, false, Array.Empty<string>());\r\n\t\tConstructionErrors.Log(msg.player, id.ToString());\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanMoveItem\", item, this, itemContainerId, num, num2, itemMoveModifier) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tBaseEntity entityOwner = item.GetEntityOwner();\r\n\tif (entityOwner != null && entityOwner == msg.player && msg.player.IsRestrainedOrSurrendering)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHideStash",
      "HookName": "CanHideStash",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "StashContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "StashContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_HideStash",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[BaseEntity.RPC_Server, BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_HideStash(BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (Interface.CallHook(\"CanHideStash\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\r\n\tthis.SetHidden(true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCombineDroppedItem",
      "HookName": "CanCombineDroppedItem",
      "HookParameters": {
        "instance": "DroppedItem",
        "di": "DroppedItem"
      },
      "ReturnBehavior": 1,
      "TargetType": "DroppedItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "OnDroppedOn",
        "ReturnType": "void",
        "Arguments": {
          "di": "DroppedItem"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (di.item == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanCombineDroppedItem\", this, di) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (di.item.info != this.item.info)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemRecycle [2]",
      "HookName": "OnItemRecycle",
      "ReturnBehavior": 0,
      "TargetType": "Recycler",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RecycleThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tfor (int i = 0; i < 6; i++)\r\n\t{\r\n\t\tglobal::Item slot = base.inventory.GetSlot(i);\r\n\t\tif (this.CanBeRecycled(slot))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemRecycle\", slot, this) != null)\r\n\t\t\t{\r\n\t\t\t\tif (!base.HasRecyclable())\r\n\t\t\t\t{\r\n\t\t\t\t\tbase.StopRecycling();\r\n\t\t\t\t\treturn;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnContainerDropItems",
      "HookName": "OnContainerDropItems",
      "HookParameters": {
        "container": "ItemContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "DropUtil",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DropItems",
        "ReturnType": "void",
        "Arguments": {
          "container": "ItemContainer",
          "position": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (container.itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnContainerDropItems\", container) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 0.25f;\r\n\tglobal::Item[] array = container.itemList.ToArray();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNpcEat [BaseNpc]",
      "HookName": "CanNpcEat",
      "HookParameters": {
        "instance": "BaseNpc",
        "best": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNpc",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "WantsToEat",
        "ReturnType": "bool",
        "Arguments": {
          "best": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public virtual bool WantsToEat(global::BaseEntity best)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanNpcEat\", this, best);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn best.HasTrait(global::BaseEntity.TraitFlag.Food) && !best.HasTrait(global::BaseEntity.TraitFlag.Alive);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcAttack [BaseNpc]",
      "HookName": "OnNpcAttack",
      "HookParameters": {
        "instance": "BaseNpc",
        "AttackTarget": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNpc",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "StartAttack",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.AttackReady())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnNpcAttack\", this, this.AttackTarget) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif ((this.AttackTarget.ServerPosition - this.ServerPosition).magnitude > this.AttackRange)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMeleeAttack",
      "HookName": "OnMeleeAttack",
      "HookParameters": {
        "player": "BasePlayer",
        "hitInfo": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMelee",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerAttack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\thitInfo.Initiator = player;\r\n\t\t\t\thitInfo.Weapon = this;\r\n\t\t\t\thitInfo.WeaponPrefab = this;\r\n\t\t\t\thitInfo.Predicted = msg.connection;\r\n\t\t\t\thitInfo.damageProperties = this.damageProperties;\r\n\t\t\t\tif (Interface.CallHook(\"OnMeleeAttack\", player, hitInfo) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tif (hitInfo.IsNaNOrInfinity())\r\n\t\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerViolation",
      "HookName": "OnPlayerViolation",
      "HookParameters": {
        "ply": "BasePlayer",
        "type": "AntiHackType",
        "amount": "float",
        "gameObject": "GameObject"
      },
      "ReturnBehavior": 1,
      "TargetType": "AntiHack",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AddViolation",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer",
          "type": "AntiHackType",
          "amount": "float",
          "gameObject": "UnityEngine.GameObject"
        }
      },
      "CodeAfterInjection": "public static void AddViolation(global::BasePlayer ply, global::AntiHackType type, float amount, GameObject gameObject = null)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerViolation\", ply, type, amount, gameObject) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"AntiHack.AddViolation\", 0))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanChangeGrade",
      "HookName": "CanChangeGrade",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BuildingBlock",
        "iGrade": "Enum",
        "iSkin": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanChangeToGrade",
        "ReturnType": "bool",
        "Arguments": {
          "iGrade": "BuildingGrade/Enum",
          "iSkin": "ulong",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanChangeToGrade(global::BuildingGrade.Enum iGrade, ulong iSkin, global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanChangeGrade\", player, this, iGrade, iSkin);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn (player.IsInCreativeMode && ConVar.Creative.freeBuild) || (this.HasUpgradePrivilege(iGrade, iSkin, player) && !this.IsUpgradeBlocked());\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAffordUpgrade",
      "HookName": "CanAffordUpgrade",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BuildingBlock",
        "iGrade": "Enum",
        "iSkin": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanAffordUpgrade",
        "ReturnType": "bool",
        "Arguments": {
          "iGrade": "BuildingGrade/Enum",
          "iSkin": "ulong",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanAffordUpgrade(global::BuildingGrade.Enum iGrade, ulong iSkin, global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAffordUpgrade\", player, this, iGrade, iSkin);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (player != null && player.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDemolish",
      "HookName": "CanDemolish",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "DecayEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanDemolish",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanDemolish(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanDemolish\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.IsDemolishSupported && this.IsDemolishable() && this.HasDemolishPrivilege(player);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseMailbox",
      "HookName": "CanUseMailbox",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "Mailbox"
      },
      "ReturnBehavior": 1,
      "TargetType": "Mailbox",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerIsOwner",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerIsOwner(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseMailbox\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.CanBuild();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSpinWheel",
      "HookName": "OnSpinWheel",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "SpinnerWheel"
      },
      "ReturnBehavior": 1,
      "TargetType": "SpinnerWheel",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Spin",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.AnyoneSpin() || rpc.player.CanBuild())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnSpinWheel\", rpc.player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.velocity > 15f)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeTargeted [GunTrap]",
      "HookName": "CanBeTargeted",
      "HookParameters": {
        "component": "BasePlayer",
        "instance": "GunTrap"
      },
      "ReturnBehavior": 1,
      "TargetType": "GunTrap",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\twhile (enumerator.MoveNext())\r\n\t\t{\r\n\t\t\tglobal::BasePlayer component = enumerator.Current.GetComponent<global::BasePlayer>();\r\n\t\t\tif (!component.IsSleeping() && component.IsAlive() && (cachedTc == null || !cachedTc.IsAuthed(component)))\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"CanBeTargeted\", component, this);\r\n\t\t\t\tif (returnvar is bool)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn (bool)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tlist.Clear();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnRconInitialize",
      "HookName": "IOnRconInitialize",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.RCon",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public static void Initialize()\r\n{\r\n\tif (Interface.CallHook(\"IOnRconInitialize\") != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (RCon.Port == 0)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMaxStackable",
      "HookName": "OnMaxStackable",
      "HookParameters": {
        "instance": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MaxStackable",
        "ReturnType": "int",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tint num = this.info.stackable;\r\n\tif (this.parent != null && this.parent.maxStackSize > 0)\r\n\t{\r\n\t\tnum = Mathf.Min(this.parent.maxStackSize, num);\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnMaxStackable\", this);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\treturn num;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWeaponReload",
      "HookName": "OnWeaponReload",
      "HookParameters": {
        "instance": "BaseProjectile",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StartReload",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\t\tthis.reloadStarted = false;\r\n\t\tthis.reloadFinished = false;\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnWeaponReload\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.reloadFinished = false;\r\n\tthis.reloadStarted = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRespawn",
      "HookName": "OnPlayerRespawn",
      "HookParameters": {
        "instance": "BasePlayer",
        "spawnPoint": "SpawnPoint"
      },
      "ReturnBehavior": 3,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Respawn",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer.SpawnPoint spawnPoint = global::ServerMgr.FindSpawnPoint(this, 0uL);\r\n\tif (ConVar.Server.respawnAtDeathPosition && this.ServerCurrentDeathNote != null)\r\n\t{\r\n\t\tspawnPoint.pos = this.ServerCurrentDeathNote.worldPosition;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnPlayerRespawn\", this, spawnPoint);\r\n\tif (returnvar is global::BasePlayer.SpawnPoint)\r\n\t{\r\n\t\tspawnPoint = (global::BasePlayer.SpawnPoint)returnvar;\r\n\t}\r\n\tthis.RespawnAt(spawnPoint.pos, spawnPoint.rot, null);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPickupLock",
      "HookName": "CanPickupLock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_TakeLock",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanRemove)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanPickupLock\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.IsLocked())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDispenserBonus",
      "HookName": "OnDispenserBonus",
      "HookParameters": {
        "instance": "ResourceDispenser",
        "player": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 3,
      "TargetType": "ResourceDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "AssignFinishBonus",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "fraction": "float",
          "weapon": "AttackEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tint num = Mathf.CeilToInt((float)((int)current.amount) * Mathf.Clamp01(fraction));\r\n\t\t\tint num2 = this.CalculateGatherBonus(player, current, (float)num);\r\n\t\t\tglobal::Item item = global::ItemManager.Create(current.itemDef, num + num2, 0uL, true);\r\n\t\t\tif (item != null)\r\n\t\t\t{\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnDispenserBonus\", this, player, item);\r\n\t\t\t\tif (returnvar is global::Item)\r\n\t\t\t\t{\r\n\t\t\t\t\titem = (global::Item)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tthis.ApplyItemOwnership(player, item);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanVendingAcceptItem",
      "HookName": "CanVendingAcceptItem",
      "HookParameters": {
        "instance": "VendingMachine",
        "item": "Item",
        "targetSlot": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanAcceptItem",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "public bool CanAcceptItem(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanVendingAcceptItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::ItemContainer expr_29 = item.GetRootContainer();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiftUse",
      "HookName": "OnLiftUse",
      "HookParameters": {
        "instance": "Lift",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Lift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "RPC_UseLift",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLiftUse\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.MoveUp();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerUserRemove",
      "HookName": "OnServerUserRemove",
      "HookParameters": {
        "uid": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerUsers",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Remove",
        "ReturnType": "void",
        "Arguments": {
          "uid": "ulong"
        }
      },
      "CodeAfterInjection": "public static void Remove(ulong uid)\r\n{\r\n\tInterface.CallHook(\"OnServerUserRemove\", uid);\r\n\tglobal::ServerUsers.users.Remove(uid);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerKicked",
      "HookName": "OnPlayerKicked",
      "HookParameters": {
        "instance": "BasePlayer",
        "reason": "string",
        "reserveSlot": "bool"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Kick",
        "ReturnType": "void",
        "Arguments": {
          "reason": "string",
          "reserveSlot": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.net.connection.canReserveSlot = reserveSlot;\r\n\tNet.sv.Kick(this.net.connection, reason, false);\r\n\tInterface.CallHook(\"OnPlayerKicked\", this, reason, reserveSlot);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBradleyApcTarget",
      "HookName": "CanBradleyApcTarget",
      "HookParameters": {
        "instance": "BradleyAPC",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "VisibilityTest",
        "ReturnType": "bool",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\telse\r\n\t{\r\n\t\tDebug.LogWarning(\"Standard vis test!\");\r\n\t\tflag = base.IsVisible(ent.CenterPoint(), float.PositiveInfinity);\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanBradleyApcTarget\", this, ent);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn flag;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcInitialize",
      "HookName": "OnBradleyApcInitialize",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Initialize()\r\n{\r\n\tif (Interface.CallHook(\"OnBradleyApcInitialize\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.myRigidBody.centerOfMass = this.centerOfMass.localPosition;\r\n\tthis.destination = base.transform.position;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcHunt",
      "HookName": "OnBradleyApcHunt",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "UpdateMovement_Hunt",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void UpdateMovement_Hunt()\r\n{\r\n\tif (Interface.CallHook(\"OnBradleyApcHunt\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.patrolPath == null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcPatrol",
      "HookName": "OnBradleyApcPatrol",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "UpdateMovement_Patrol",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tthis.nextPatrolTime = Time.time + 20f;\r\n\tif (this.HasPath() && !this.IsAtFinalDestination())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBradleyApcPatrol\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::IAIPathInterestNode randomInterestNodeAwayFrom = this.patrolPath.GetRandomInterestNodeAwayFrom(base.transform.position, 10f);\r\n\tglobal::IAIPathNode closestToPoint = this.patrolPath.GetClosestToPoint(randomInterestNodeAwayFrom.Position);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopCompleteTrade",
      "HookName": "OnShopCompleteTrade",
      "HookParameters": {
        "instance": "ShopFront"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "CompleteTrade",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void CompleteTrade()\r\n{\r\n\tif (this.vendorPlayer != null && this.customerPlayer != null && base.HasFlag(global::BaseEntity.Flags.Reserved1) && base.HasFlag(global::BaseEntity.Flags.Reserved2))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnShopCompleteTrade\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\ttry\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterUseNapalm",
      "HookName": "CanHelicopterUseNapalm",
      "HookParameters": {
        "instance": "PatrolHelicopterAI"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanUseNapalm",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanUseNapalm()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterUseNapalm\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn Time.realtimeSinceStartup - this.lastNapalmTime >= UnityEngine.Random.Range(25f, 35f);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterStrafe",
      "HookName": "CanHelicopterStrafe",
      "HookParameters": {
        "instance": "PatrolHelicopterAI"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanStrafe",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanStrafe()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterStrafe\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn Time.realtimeSinceStartup - this.lastStrafeTime >= UnityEngine.Random.Range(15f, 25f) && this.CanInterruptState();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterTarget",
      "HookName": "CanHelicopterTarget",
      "HookParameters": {
        "instance": "PatrolHelicopterAI",
        "ply": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "PlayerVisible",
        "ReturnType": "bool",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool PlayerVisible(global::BasePlayer ply)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterTarget\", this, ply);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tbool result;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDismountEntity",
      "HookName": "CanDismountEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this._mounted != player)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanDismountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseVehicle baseVehicle = this.VehicleParent();\r\n\tif (lite)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDismounted",
      "HookName": "OnEntityDismounted",
      "HookParameters": {
        "instance": "BaseMountable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tplayer.ClientRPC(global::RpcTarget.Player(\"ForcePositionTo\", player), position);\r\n\t\tplayer.ClientRPC(global::RpcTarget.NetworkGroup(\"ForceResetRotation\", player));\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnDismountEntity(player, this, baseVehicle);\r\n\tInterface.CallHook(\"OnEntityDismounted\", this, player);\r\n\tthis.OnPlayerDismounted(player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDismounted [lite]",
      "HookName": "OnEntityDismounted",
      "HookParameters": {
        "instance": "BaseMountable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DismountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "lite": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tif (baseVehicle != null)\r\n\t\t{\r\n\t\t\tbaseVehicle.PlayerDismounted(player, this);\r\n\t\t}\r\n\t\tthis.OnPlayerDismounted(player);\r\n\t\tInterface.CallHook(\"OnEntityDismounted\", this, player);\r\n\t\treturn;\r\n\t}\r\n\tVector3 position;\r\n\tif (!this.GetDismountPosition(player, out position, false) || base.Distance(position) > 10f)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanMountEntity",
      "HookName": "CanMountEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.mountAnchor == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanMountEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayer.EnsureDismounted();\r\n\tthis._mounted = player;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMounted",
      "HookName": "OnEntityMounted",
      "HookParameters": {
        "instance": "BaseMountable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MountPlayer",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tplayer.OverrideViewAngles(transform.rotation.eulerAngles);\r\n\tthis._mounted.eyes.NetworkUpdate(transform.rotation);\r\n\tplayer.SendNetworkUpdateImmediate(false);\r\n\tFacepunch.Rust.Analytics.Azure.OnMountEntity(player, this, this.VehicleParent());\r\n\tthis.OnPlayerMounted();\r\n\tInterface.CallHook(\"OnEntityMounted\", this, player);\r\n\tif (this.allowedGestures == global::BaseMountable.MountGestureType.None && player.InGesture)\r\n\t{\r\n\t\tplayer.Server_CancelGesture();\r\n\t}\r\n\telse if (this.allowedGestures == global::BaseMountable.MountGestureType.UpperBody && player.InGesture && player.CurrentGestureIsFullBody)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCraft [PlayerBlueprints]",
      "HookName": "CanCraft",
      "HookParameters": {
        "instance": "PlayerBlueprints",
        "itemDefinition": "ItemDefinition",
        "skinItemId": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerBlueprints",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanCraft",
        "ReturnType": "bool",
        "Arguments": {
          "itemid": "int",
          "skinItemId": "int",
          "playerId": "ulong"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::ItemDefinition itemDefinition = global::ItemManager.FindItemDefinition(itemid);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanCraft\", this, itemDefinition, skinItemId);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn (skinItemId == 0 || base.baseEntity.UnlockAllSkins || this.CheckSkinOwnership(skinItemId, playerId)) && base.baseEntity.currentCraftLevel >= (float)itemDefinition.Blueprint.GetWorkbenchLevel() && this.HasUnlocked(itemDefinition);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResearchCostDetermine [Item]",
      "HookName": "OnResearchCostDetermine",
      "HookParameters": {
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ScrapForResearch",
        "ReturnType": "int",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "public static int ScrapForResearch(global::Item item)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnResearchCostDetermine\", item);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\treturn global::ResearchTable.ScrapForResearch(item.info);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootSpawn [LootContainer]",
      "HookName": "OnLootSpawn",
      "HookParameters": {
        "instance": "LootContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "LootContainer",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "SpawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tDebug.Log(\"CONTACT DEVELOPERS! LootContainer::PopulateLoot has null inventory!!!\");\r\n\t\treturn;\r\n\t}\r\n\tbase.inventory.Clear();\r\n\tglobal::ItemManager.DoRemoves();\r\n\tif (Interface.CallHook(\"OnLootSpawn\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PopulateLoot();\r\n\tif (this.shouldRefreshContents)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDropActiveItem",
      "HookName": "CanDropActiveItem",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ShouldDropActiveItem",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual bool ShouldDropActiveItem()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanDropActiveItem\", this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerActiveShieldDrop",
      "HookName": "OnPlayerActiveShieldDrop",
      "HookParameters": {
        "player": "BasePlayer",
        "shield": "Shield"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerBelt",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DropActive",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "velocity": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "public void DropActive(Vector3 position, Vector3 velocity)\r\n{\r\n\tglobal::Shield shield;\r\n\tif (this.player.GetActiveShield(out shield))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnPlayerActiveShieldDrop\", this.player, shield) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::DroppedItem droppedItem = shield.GetItem().Drop(position, velocity, default(Quaternion)) as global::DroppedItem;\r\n\t\tif (droppedItem != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretClearList",
      "HookName": "OnTurretClearList",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "ClearList",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.booting || this.IsOnline() || !player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretClearList\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.Clear();\r\n\tthis.authDirty = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretModeToggle [Peacekeeper]",
      "HookName": "OnTurretModeToggle",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SERVER_Peacekeeper",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\nprivate void SERVER_Peacekeeper(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (this.IsAuthed(rpc.player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTurretModeToggle\", this, rpc.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.SetPeacekeepermode(true);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWorldProjectileCreate",
      "HookName": "OnWorldProjectileCreate",
      "HookParameters": {
        "info": "HitInfo",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CreateWorldProjectile",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo",
          "itemDef": "ItemDefinition",
          "itemMod": "ItemModProjectile",
          "projectilePrefab": "Projectile",
          "recycleItem": "Item"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 projectileVelocity = info.ProjectileVelocity;\r\n\tglobal::Item item = (recycleItem != null) ? recycleItem : global::ItemManager.Create(itemDef, 1, 0uL, true);\r\n\tif (Interface.CallHook(\"OnWorldProjectileCreate\", info, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseEntity baseEntity;\r\n\tif (!info.DidHit)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnActiveItemChange",
      "HookName": "OnActiveItemChange",
      "HookParameters": {
        "instance": "BasePlayer",
        "activeItem": "Item",
        "itemID": "ItemId"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UpdateActiveItem",
        "ReturnType": "void",
        "Arguments": {
          "itemID": "ItemId"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (this.IsItemHoldRestricted(item))\r\n\t{\r\n\t\titemID = default(ItemId);\r\n\t}\r\n\tglobal::Item activeItem = this.GetActiveItem();\r\n\tif (Interface.CallHook(\"OnActiveItemChange\", this, activeItem, itemID) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.svActiveItemID = default(ItemId);\r\n\tif (activeItem != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAmmoSwitch",
      "HookName": "OnAmmoSwitch",
      "HookParameters": {
        "instance": "BaseProjectile",
        "ownerPlayer": "BasePlayer",
        "itemDefinition": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "SwitchAmmoTo",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::ItemModProjectile component = itemDefinition.GetComponent<global::ItemModProjectile>();\r\n\tif (!component || !component.IsAmmo(this.primaryMagazine.definition.ammoTypes))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnAmmoSwitch\", this, ownerPlayer, itemDefinition) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.primaryMagazine.contents > 0)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerVoice",
      "HookName": "OnPlayerVoice",
      "HookParameters": {
        "instance": "BasePlayer",
        "data": "Byte[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnReceivedVoice",
        "ReturnType": "void",
        "Arguments": {
          "data": "System.Byte[]"
        }
      },
      "CodeAfterInjection": "public void OnReceivedVoice(byte[] data)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerVoice\", this, data) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_1A = Network.Net.sv.StartWrite();\r\n\texpr_1A.PacketID(Message.Type.VoiceData);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "CanBeTargeted [FlameTurret] [cleanup]",
      "HookName": "CanBeTargeted [patch]",
      "ReturnBehavior": 0,
      "TargetType": "FlameTurret",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "CanBeTargeted [GunTrap] [cleanup]",
      "HookName": "CanBeTargeted [patch]",
      "ReturnBehavior": 0,
      "TargetType": "GunTrap",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CheckTrigger",
        "ReturnType": "bool",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnLiftUse [ProceduralLift]",
      "HookName": "OnLiftUse",
      "HookParameters": {
        "instance": "ProceduralLift",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ProceduralLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "RPC_UseLift",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLiftUse\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.IsBusy())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [LootableCorpse]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "LootableCorpse"
      },
      "ReturnBehavior": 1,
      "TargetType": "LootableCorpse",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_LootCorpse",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.containers == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [ResourceContainer]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ResourceContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartLootingContainer",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.lootable)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(base.baseEntity, true))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [DroppedItemContainer]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "DroppedItemContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "DroppedItemContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_OpenLoot",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer player = rpc.player;\r\n\tif (!player || !player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityBuilt",
      "HookName": "OnEntityBuilt",
      "HookParameters": {
        "instance": "Planner",
        "result": "GameObject"
      },
      "ReturnBehavior": 0,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoBuild",
        "ReturnType": "BaseEntity",
        "Arguments": {
          "target": "Construction/Target",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tglobal::ConstructionErrors.Log(ownerPlayer, global::Construction.lastPlacementErrorDebug);\r\n\t}\r\n\tif (gameObject != null)\r\n\t{\r\n\t\tInterface.CallHook(\"OnEntityBuilt\", this, gameObject);\r\n\t\tglobal::Deployable deployable = this.GetDeployable();\r\n\t\tglobal::BaseEntity baseEntity = gameObject.ToBaseEntity(false);\r\n\t\tif (baseEntity != null && deployable != null)\r\n\t\t{\r\n\t\t\tif (this.ShouldParent(target.entity, deployable))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorKnocked [Door]",
      "HookName": "OnDoorKnocked",
      "HookParameters": {
        "instance": "Door",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Door",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_KnockDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tcomponent.Knock(rpc.player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tglobal::Effect.server.Run(this.knockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false, null);\r\n\tInterface.CallHook(\"OnDoorKnocked\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnLootEntity [patch]",
      "HookName": "OnLootEntity [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "StartLootingEntity",
        "ReturnType": "bool",
        "Arguments": {
          "targetEntity": "BaseEntity",
          "doPositionChecks": "bool"
        }
      }
    },
    {
      "Type": 1,
      "Name": "OnLootItem [patch]",
      "HookName": "OnLootItem [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PlayerLoot",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "StartLootingItem",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item"
        }
      }
    },
    {
      "Type": 1,
      "Name": "OnPlayerAttack [melee, patch]",
      "HookName": "OnPlayerAttack [melee, patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseMelee",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "DoAttackShared",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnPlayerInput",
      "HookName": "OnPlayerInput",
      "HookParameters": {
        "instance": "BasePlayer",
        "serverInput": "InputState"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnReceiveTick",
        "ReturnType": "void",
        "Arguments": {
          "msg": "PlayerTick",
          "wasPlayerStalled": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.serverInput.current.buttons != this.serverInput.previous.buttons)\r\n\t{\r\n\t\tthis.ResetInputIdleTime();\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerInput\", this, this.serverInput) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsReceivingSnapshot)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnNpcTarget [BaseNpc]",
      "HookName": "IOnNpcTarget",
      "HookParameters": {
        "instance": "BaseNpc",
        "target": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNpc",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetWantsToAttack",
        "ReturnType": "float",
        "Arguments": {
          "target": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public float GetWantsToAttack(global::BaseEntity target)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"IOnNpcTarget\", this, target);\r\n\tif (returnvar is float)\r\n\t{\r\n\t\treturn (float)returnvar;\r\n\t}\r\n\treturn this.WantsToAttack(target);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHackCrate",
      "HookName": "CanHackCrate",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 1,
      "TargetType": "HackableLockedCrate",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Hack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.IsBeingHacked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanHackCrate\", msg.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnLockedCrateStarted(msg.player, this);\r\n\tthis.originalHackerPlayerId = msg.player.userID;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateHack",
      "HookName": "OnCrateHack",
      "HookParameters": {
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartHacking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void StartHacking()\r\n{\r\n\tInterface.CallHook(\"OnCrateHack\", this);\r\n\tbase.BroadcastEntityMessage(\"HackingStarted\", 20f, 256);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, true, false, true);\r\n\tbase.InvokeRepeating(new Action(this.HackProgress), 1f, 1f);\r\n\tbase.ClientRPC(global::RpcTarget.NetworkGroup(\"UpdateHackProgress\"), 0, (int)global::HackableLockedCrate.requiredHackSeconds);\r\n\tthis.RefreshDecay();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateHackEnd",
      "HookName": "OnCrateHackEnd",
      "HookParameters": {
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "HackProgress",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void HackProgress()\r\n{\r\n\tthis.hackSeconds += 1f;\r\n\tif (this.hackSeconds > global::HackableLockedCrate.requiredHackSeconds)\r\n\t{\r\n\t\tInterface.CallHook(\"OnCrateHackEnd\", this);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnLockedCrateFinished(this.originalHackerPlayerId, this);\r\n\t\tif (this.originalHackerPlayer != null && this.originalHackerPlayer.serverClan != null)\r\n\t\t{\r\n\t\t\tthis.originalHackerPlayer.AddClanScore(ClanScoreEventType.HackedCrate, 1, null, null, null, null);\r\n\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateLanded",
      "HookName": "OnCrateLanded",
      "HookParameters": {
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "LandCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void LandCheck()\r\n{\r\n\tif (this.hasLanded)\r\n\t{\r\n\t\tInterface.CallHook(\"OnCrateLanded\", this);\r\n\t\treturn;\r\n\t}\r\n\tRaycastHit raycastHit;\r\n\tif (Physics.Raycast(new Ray(base.transform.position + Vector3.up * 0.5f, Vector3.down), out raycastHit, 1f, 1084293377))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateDropped",
      "HookName": "OnCrateDropped",
      "HookParameters": {
        "instance": "HackableLockedCrate"
      },
      "ReturnBehavior": 0,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SetWasDropped",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void SetWasDropped()\r\n{\r\n\tthis.wasDropped = true;\r\n\tInterface.CallHook(\"OnCrateDropped\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentStart",
      "HookName": "OnExperimentStart",
      "HookParameters": {
        "instance": "Workbench",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_BeginExperiment",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tplayer.ChatMessage(\"You have already unlocked everything for this workbench tier.\");\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentStart\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item slot = base.inventory.GetSlot(0);\r\n\tif (slot != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanHelicopterDropCrate",
      "HookName": "CanHelicopterDropCrate",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanDropCrate",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanDropCrate()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanHelicopterDropCrate\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.numCrates > 0;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterDropCrate",
      "HookName": "OnHelicopterDropCrate",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 0,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "DropCrate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tVector3 pos = base.transform.position + Vector3.down * 5f;\r\n\tQuaternion rot = Quaternion.Euler(0f, UnityEngine.Random.Range(0f, 360f), 0f);\r\n\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.lockedCratePrefab.resourcePath, pos, rot, true);\r\n\tif (baseEntity)\r\n\t{\r\n\t\tInterface.CallHook(\"OnHelicopterDropCrate\", this);\r\n\t\tbaseEntity.SendMessage(\"SetWasDropped\");\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tthis.numCrates--;\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterAttack",
      "HookName": "OnHelicopterAttack",
      "HookParameters": {
        "instance": "CH47HelicopterAIController",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterAttack\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.OnAttacked(info);\r\n\tthis.InitiateAnger();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDestroy [CH47Helicopter]",
      "HookName": "OnEntityDestroy",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnDied",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnDied(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityDestroy\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.OutOfCrates())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterOutOfCrates",
      "HookName": "OnHelicopterOutOfCrates",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "OutOfCrates",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool OutOfCrates()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnHelicopterOutOfCrates\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.numCrates <= 0;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterDropDoorOpen",
      "HookName": "OnHelicopterDropDoorOpen",
      "HookParameters": {
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetDropDoorOpen",
        "ReturnType": "void",
        "Arguments": {
          "open": "bool"
        }
      },
      "CodeAfterInjection": "public void SetDropDoorOpen(bool open)\r\n{\r\n\tif (Interface.CallHook(\"OnHelicopterDropDoorOpen\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, open, false, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "CanRenameBed",
      "HookName": "CanRenameBed",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "SleepingBag",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Rename",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!msg.player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String(256, false);\r\n\tif (Interface.CallHook(\"CanRenameBed\", msg.player, this, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttext = global::WordFilter.Filter(text);\r\n\tif (string.IsNullOrEmpty(text))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAddVendingOffer",
      "HookName": "OnAddVendingOffer",
      "HookParameters": {
        "instance": "VendingMachine",
        "sellOrder": "SellOrder"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "AddSellOrder",
        "ReturnType": "void",
        "Arguments": {
          "itemToSellID": "int",
          "itemToSellAmount": "int",
          "currencyToUseID": "int",
          "currencyAmount": "int",
          "bpState": "byte"
        }
      },
      "CodeAfterInjection": "//---\r\n\tsellOrder.itemToSellAmount = itemToSellAmount;\r\n\tsellOrder.currencyID = currencyToUseID;\r\n\tsellOrder.currencyAmountPerItem = currencyAmount;\r\n\tsellOrder.currencyIsBP = (bpState == 3 || bpState == 2);\r\n\tsellOrder.itemToSellIsBP = (bpState == 3 || bpState == 1);\r\n\tInterface.CallHook(\"OnAddVendingOffer\", this, sellOrder);\r\n\tthis.sellOrders.sellOrders.Add(sellOrder);\r\n\tthis.RefreshSellOrderStockLevel(itemDefinition);\r\n\tthis.UpdateMapMarker(false);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootPlayer",
      "HookName": "OnLootPlayer",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_LootPlayer",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n\t\tplayer.inventory.loot.AddContainer(this.inventory.containerMain);\r\n\t\tplayer.inventory.loot.AddContainer(this.inventory.containerWear);\r\n\t\tplayer.inventory.loot.AddContainer(this.inventory.containerBelt);\r\n\t\tInterface.CallHook(\"OnLootPlayer\", this, player);\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t\tplayer.RadioactiveLootCheck(player.inventory.loot.containers);\r\n\t\tplayer.ClientRPC(global::RpcTarget.Player(\"RPC_OpenLootPanel\", player), \"player_corpse\");\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFlameThrowerBurn",
      "HookName": "OnFlameThrowerBurn",
      "HookParameters": {
        "instance": "FlameThrower",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "FlameThrower",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "FlameTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.fireballPrefab.resourcePath, vector, default(Quaternion), true);\r\n\t\t\tif (baseEntity)\r\n\t\t\t{\r\n\t\t\t\tInterface.CallHook(\"OnFlameThrowerBurn\", this, baseEntity);\r\n\t\t\t\tbaseEntity.creatorEntity = ownerPlayer;\r\n\t\t\t\tglobal::FireBall fireBall = baseEntity as global::FireBall;\r\n\t\t\t\tif (fireBall != null && ownerPlayer.IsNpc)\r\n\t\t\t\t{\r\n\t\t\t\t\tfireBall.ignoreNPC = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireBallDamage",
      "HookName": "OnFireBallDamage",
      "HookParameters": {
        "instance": "FireBall",
        "current": "BaseCombatEntity",
        "hitInfo": "HitInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "FireBall",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DoRadialDamage",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tglobal::Effect.server.Run(\"assets/bundled/prefabs/fx/impacts/additive/fire.prefab\", current, 0u, new Vector3(0f, 1f, 0f), Vector3.up, null, false, null);\r\n\t\t\t}\r\n\t\t\thitInfo.PointEnd = current.transform.position;\r\n\t\t\thitInfo.HitPositionWorld = current.transform.position;\r\n\t\t\thitInfo.damageTypes.Set(Rust.DamageType.Heat, this.damagePerSecond * this.tickRate);\r\n\t\t\tInterface.CallHook(\"OnFireBallDamage\", this, current, hitInfo);\r\n\t\t\tcurrent.OnAttacked(hitInfo);\r\n\t\t}\r\n\t}\r\n\tPool.FreeUnmanaged<global::BaseCombatEntity>(ref list);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireBallSpread",
      "HookName": "OnFireBallSpread",
      "HookParameters": {
        "instance": "FireBall",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "FireBall",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "TryToSpread",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tbaseEntity.transform.position = base.transform.position + Vector3.up * 0.25f;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tVector3 modifiedAimConeDirection = global::AimConeUtil.GetModifiedAimConeDirection(45f, Vector3.up, true);\r\n\t\t\tbaseEntity.creatorEntity = ((this.creatorEntity == null) ? baseEntity : this.creatorEntity);\r\n\t\t\tInterface.CallHook(\"OnFireBallSpread\", this, baseEntity);\r\n\t\t\tbaseEntity.SetVelocity(modifiedAimConeDirection * UnityEngine.Random.Range(5f, 8f));\r\n\t\t\tbaseEntity.SendMessage(\"SetGeneration\", this.generation + 1f);\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerMetabolize",
      "HookName": "OnPlayerMetabolize",
      "HookParameters": {
        "instance": "PlayerMetabolism",
        "ownerEntity": "BaseCombatEntity",
        "delta": "float"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerMetabolism",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ServerUpdate",
        "ReturnType": "void",
        "Arguments": {
          "ownerEntity": "BaseCombatEntity",
          "delta": "float"
        }
      },
      "CodeAfterInjection": "public override void ServerUpdate(global::BaseCombatEntity ownerEntity, float delta)\r\n{\r\n\tbase.ServerUpdate(ownerEntity, delta);\r\n\tInterface.CallHook(\"OnPlayerMetabolize\", this, ownerEntity, delta);\r\n\tif (this.owner.IsConnected)\r\n\t{\r\n\t\tthis.SendChangesToClient();\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMarkHostile",
      "HookName": "OnEntityMarkHostile",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "duration": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "MarkHostileFor",
        "ReturnType": "void",
        "Arguments": {
          "duration": "float"
        }
      },
      "CodeAfterInjection": "public virtual void MarkHostileFor(float duration = 60f)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityMarkHostile\", this, duration) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat b = Time.realtimeSinceStartup + duration;\r\n\tthis.unHostileTime = Mathf.Max(this.unHostileTime, b);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnArcadeScoreAdded",
      "HookName": "OnArcadeScoreAdded",
      "HookDescription": "",
      "HookParameters": {
        "instance": "BaseArcadeMachine",
        "player": "BasePlayer",
        "score": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseArcadeMachine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "AddScore",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "score": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\targ_5B_1 = (global::BaseArcadeMachine.<>c.<>9__16_0 = new Comparison<global::BaseArcadeMachine.ScoreEntry>(global::BaseArcadeMachine.<>c.<>9.<AddScore>b__16_0));\r\n\t}\r\n\targ_5B_0.Sort(arg_5B_1);\r\n\tthis.scores.TrimExcess();\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnArcadeScoreAdded\", this, player, score);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEntityBeHostile",
      "HookName": "CanEntityBeHostile",
      "HookParameters": {
        "instance": "BaseCombatEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "IsHostile",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual bool IsHostile()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEntityBeHostile\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.unHostileTime > Time.realtimeSinceStartup;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanEntityBeHostile [BasePlayer]",
      "HookName": "CanEntityBeHostile",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "IsHostile",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public override bool IsHostile()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanEntityBeHostile\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.State.unHostileTimestamp > TimeEx.currentTimestamp;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRemove",
      "HookName": "OnItemRemove",
      "HookParameters": {
        "instance": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Remove",
        "ReturnType": "void",
        "Arguments": {
          "fTime": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.removeTime > 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemRemove\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.isServer)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "ICanPickupEntity [DoorCloser]",
      "HookName": "ICanPickupEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "DoorCloser"
      },
      "ReturnBehavior": 1,
      "TargetType": "DoorCloser",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Take",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_Take(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (Interface.CallHook(\"ICanPickupEntity\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!rpc.player.CanInteract())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamCreate",
      "HookName": "OnTeamCreate",
      "HookParameters": {
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "trycreateteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer basePlayer = arg.Player();\r\n\tif (basePlayer.currentTeam != 0uL)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamCreate\", basePlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.CreateTeam();\r\n\tplayerTeam.teamLeader = basePlayer.userID;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamInvite",
      "HookName": "OnTeamInvite",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "basePlayer2": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "sendinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tif (Vector3.Distance(basePlayer2.transform.position, basePlayer.transform.position) > num)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tDateTime hookExpireDate = new DateTime(2025, 12, 31);\r\n\t\tif (Interface.CallDeprecatedHook(\"OnTeamInvite\", \"OnTeamMemberInvite( PlayerTeam playerTeam, BasePlayer basePlayer, ulong PlayerID )\", hookExpireDate, basePlayer, basePlayer2) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayerTeam.SendInvite(basePlayer2);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamRejectInvite",
      "HookName": "OnTeamRejectInvite",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "playerTeam": "PlayerTeam"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "rejectinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (playerTeam == null)\r\n\t{\r\n\t\tbasePlayer.ClearPendingInvite();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamRejectInvite\", basePlayer, playerTeam) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.RejectInvite(basePlayer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamLeave",
      "HookName": "OnTeamLeave",
      "HookParameters": {
        "playerTeam": "PlayerTeam",
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "leaveteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.FindTeam(basePlayer.currentTeam);\r\n\tif (playerTeam != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTeamLeave\", playerTeam, basePlayer) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayerTeam.RemovePlayer(basePlayer.userID);\r\n\t\tbasePlayer.ClearTeam();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamKick",
      "HookName": "OnTeamKick",
      "HookParameters": {
        "playerTeam": "PlayerTeam",
        "basePlayer": "BasePlayer",
        "uLong": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "kickmember",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\tulong uLong = arg.GetULong(0, 0uL);\r\n\tif (basePlayer.userID == uLong)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamKick\", playerTeam, basePlayer, uLong) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.RemovePlayer(uLong);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamAcceptInvite",
      "HookName": "OnTeamAcceptInvite",
      "HookParameters": {
        "playerTeam": "PlayerTeam",
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "acceptinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (playerTeam == null)\r\n\t{\r\n\t\tbasePlayer.ClearPendingInvite();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTeamAcceptInvite\", playerTeam, basePlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayerTeam.AcceptInvite(basePlayer);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamDisband",
      "HookName": "OnTeamDisband",
      "HookParameters": {
        "teamToDisband": "PlayerTeam"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "DisbandTeam",
        "ReturnType": "void",
        "Arguments": {
          "teamToDisband": "RelationshipManager/PlayerTeam"
        }
      },
      "CodeAfterInjection": "public void DisbandTeam(global::RelationshipManager.PlayerTeam teamToDisband)\r\n{\r\n\tif (Interface.CallHook(\"OnTeamDisband\", teamToDisband) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.teams.Remove(teamToDisband.teamID);\r\n\tPool.Free<global::RelationshipManager.PlayerTeam>(ref teamToDisband);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamCreated",
      "HookName": "OnTeamCreated",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "relationshipManager": "RelationshipManager"
      },
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "trycreateteam",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::RelationshipManager.PlayerTeam OxideGen_2 = global::RelationshipManager.ServerInstance.CreateTeam();\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = OxideGen_2;\r\n\tplayerTeam.teamLeader = basePlayer.userID;\r\n\tplayerTeam.AddPlayer(basePlayer, false);\r\n\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\"created\", playerTeam.teamID, basePlayer.userID, basePlayer.userID, playerTeam.members);\r\n\tInterface.CallHook(\"OnTeamCreated\", basePlayer, OxideGen_2);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamDisbanded",
      "HookName": "OnTeamDisbanded",
      "HookParameters": {
        "teamToDisband": "PlayerTeam"
      },
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "DisbandTeam",
        "ReturnType": "void",
        "Arguments": {
          "teamToDisband": "RelationshipManager/PlayerTeam"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (Interface.CallHook(\"OnTeamDisband\", teamToDisband) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.teams.Remove(teamToDisband.teamID);\r\n\tInterface.CallHook(\"OnTeamDisbanded\", teamToDisband);\r\n\tPool.Free<global::RelationshipManager.PlayerTeam>(ref teamToDisband);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLand",
      "HookName": "OnPlayerLand",
      "HookParameters": {
        "instance": "BasePlayer",
        "num": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ApplyFallDamageFromVelocity",
        "ReturnType": "void",
        "Arguments": {
          "velocity": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\tfloat num = Mathf.InverseLerp(-15f, -100f, velocity);\r\n\tif (num == 0f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerLand\", this, num) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num2 = (this.modifiers != null) ? Mathf.Clamp01(1f - this.modifiers.GetValue(global::Modifier.ModifierType.Clotting, 0f)) : 1f;\r\n\tthis.metabolism.bleeding.Add(num * 0.5f * num2);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerLanded",
      "HookName": "OnPlayerLanded",
      "HookParameters": {
        "instance": "BasePlayer",
        "num": "float"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ApplyFallDamageFromVelocity",
        "ReturnType": "void",
        "Arguments": {
          "velocity": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbase.Hurt(num3, Rust.DamageType.Fall, null, true);\r\n\tif (num3 > 20f && this.fallDamageEffect.isValid)\r\n\t{\r\n\t\tglobal::Effect.server.Run(this.fallDamageEffect.resourcePath, base.transform.position, Vector3.zero, null, false, null);\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerLanded\", this, num);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDeployItem",
      "HookName": "CanDeployItem",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "Deployer",
        "networkableId": "NetworkableId"
      },
      "ReturnBehavior": 1,
      "TargetType": "Deployer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DoDeploy",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tRay ray = msg.read.Ray();\r\n\tNetworkableId networkableId = msg.read.EntityID();\r\n\tif (Interface.CallHook(\"CanDeployItem\", msg.player, this, networkableId) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (deployable.toSlot)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSamSiteShoot",
      "HookName": "CanSamSiteShoot",
      "HookParameters": {
        "instance": "SamSite"
      },
      "ReturnBehavior": 1,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WeaponTick",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tthis.nextBurstTime = Time.time + timeBetweenBursts;\r\n\t\tthis.firedCount = 0;\r\n\t\treturn;\r\n\t}\r\n\tthis.EnsureReloaded();\r\n\tif (Interface.CallHook(\"CanSamSiteShoot\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasAmmo())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWorldPrefabSpawned",
      "HookName": "OnWorldPrefabSpawned",
      "HookParameters": {
        "gameObject": "GameObject",
        "category": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "World",
      "Category": "World",
      "MethodData": {
        "MethodName": "SpawnPrefab",
        "ReturnType": "void",
        "Arguments": {
          "category": "string",
          "prefab": "Prefab",
          "position": "UnityEngine.Vector3",
          "rotation": "UnityEngine.Quaternion",
          "scale": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tprefab.ApplyTerrainModifiers(position, rotation, scale);\r\n\t}\r\n\tGameObject gameObject = prefab.Spawn(position, rotation, scale, true);\r\n\tif (gameObject)\r\n\t{\r\n\t\tInterface.CallHook(\"OnWorldPrefabSpawned\", gameObject, category);\r\n\t\tgameObject.SetHierarchyGroup(category, true, false);\r\n\t}\r\n\tglobal::World.spawnTimer.Stop();\r\n\tglobal::World.spawnTimings.Add(new global::World.SpawnTiming\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBoatPathGenerate",
      "HookName": "OnBoatPathGenerate",
      "HookParameters": {
        "instance": "BaseBoat"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseBoat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "GenerateOceanPatrolPath",
        "ReturnType": "System.Collections.Generic.List`1<UnityEngine.Vector3>",
        "Arguments": {
          "minDistanceFromShore": "float",
          "minWaterDepth": "float"
        }
      },
      "CodeAfterInjection": "public static List<Vector3> GenerateOceanPatrolPath(float minDistanceFromShore = 50f, float minWaterDepth = 8f)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnBoatPathGenerate\");\r\n\tif (returnvar is List<Vector3>)\r\n\t{\r\n\t\treturn (List<Vector3>)returnvar;\r\n\t}\r\n\tfloat expr_28 = global::TerrainMeta.Size.x;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCollectiblePickup",
      "HookName": "OnCollectiblePickup",
      "HookParameters": {
        "instance": "CollectibleEntity",
        "reciever": "BasePlayer",
        "eat": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "CollectibleEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "DoPickup",
        "ReturnType": "void",
        "Arguments": {
          "reciever": "BasePlayer",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.itemList == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCollectiblePickup\", this, reciever, eat) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = (reciever.modifiers != null) ? reciever.modifiers.GetValue(global::Modifier.ModifierType.Collectible_DoubleYield, 0f) : 0f;\r\n\tbool flag = num != 0f && UnityEngine.Random.value < num;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnProjectileRicochet",
      "HookName": "OnProjectileRicochet",
      "HookParameters": {
        "instance": "BasePlayer",
        "playerProjectileRicochet": "PlayerProjectileRicochet"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "OnProjectileRicochet",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t{\r\n\t\t\t\tglobal::AntiHack.Log(this, global::AntiHackType.ProjectileHack, \"Lifetime is zero (\" + playerProjectileRicochet.projectileID.ToString() + \")\", true);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnProjectileRicochet\", this, playerProjectileRicochet) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfiredProjectile.ricochets++;\r\n\t\t\t\tthis.firedProjectiles[playerProjectileRicochet.projectileID] = firedProjectile;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAffordToPlace",
      "HookName": "CanAffordToPlace",
      "HookParameters": {
        "ownerPlayer": "BasePlayer",
        "instance": "Planner",
        "component": "Construction"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CanAffordToPlace",
        "ReturnType": "bool",
        "Arguments": {
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAffordToPlace\", ownerPlayer, this, component);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (ownerPlayer.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSpectateTarget",
      "HookName": "CanSpectateTarget",
      "HookParameters": {
        "instance": "BasePlayer",
        "strName": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UpdateSpectateTarget",
        "ReturnType": "void",
        "Arguments": {
          "strName": "string"
        }
      },
      "CodeAfterInjection": "public void UpdateSpectateTarget(string strName)\r\n{\r\n\tif (Interface.CallHook(\"CanSpectateTarget\", this, strName) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.spectateFilter = strName;\r\n\tIEnumerable<global::BaseEntity> source;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [ElectricSwitch]",
      "HookName": "OnSwitchToggle",
      "HookParameters": {
        "instance": "ElectricSwitch",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElectricSwitch",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_Switch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Switch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool @switch = msg.read.Bool();\r\n\tthis.SetSwitch(@switch);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopAcceptClick",
      "HookName": "OnShopAcceptClick",
      "HookParameters": {
        "instance": "ShopFront",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "AcceptClicked",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.vendorPlayer == null || this.customerPlayer == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnShopAcceptClick\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsPlayerVendor(msg.player))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnShopCancelClick",
      "HookName": "OnShopCancelClick",
      "HookParameters": {
        "instance": "ShopFront",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ShopFront",
      "Category": "Shop",
      "MethodData": {
        "MethodName": "CancelClicked",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!this.IsTradingPlayer(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnShopCancelClick\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.vendorPlayer;\r\n\tthis.customerPlayer;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAdministerVending [NPC]",
      "HookName": "CanAdministerVending",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "NPCVendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "CanPlayerAdmin",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool CanPlayerAdmin(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAdministerVending\", player, this);\r\n\treturn returnvar is bool && (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGiveSoldItem",
      "HookName": "OnGiveSoldItem",
      "HookParameters": {
        "instance": "VendingMachine",
        "soldItem": "Item",
        "buyer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "GiveSoldItem",
        "ReturnType": "void",
        "Arguments": {
          "soldItem": "Item",
          "buyer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void GiveSoldItem(global::Item soldItem, global::BasePlayer buyer)\r\n{\r\n\tif (Interface.CallHook(\"OnGiveSoldItem\", this, soldItem, buyer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\twhile (soldItem.amount > soldItem.MaxStackable())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanTakeCutting",
      "HookName": "CanTakeCutting",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "GrowableEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TakeClones",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanClone())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanTakeCutting\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = this.Properties.BaseCloneCount + this.Genes.GetGeneTypeCount(global::GrowableGenetics.GeneType.Yield) / 2;\r\n\tif (num <= 0)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSendCommand",
      "HookName": "OnSendCommand",
      "HookParameters": {
        "cn": "Connection",
        "strCommand": "string",
        "args": "Object[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "SendClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "cn": "Network.Connection",
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSendCommand\", cn, strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_28 = Net.sv.StartWrite();\r\n\texpr_28.PacketID(Message.Type.ConsoleCommand);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSendCommand [list]",
      "HookName": "OnSendCommand",
      "HookParameters": {
        "cn": "List`1",
        "strCommand": "string",
        "args": "Object[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "SendClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "cn": "System.Collections.Generic.List`1<Network.Connection>",
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSendCommand\", cn, strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_28 = Net.sv.StartWrite();\r\n\texpr_28.PacketID(Message.Type.ConsoleCommand);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBroadcastCommand",
      "HookName": "OnBroadcastCommand",
      "HookParameters": {
        "strCommand": "string",
        "args": "Object[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Server",
      "MethodData": {
        "MethodName": "BroadcastToAllClients",
        "ReturnType": "void",
        "Arguments": {
          "strCommand": "string",
          "args": "System.Object[]"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!Net.sv.IsConnected())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBroadcastCommand\", strCommand, args) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_27 = Net.sv.StartWrite();\r\n\texpr_27.PacketID(Message.Type.ConsoleCommand);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopRename",
      "HookName": "OnVendingShopRename",
      "HookParameters": {
        "instance": "VendingMachine",
        "obj": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_UpdateShopName",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tglobal::BasePlayer player = msg.player;\r\n\tstring obj = msg.read.String(32, false);\r\n\tif (this.CanPlayerAdmin(player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVendingShopRename\", this, obj, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.shopName = obj;\r\n\t\tthis.nameLastEditedBy = player.userID.Get();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcGiveSoldItem",
      "HookName": "OnNpcGiveSoldItem",
      "HookParameters": {
        "instance": "NPCVendingMachine",
        "soldItem": "Item",
        "buyer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GiveSoldItem",
        "ReturnType": "void",
        "Arguments": {
          "soldItem": "Item",
          "buyer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override void GiveSoldItem(global::Item soldItem, global::BasePlayer buyer)\r\n{\r\n\tif (Interface.CallHook(\"OnNpcGiveSoldItem\", this, soldItem, buyer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tsoldItem.SetItemOwnership(buyer, global::ItemOwnershipPhrases.VendorSale);\r\n\tbase.GiveSoldItem(soldItem, buyer);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorGather",
      "HookName": "OnExcavatorGather",
      "HookParameters": {
        "instance": "ExcavatorArm",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "ProduceResources",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\tint num3 = Mathf.FloorToInt(itemAmount.amount / (float)this.outputPiles.Count);\r\n\t\t\titemAmount.amount -= (float)(num3 * 2);\r\n\t\t\tforeach (global::ExcavatorOutputPile current in this.outputPiles)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(this.resourcesToMine[this.resourceMiningIndex].itemDef, num3, 0uL, true);\r\n\t\t\t\tif (Interface.CallHook(\"OnExcavatorGather\", this, item) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnExcavatorProduceItem(item, this);\r\n\t\t\t\tif (!item.MoveToContainer(current.inventory, -1, true, false, null, true))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityTakeDamage [ResourceEntity]",
      "HookName": "OnEntityTakeDamage",
      "HookParameters": {
        "instance": "ResourceEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResourceEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void OnAttacked(global::HitInfo info)\r\n{\r\n\tif (base.isServer && !this.isKilled)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnEntityTakeDamage\", this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.resourceDispenser != null)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSupplyDropLanded",
      "HookName": "OnSupplyDropLanded",
      "HookParameters": {
        "instance": "SupplyDrop"
      },
      "ReturnBehavior": 0,
      "TargetType": "SupplyDrop",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnCollisionEnter",
        "ReturnType": "void",
        "Arguments": {
          "collision": "UnityEngine.Collision"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (flag)\r\n\t{\r\n\t\tthis.RemoveParachute();\r\n\t\tthis.MakeLootable();\r\n\t}\r\n\tInterface.CallHook(\"OnSupplyDropLanded\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityEnter [TriggerComfort]",
      "HookName": "OnEntityEnter",
      "HookParameters": {
        "instance": "TriggerComfort",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggerComfort",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnEntityEnter",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!(ent is global::BasePlayer) && !(ent is global::RidableHorse) && !(ent is global::RidableHorse))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityEnter\", this, ent) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis._entities.Add(ent);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityLeave [TriggerComfort]",
      "HookName": "OnEntityLeave",
      "HookParameters": {
        "instance": "TriggerComfort",
        "ent": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggerComfort",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnEntityLeave",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!(ent is global::BasePlayer) && !(ent is global::RidableHorse) && !(ent is global::RidableHorse))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityLeave\", this, ent) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis._entities.Remove(ent);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSetInfo [server]",
      "HookName": "OnPlayerSetInfo",
      "HookParameters": {
        "connection": "Connection",
        "name": "string",
        "value": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ClientReady",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tusing (ClientReady clientReady = packet.read.Proto<ClientReady>(null))\r\n\t{\r\n\t\tforeach (ClientReady.ClientInfo current in clientReady.clientInfo)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnPlayerSetInfo\", packet.connection, current.name, current.value);\r\n\t\t\tpacket.connection.info.Set(current.name, current.value);\r\n\t\t}\r\n\t\tpacket.connection.globalNetworking = clientReady.globalNetworking;\r\n\t\tthis.connectionQueue.JoinedGame(packet.connection);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnPlayerConnected(packet.connection);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSetInfo",
      "HookName": "OnPlayerSetInfo",
      "HookParameters": {
        "connection": "Connection",
        "key": "string",
        "val": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SetInfo",
        "ReturnType": "void",
        "Arguments": {
          "key": "string",
          "val": "string"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!this.IsConnected)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerSetInfo\", this.net.connection, key, val);\r\n\tthis.net.connection.info.Set(key, val);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTakeCurrencyItem",
      "HookName": "OnTakeCurrencyItem",
      "HookParameters": {
        "instance": "VendingMachine",
        "takenCurrencyItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "TakeCurrencyItem",
        "ReturnType": "void",
        "Arguments": {
          "takenCurrencyItem": "Item"
        }
      },
      "CodeAfterInjection": "public virtual void TakeCurrencyItem(global::Item takenCurrencyItem)\r\n{\r\n\tif (Interface.CallHook(\"OnTakeCurrencyItem\", this, takenCurrencyItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!takenCurrencyItem.MoveToContainer(base.inventory, -1, true, false, null, true))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTakeCurrencyItem [NPC]",
      "HookName": "OnTakeCurrencyItem",
      "HookParameters": {
        "instance": "NPCVendingMachine",
        "takenCurrencyItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCVendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "TakeCurrencyItem",
        "ReturnType": "void",
        "Arguments": {
          "takenCurrencyItem": "Item"
        }
      },
      "CodeAfterInjection": "public override void TakeCurrencyItem(global::Item takenCurrencyItem)\r\n{\r\n\tif (Interface.CallHook(\"OnTakeCurrencyItem\", this, takenCurrencyItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttakenCurrencyItem.MoveToContainer(base.inventory, -1, true, false, null, true);\r\n\ttakenCurrencyItem.RemoveFromContainer();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityStabilityCheck",
      "HookName": "OnEntityStabilityCheck",
      "HookParameters": {
        "instance": "StabilityEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "StabilityEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StabilityCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (base.IsDestroyed)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityStabilityCheck\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.supports == null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPayForUpgrade",
      "HookName": "OnPayForUpgrade",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BuildingBlock",
        "g": "ConstructionGrade"
      },
      "ReturnBehavior": 1,
      "TargetType": "BuildingBlock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PayForUpgrade",
        "ReturnType": "void",
        "Arguments": {
          "g": "ConstructionGrade",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private void PayForUpgrade(global::ConstructionGrade g, global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnPayForUpgrade\", player, this, g) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPayForPlacement [Planner]",
      "HookName": "OnPayForPlacement",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "Planner",
        "component": "Construction"
      },
      "ReturnBehavior": 1,
      "TargetType": "Planner",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PayForPlacement",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "public virtual void PayForPlacement(global::BasePlayer player, global::Construction component)\r\n{\r\n\tif (Interface.CallHook(\"OnPayForPlacement\", player, this, component) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPayForPlacement [WallpaperPlanner]",
      "HookName": "OnPayForPlacement",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "WallpaperPlanner",
        "component": "Construction"
      },
      "ReturnBehavior": 1,
      "TargetType": "WallpaperPlanner",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PayForPlacement",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "public override void PayForPlacement(global::BasePlayer player, global::Construction component)\r\n{\r\n\tif (Interface.CallHook(\"OnPayForPlacement\", player, this, component) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.IsInCreativeMode && ConVar.Creative.freeBuild)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDeath [ResourceEntity]",
      "HookName": "OnEntityDeath",
      "HookParameters": {
        "instance": "ResourceEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResourceEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnDied",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public virtual void OnDied(global::HitInfo info)\r\n{\r\n\tthis.isKilled = true;\r\n\tInterface.CallHook(\"OnEntityDeath\", this, info);\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamUpdate",
      "HookName": "OnTeamUpdate",
      "HookParameters": {
        "currentTeam": "ulong",
        "newTeam": "ulong",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Team",
      "MethodData": {
        "MethodName": "UpdateTeam",
        "ReturnType": "void",
        "Arguments": {
          "newTeam": "ulong"
        }
      },
      "CodeAfterInjection": "public void UpdateTeam(ulong newTeam)\r\n{\r\n\tif (Interface.CallHook(\"OnTeamUpdate\", this.currentTeam, newTeam, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.currentTeam = newTeam;\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamUpdated",
      "HookName": "OnTeamUpdated",
      "HookParameters": {
        "currentTeam": "ulong",
        "playerTeam2": "PlayerTeam",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Team",
      "MethodData": {
        "MethodName": "TeamUpdate",
        "ReturnType": "void",
        "Arguments": {
          "fullTeamUpdate": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tforeach (MapNote current2 in playerState.pointsOfInterest)\r\n\t\t\t\t{\r\n\t\t\t\t\tplayerTeam2.leaderMapNotes.Add(current2);\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tif (Interface.CallHook(\"OnTeamUpdated\", this.currentTeam, playerTeam2, this) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbase.ClientRPC(global::RpcTarget.PlayerAndSpectators(\"CLIENT_ReceiveTeamInfo\", this), playerTeam2);\r\n\t\t\tif (playerTeam2.leaderMapNotes != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExplosiveFuseSet",
      "HookName": "OnExplosiveFuseSet",
      "HookParameters": {
        "instance": "TimedExplosive",
        "fuseLength": "float"
      },
      "ReturnBehavior": 3,
      "TargetType": "TimedExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "SetFuse",
        "ReturnType": "void",
        "Arguments": {
          "fuseLength": "float"
        }
      },
      "CodeAfterInjection": "public virtual void SetFuse(float fuseLength)\r\n{\r\n\tif (base.isServer)\r\n\t{\r\n\t\tobject returnvar = Interface.CallHook(\"OnExplosiveFuseSet\", this, fuseLength);\r\n\t\tif (returnvar is float)\r\n\t\t{\r\n\t\t\tfuseLength = (float)returnvar;\r\n\t\t}\r\n\t\tbase.Invoke(new Action(this.Explode), fuseLength);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnExplosiveDud",
      "HookName": "OnExplosiveDud",
      "ReturnBehavior": 0,
      "TargetType": "DudTimedExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (this.creatorEntity != null && this.creatorEntity.IsNpc)\r\n\t{\r\n\t\tbase.Explode();\r\n\t\treturn;\r\n\t}\r\n\tif (UnityEngine.Random.Range(0f, 1f) < this.dudChance && Interface.CallHook(\"OnExplosiveDud\", this) == null)\r\n\t{\r\n\t\tthis.BecomeDud();\r\n\t\treturn;\r\n\t}\r\n\tbase.Explode();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerAssist",
      "HookName": "OnPlayerAssist",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_Assist",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.IsWounded())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerAssist\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.StopWounded(msg.player);\r\n\tmsg.player.stats.Add(\"wounded_assisted\", 1, (global::Stats)5);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerKeepAlive",
      "HookName": "OnPlayerKeepAlive",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_KeepAlive",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.IsWounded())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerKeepAlive\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ProlongWounding(10f);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorMiningToggled [start]",
      "HookName": "OnExcavatorMiningToggled",
      "HookParameters": {
        "instance": "ExcavatorArm"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "BeginMining",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tthis.nextNotificationTime = Time.time + 60f;\r\n\t}\r\n\tglobal::ExcavatorServerEffects.SetMining(true, false);\r\n\tthis.excavatorStartTime = this.GetNetworkTime();\r\n\tInterface.CallHook(\"OnExcavatorMiningToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorMiningToggled [stop]",
      "HookName": "OnExcavatorMiningToggled",
      "HookParameters": {
        "instance": "ExcavatorArm"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StopMining",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void StopMining()\r\n{\r\n\tglobal::ExcavatorServerEffects.SetMining(false, false);\r\n\tbase.CancelInvoke(new Action(this.ProduceResources));\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tInterface.CallHook(\"OnExcavatorMiningToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorResourceSet",
      "HookName": "OnExcavatorResourceSet",
      "HookParameters": {
        "instance": "ExcavatorArm",
        "text": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorArm",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "RPC_SetResourceTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\npublic void RPC_SetResourceTarget(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tstring text = msg.read.String(256, false);\r\n\tif (Interface.CallHook(\"OnExcavatorResourceSet\", this, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (text == \"HQM\")\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggled [off]",
      "HookName": "OnDieselEngineToggled",
      "HookParameters": {
        "instance": "DieselEngine"
      },
      "ReturnBehavior": 0,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineOff",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void EngineOff()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tbase.BroadcastEntityMessage(\"DieselEngineOff\", 20f, 1218652417);\r\n\tInterface.CallHook(\"OnDieselEngineToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggled [on]",
      "HookName": "OnDieselEngineToggled",
      "HookParameters": {
        "instance": "DieselEngine"
      },
      "ReturnBehavior": 0,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineOn",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void EngineOn()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.BroadcastEntityMessage(\"DieselEngineOn\", 20f, 1218652417);\r\n\tInterface.CallHook(\"OnDieselEngineToggled\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDieselEngineToggle",
      "HookName": "OnDieselEngineToggle",
      "HookParameters": {
        "instance": "DieselEngine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "DieselEngine",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(6f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnDieselEngineToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (msg.read.Bit())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnActiveItemChanged",
      "HookName": "OnActiveItemChanged",
      "HookParameters": {
        "instance": "BasePlayer",
        "activeItem": "Item",
        "heldEntity": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UpdateActiveItem",
        "ReturnType": "void",
        "Arguments": {
          "itemID": "ItemId"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\theldEntity2.SetHeld(true);\r\n\t\t}\r\n\t\tthis.NotifyGesturesNewItemEquipped();\r\n\t}\r\n\tthis.inventory.UpdatedVisibleHolsteredItems();\r\n\tInterface.CallHook(\"OnActiveItemChanged\", this, activeItem, activeItem2);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAmmoUnload",
      "HookName": "OnAmmoUnload",
      "HookParameters": {
        "component": "BaseProjectile",
        "item": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "UnloadAmmo",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BaseProjectile component = item.GetHeldEntity().GetComponent<global::BaseProjectile>();\r\n\tif (!component.canUnloadAmmo)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnAmmoUnload\", component, item, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (component)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOutputUpdate",
      "HookName": "OnOutputUpdate",
      "HookParameters": {
        "instance": "IOEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "IOEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdateOutputs",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void UpdateOutputs()\r\n{\r\n\tif (Interface.CallHook(\"OnOutputUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.ShouldUpdateOutputs())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInputUpdate",
      "HookName": "OnInputUpdate",
      "HookParameters": {
        "instance": "IOEntity",
        "inputAmount": "int",
        "inputSlot": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "IOEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdateFromInput",
        "ReturnType": "void",
        "Arguments": {
          "inputAmount": "int",
          "inputSlot": "int"
        }
      },
      "CodeAfterInjection": "public virtual void UpdateFromInput(int inputAmount, int inputSlot)\r\n{\r\n\tif (Interface.CallHook(\"OnInputUpdate\", this, inputAmount, inputSlot) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.inputs[inputSlot].type != this.ioType || this.inputs[inputSlot].type == global::IOEntity.IOType.Industrial)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCardSwipe",
      "HookName": "OnCardSwipe",
      "HookParameters": {
        "instance": "CardReader",
        "keycard": "Keycard",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "CardReader",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ServerCardSwiped",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::Effect.server.Run(this.swipeEffect.resourcePath, this.audioPosition.position, Vector3.up, msg.player.net.connection, false, null);\r\n\tif (keycard == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCardSwipe\", this, keycard, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item item = keycard.GetItem();\r\n\tif (item == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDigitalClockRing",
      "HookName": "OnDigitalClockRing",
      "HookDescription": "",
      "HookParameters": {
        "instance": "DigitalClock"
      },
      "ReturnBehavior": 1,
      "TargetType": "DigitalClock",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Ring",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void Ring()\r\n{\r\n\tif (Interface.CallHook(\"OnDigitalClockRing\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.isRinging = true;\r\n\tbase.ClientRPC(global::RpcTarget.NetworkGroup(\"RPC_StartRinging\"));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDigitalClockRingStop",
      "HookName": "OnDigitalClockRingStop",
      "HookDescription": "",
      "HookParameters": {
        "instance": "DigitalClock"
      },
      "ReturnBehavior": 1,
      "TargetType": "DigitalClock",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "StopRinging",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void StopRinging()\r\n{\r\n\tif (Interface.CallHook(\"OnDigitalClockRingStop\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.isRinging = false;\r\n\tbase.ClientRPC(global::RpcTarget.NetworkGroup(\"RPC_StopRinging\"));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDigitalClockAlarmsSet",
      "HookName": "OnDigitalClockAlarmsSet",
      "HookDescription": "",
      "HookParameters": {
        "instance": "DigitalClock",
        "digitalClockMessage": "DigitalClockMessage"
      },
      "ReturnBehavior": 1,
      "TargetType": "DigitalClock",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "RPC_SetAlarms",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.CanPlayerAdmin(msg.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDigitalClockMessage digitalClockMessage = msg.read.Proto<DigitalClockMessage>(null);\r\n\tif (Interface.CallHook(\"OnDigitalClockAlarmsSet\", this, digitalClockMessage) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\ttry\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnButtonPress",
      "HookName": "OnButtonPress",
      "HookParameters": {
        "instance": "PressButton",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PressButton",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "RPC_Press",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_Press(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnButtonPress\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Press();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkersClear",
      "HookName": "OnMapMarkersClear",
      "HookParameters": {
        "instance": "BasePlayer",
        "pointsOfInterest": "List`1"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_ClearMapMarkers",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(1uL), global::BaseEntity.RPC_Server.FromOwner(false)]\r\npublic void Server_ClearMapMarkers(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMapMarkersClear\", this, this.State.pointsOfInterest) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tMapNote expr_20 = this.ServerCurrentDeathNote;\r\n\tif (expr_20 != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkersCleared",
      "HookName": "OnMapMarkersCleared",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_ClearMapMarkers",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tthis.State.pointsOfInterest.Clear();\r\n\t}\r\n\tthis.DirtyPlayerState();\r\n\tthis.TeamUpdate();\r\n\tInterface.CallHook(\"OnMapMarkersCleared\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanNetworkTo [BasePlayer]",
      "HookName": "CanNetworkTo",
      "HookParameters": {
        "instance": "BasePlayer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ShouldNetworkTo",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool ShouldNetworkTo(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanNetworkTo\", this, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (player == this)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWireConnect",
      "HookName": "OnWireConnect",
      "HookParameters": {
        "player": "BasePlayer",
        "iOEntity": "IOEntity",
        "inputIndex": "int",
        "iOEntity2": "IOEntity",
        "outputIndex": "int",
        "linePoints": "List`1",
        "slackLevels": "List`1"
      },
      "ReturnBehavior": 1,
      "TargetType": "WireTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_MakeConnection",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tarray[i].boneName = wireLineAnchorInfo.boneName;\r\n\t\tarray[i].index = (int)wireLineAnchorInfo.index;\r\n\t\tarray[i].position = wireLineAnchorInfo.position;\r\n\t}\r\n\tglobal::WireTool.WireColour wireColour = this.IntToColour(wireConnectionMessage.wireColor);\r\n\tif (Interface.CallHook(\"OnWireConnect\", player, iOEntity, inputIndex, iOEntity2, outputIndex, wireConnectionMessage.linePoints, slackLevels) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (wireColour == global::WireTool.WireColour.Invisible && !player.IsInCreativeMode)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWireClear",
      "HookName": "OnWireClear",
      "HookParameters": {
        "ply": "BasePlayer",
        "iOEntity": "IOEntity",
        "clearIndex": "int",
        "OxideGen_": "IOEntity",
        "isInput": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "WireTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AttemptClearSlot",
        "ReturnType": "bool",
        "Arguments": {
          "clearEnt": "BaseNetworkable",
          "ply": "BasePlayer",
          "clearIndex": "int",
          "isInput": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (OxideGen_.connectedTo.Get(true) == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tOxideGen_ = OxideGen_.connectedTo.Get(true);\r\n\tobject returnvar = Interface.CallHook(\"OnWireClear\", ply, iOEntity, clearIndex, OxideGen_, isInput);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !(iOEntity == null) && (!(ply != null) || global::WireTool.CanModifyEntity(ply, iOEntity)) && iOEntity.Disconnect(clearIndex, isInput);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnWireClear [patch]",
      "HookName": "OnWireClear [patch]",
      "HookDescription": "",
      "ReturnBehavior": 0,
      "TargetType": "WireTool",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "AttemptClearSlot",
        "ReturnType": "bool",
        "Arguments": {
          "clearEnt": "BaseNetworkable",
          "ply": "BasePlayer",
          "clearIndex": "int",
          "isInput": "bool"
        }
      }
    },
    {
      "Type": 0,
      "Name": "CanUseWires",
      "HookName": "CanUseWires",
      "HookParameters": {
        "player": "BasePlayer",
        "cached": "bool",
        "cacheDuration": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "WireTool",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanPlayerUseWires",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "cached": "bool",
          "cacheDuration": "float"
        }
      },
      "CodeAfterInjection": "public static bool CanPlayerUseWires(global::BasePlayer player, bool cached = false, float cacheDuration = 1f)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseWires\", player, cached, cacheDuration);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (player != null && player.IsInCreativeMode && ConVar.Creative.unlimitedIo)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseLead [RidableHorse]",
      "HookName": "OnHorseLead",
      "HookParameters": {
        "instance": "RidableHorse",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RidableHorse",
      "Category": "Animal",
      "MethodData": {
        "MethodName": "SERVER_Lead",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\telse if (!this.CanStopLead(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHorseLead\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetLeading(flag ? player : null);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRespawn [SleepingBag]",
      "HookName": "OnPlayerRespawn",
      "HookParameters": {
        "player": "BasePlayer",
        "sleepingBag2": "SleepingBag"
      },
      "ReturnBehavior": 3,
      "TargetType": "SleepingBag",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SpawnPlayer",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "sleepingBag": "NetworkableId"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::SleepingBag sleepingBag2 = array.FirstOrDefault((global::SleepingBag x) => x.ValidForPlayer(player.userID, false) && x.net.ID == sleepingBag && x.unlockTime < Time.realtimeSinceStartup);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnPlayerRespawn\", player2, sleepingBag2);\r\n\tif (returnvar is global::SleepingBag)\r\n\t{\r\n\t\tsleepingBag2 = (global::SleepingBag)returnvar;\r\n\t}\r\n\tglobal::StaticRespawnArea staticRespawnArea = sleepingBag2 as global::StaticRespawnArea;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneNameUpdate",
      "HookName": "OnPhoneNameUpdate",
      "HookParameters": {
        "instance": "PhoneController",
        "text": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdatePhoneName",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tstring text = msg.read.String(256, false);\r\n\tif (text.Length > 30)\r\n\t{\r\n\t\ttext = text.Substring(0, 30);\r\n\t}\r\n\tif (Interface.CallHook(\"OnPhoneNameUpdate\", this, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PhoneName = text;\r\n\tbase.baseEntity.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuildingPrivilege",
      "HookName": "OnBuildingPrivilege",
      "HookParameters": {
        "instance": "BaseEntity",
        "obb": "OBB",
        "cached": "bool",
        "cacheDuration": "float",
        "exclude": "BuildingPrivlidge"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "GetBuildingPrivilege",
        "ReturnType": "BuildingPrivlidge",
        "Arguments": {
          "obb": "OBB",
          "cached": "bool",
          "cacheDuration": "float",
          "exclude": "BuildingPrivlidge"
        }
      },
      "CodeAfterInjection": "public global::BuildingPrivlidge GetBuildingPrivilege(OBB obb, bool cached, float cacheDuration = 1f, global::BuildingPrivlidge exclude = null)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnBuildingPrivilege\", this, obb, cached, cacheDuration, exclude);\r\n\tif (returnvar is global::BuildingPrivlidge)\r\n\t{\r\n\t\treturn (global::BuildingPrivlidge)returnvar;\r\n\t}\r\n\tif (cached && this.cachedBuildingPrivilegeTime != 0f && Time.time - this.cachedBuildingPrivilegeTime < cacheDuration)\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSignalBroadcast",
      "HookName": "OnSignalBroadcast",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "Network",
      "MethodData": {
        "MethodName": "SignalBroadcast",
        "ReturnType": "void",
        "Arguments": {
          "signal": "BaseEntity/Signal",
          "sourceConnection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.net.group == null || base.limitNetworking)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSignalBroadcast\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ClientRPC(global::RpcTarget.NetworkGroup(\"SignalFromServer\", this, SendMethod.Unreliable, Priority.Immediate), (int)signal, (sourceConnection != null) ? sourceConnection.userid : 0uL);\r\n}\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSignalBroadcast",
      "HookName": "OnSignalBroadcast",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SignalBroadcast",
        "ReturnType": "void",
        "Arguments": {
          "signal": "BaseEntity/Signal",
          "arg": "string",
          "sourceConnection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.net.group == null || base.limitNetworking)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSignalBroadcast\", this, sourceConnection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ClientRPC(global::RpcTarget.NetworkGroup(\"SignalFromServerEx\", this, SendMethod.Unreliable, Priority.Immediate), (int)signal, arg, (sourceConnection != null) ? sourceConnection.userid : 0uL);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHelicopterRetire",
      "HookName": "OnHelicopterRetire",
      "HookParameters": {
        "instance": "PatrolHelicopterAI"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Retire",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.isRetiring)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnHelicopterRetire\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.Invoke(new Action(this.DestroyMe), 240f);\r\n\tfloat x = global::TerrainMeta.Size.x;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardProtectionCalculated",
      "HookName": "OnCupboardProtectionCalculated",
      "HookParameters": {
        "instance": "BuildingPrivlidge",
        "cachedProtectedMinutes": "float"
      },
      "ReturnBehavior": 0,
      "TargetType": "BuildingPrivlidge",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "GetProtectedMinutes",
        "ReturnType": "float",
        "Arguments": {
          "force": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tPool.FreeUnmanaged<global::ItemAmount>(ref list);\r\n\tthis.cachedProtectedMinutes = num2;\r\n\tInterface.CallHook(\"OnCupboardProtectionCalculated\", this, this.cachedProtectedMinutes);\r\n\treturn this.cachedProtectedMinutes;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipEgress",
      "HookName": "OnCargoShipEgress",
      "HookParameters": {
        "instance": "CargoShip"
      },
      "ReturnBehavior": 1,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartEgress",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (this.egressing)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.egressing = true;\r\n\tif (Interface.CallHook(\"OnCargoShipEgress\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.CancelInvoke(new Action(this.PlayHorn));\r\n\tthis.radiation.SetActive(true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipSpawnCrate",
      "HookName": "OnCargoShipSpawnCrate",
      "HookParameters": {
        "instance": "CargoShip"
      },
      "ReturnBehavior": 1,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RespawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void RespawnLoot()\r\n{\r\n\tif (Interface.CallHook(\"OnCargoShipSpawnCrate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.InvokeRepeating(new Action(this.PlayHorn), 0f, 8f);\r\n\tthis.SpawnCrate(this.lockedCratePrefab.resourcePath);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcRadioChatter [ScientistNPC]",
      "HookName": "OnNpcRadioChatter",
      "HookParameters": {
        "instance": "ScientistNPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "PlayRadioChatter",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (base.IsDestroyed || base.transform == null)\r\n\t{\r\n\t\tbase.CancelInvoke(new Action(this.PlayRadioChatter));\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnNpcRadioChatter\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Effect.server.Run(this.RadioChatterEffects[UnityEngine.Random.Range(0, this.RadioChatterEffects.Length)].resourcePath, this, global::StringPool.Get(\"head\"), Vector3.zero, Vector3.zero, null, false, null);\r\n\tthis.QueueRadioChatter();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcAlert [ScientistNPC]",
      "HookName": "OnNpcAlert",
      "HookParameters": {
        "instance": "ScientistNPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Alert",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Alert()\r\n{\r\n\tif (Interface.CallHook(\"OnNpcAlert\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.lastAlertedTime = Time.time;\r\n\tthis.SetChatterType(global::ScientistNPC.RadioChatterType.Alert);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDestroy [BradleyAPC]",
      "HookName": "OnEntityDestroy",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnDied",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEntityDestroy\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.CreateExplosionMarker(10f);\r\n\tglobal::Effect.server.Run(this.explosionEffect.resourcePath, this.mainTurretEyePos.transform.position, Vector3.up, null, true, null);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcEquipWeapon [NPCPlayer]",
      "HookName": "OnNpcEquipWeapon",
      "HookParameters": {
        "instance": "NPCPlayer",
        "slot": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCPlayer",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "EquipWeapon",
        "ReturnType": "void",
        "Arguments": {
          "skipDeployDelay": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (base.inventory == null || base.inventory.containerBelt == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item slot = base.inventory.containerBelt.GetSlot(0);\r\n\tif (Interface.CallHook(\"OnNpcEquipWeapon\", this, slot) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (slot != null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcEquipWeapon [ScientistNPC]",
      "HookName": "OnNpcEquipWeapon",
      "HookParameters": {
        "instance": "ScientistNPC",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ScientistNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "EquipWeapon",
        "ReturnType": "void",
        "Arguments": {
          "skipDeployDelay": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (heldEntity != null)\r\n\t{\r\n\t\tglobal::Item item = heldEntity.GetItem();\r\n\t\tif (item != null && item.contents != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnNpcEquipWeapon\", this, item) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (UnityEngine.Random.Range(0, 3) == 0)\r\n\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcDuck [HumanNPC]",
      "HookName": "OnNpcDuck",
      "HookParameters": {
        "instance": "HumanNPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "HumanNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "SetDucked",
        "ReturnType": "void",
        "Arguments": {
          "flag": "bool"
        }
      },
      "CodeAfterInjection": "public void SetDucked(bool flag)\r\n{\r\n\tif (Interface.CallHook(\"OnNpcDuck\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.modelState.ducked = flag;\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDeath [BaseCombatEntity]",
      "HookName": "OnEntityDeath",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Die",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tbase.LogEntry(global::RustLog.EntryType.Combat, 2, \"died\");\r\n\tthis.health = 0f;\r\n\tthis.lifestate = global::BaseCombatEntity.LifeState.Dead;\r\n\tInterface.CallHook(\"OnEntityDeath\", this, info);\r\n\tif (info != null && info.InitiatorPlayer)\r\n\t{\r\n\t\tglobal::BasePlayer initiatorPlayer = info.InitiatorPlayer;\r\n\t\tif (initiatorPlayer != null && initiatorPlayer.GetActiveMission() != -1 && !initiatorPlayer.IsNpc)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [FuelGenerator]",
      "HookName": "OnSwitchToggle",
      "HookParameters": {
        "instance": "FuelGenerator",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "FuelGenerator",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RPC_EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool generatorState = msg.read.Bit();\r\n\tthis.SetGeneratorState(generatorState);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWantsDismount",
      "HookName": "OnPlayerWantsDismount",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_WantsDismount",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!this.HasValidDismountPosition(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsDismount\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player != null && player.IsRestrained)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWantsMount",
      "HookName": "OnPlayerWantsMount",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "WantsMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!player.IsValid() || !player.CanInteract())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsMount\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.DirectlyMountable())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerStudyBlueprint",
      "HookName": "OnPlayerStudyBlueprint",
      "HookParameters": {
        "player": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModStudyBlueprint",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::ItemBlueprint itemBlueprint;\r\n\tif (global::ItemModStudyBlueprint.IsBlueprintUnlocked(item, player, out itemDefinition, out itemBlueprint))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerStudyBlueprint\", player, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item item2 = item;\r\n\tif (item.amount > 1)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerConnected",
      "HookName": "IOnPlayerConnected",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerInit",
        "ReturnType": "void",
        "Arguments": {
          "c": "Network.Connection"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tif (this.net != null)\r\n\t\t{\r\n\t\t\tglobal::EACServer.OnStartLoading(this.net.connection);\r\n\t\t}\r\n\t\tInterface.CallHook(\"IOnPlayerConnected\", this);\r\n\t\tif (this.IsAdmin)\r\n\t\t{\r\n\t\t\tif (ConVar.AntiHack.noclip_protection <= 0)\r\n\t\t\t{\r\n\t\t\t\tthis.ChatMessage(\"antihack.noclip_protection is disabled!\");\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityMarkHostile [BasePlayer]",
      "HookName": "OnEntityMarkHostile",
      "HookParameters": {
        "instance": "BasePlayer",
        "duration": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "MarkHostileFor",
        "ReturnType": "void",
        "Arguments": {
          "duration": "float"
        }
      },
      "CodeAfterInjection": "public override void MarkHostileFor(float duration = 60f)\r\n{\r\n\tif (Interface.CallHook(\"OnEntityMarkHostile\", this, duration) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tdouble currentTimestamp = TimeEx.currentTimestamp;\r\n\tdouble val = currentTimestamp + (double)duration;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuildingSplit",
      "HookName": "OnBuildingSplit",
      "HookParameters": {
        "oldBuilding": "Building",
        "newID": "uint"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerBuildingManager",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Split",
        "ReturnType": "void",
        "Arguments": {
          "oldBuilding": "BuildingManager/Building"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BuildingManager.Building largestSplit = null;\r\n\twhile (oldBuilding.HasBuildingBlocks())\r\n\t{\r\n\t\tglobal::BaseEntity arg_4F_0 = oldBuilding.buildingBlocks[0];\r\n\t\tuint newID = global::BuildingManager.server.NewBuildingID();\r\n\t\tInterface.CallHook(\"OnBuildingSplit\", oldBuilding, newID);\r\n\t\targ_4F_0.EntityLinkBroadcast<global::BuildingBlock>(delegate(global::BuildingBlock b)\r\n\t\t{\r\n\t\t\tb.AttachToBuilding(newID);\r\n\t\t});\r\n\t\tglobal::BuildingManager.Building building = global::BuildingManager.server.GetBuilding(newID);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMapMarkerRemove",
      "HookName": "OnMapMarkerRemove",
      "HookParameters": {
        "instance": "BasePlayer",
        "pointsOfInterest": "List`1",
        "num": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_RemovePointOfInterest",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\npublic void Server_RemovePointOfInterest(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tint num = msg.read.Int32();\r\n\tif (this.State.pointsOfInterest != null && this.State.pointsOfInterest.Count > num && num >= 0)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnMapMarkerRemove\", this, this.State.pointsOfInterest, num) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.State.pointsOfInterest[num].Dispose();\r\n\t\tthis.State.pointsOfInterest.RemoveAt(num);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGrowableGathered",
      "HookName": "OnGrowableGathered",
      "HookParameters": {
        "instance": "GrowableEntity",
        "item": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "GiveFruit",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "amount": "int",
          "applyCondition": "bool",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tif (player != null)\r\n\t{\r\n\t\tInterface.CallHook(\"OnGrowableGathered\", this, item, player);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, player, null);\r\n\t\tplayer.GiveItem(item, global::BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\treturn;\r\n\t}\r\n\titem.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up * 1f, default(Quaternion));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQuarryConsumeFuel",
      "HookName": "OnQuarryConsumeFuel",
      "HookParameters": {
        "instance": "MiningQuarry",
        "item": "Item"
      },
      "ReturnBehavior": 3,
      "TargetType": "MiningQuarry",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "FuelCheck",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (this.pendingWork > 0f)\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tglobal::Item item = this.fuelStoragePrefab.instance.GetComponent<global::StorageContainer>().inventory.FindItemByItemName(\"diesel_barrel\");\r\n\tobject returnvar = Interface.CallHook(\"OnQuarryConsumeFuel\", this, item);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\titem = (global::Item)returnvar;\r\n\t}\r\n\tif (item != null && item.amount >= 1)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityActiveCheck",
      "HookName": "OnEntityActiveCheck",
      "HookParameters": {
        "ent": "BaseEntity",
        "player": "BasePlayer",
        "id": "uint",
        "debugName": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/IsActiveItem",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (ent.net == null || player.net == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityActiveCheck\", ent, player, id, debugName);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (ent.net.ID == player.net.ID)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityFromOwnerCheck",
      "HookName": "OnEntityFromOwnerCheck",
      "HookParameters": {
        "ent": "BaseEntity",
        "player": "BasePlayer",
        "id": "uint",
        "debugName": "string",
        "includeMounted": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/FromOwner",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer",
          "includeMounted": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (ent.net == null || player.net == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityFromOwnerCheck\", ent, player, id, debugName, includeMounted);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (ent.net.ID == player.net.ID)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity [RidableHorse]",
      "HookName": "CanLootEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "RidableHorse"
      },
      "ReturnBehavior": 1,
      "TargetType": "RidableHorse",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SERVER_OpenLoot",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.needsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSamSiteTarget",
      "HookName": "OnSamSiteTarget",
      "ReturnBehavior": 0,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tthis.AddMLRSRockets(list, global::SamSite.targetTypeMissile.scanRadius);\r\n\tglobal::SamSite.ISamSiteTarget samSiteTarget = null;\r\n\tforeach (global::SamSite.ISamSiteTarget current in list)\r\n\t{\r\n\t\tif (!current.isClient && current.CenterPoint().y >= this.eyePoint.transform.position.y && current.IsVisible(this.eyePoint.transform.position, current.SAMTargetType.scanRadius * 2f) && current.IsValidSAMTarget(this.staticRespawn) && Interface.CallHook(\"OnSamSiteTarget\", this, current) == null)\r\n\t\t{\r\n\t\t\tsamSiteTarget = current;\r\n\t\t\tbreak;\r\n\t\t}\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [StorageContainer]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "StorageContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.IsLocked() || base.IsTransferring())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityVisibilityCheck",
      "HookName": "OnEntityVisibilityCheck",
      "HookParameters": {
        "ent": "BaseEntity",
        "player": "BasePlayer",
        "id": "uint",
        "debugName": "string",
        "maximumDistance": "float"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/IsVisible",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer",
          "maximumDistance": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (ent == null || player == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityVisibilityCheck\", ent, player, id, debugName, maximumDistance);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn global::GamePhysics.LineOfSight(player.eyes.center, player.eyes.position, 1218519041, null) && (ent.IsVisible(player.eyes.HeadRay(), 1218519041, maximumDistance) || ent.IsVisible(player.eyes.position, maximumDistance));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityDistanceCheck",
      "HookName": "OnEntityDistanceCheck",
      "HookParameters": {
        "ent": "BaseEntity",
        "player": "BasePlayer",
        "id": "uint",
        "debugName": "string",
        "maximumDistance": "float",
        "checkParent": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity/RPC_Server/MaxDistance",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Test",
        "ReturnType": "bool",
        "Arguments": {
          "id": "uint",
          "debugName": "string",
          "ent": "BaseEntity",
          "player": "BasePlayer",
          "maximumDistance": "float",
          "checkParent": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (ent == null || player == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnEntityDistanceCheck\", ent, player, id, debugName, maximumDistance, checkParent);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tbool flag = ent.Distance(player.eyes.position) <= maximumDistance;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGrowableGather",
      "HookName": "OnGrowableGather",
      "HookParameters": {
        "instance": "GrowableEntity",
        "player": "BasePlayer",
        "eat": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "PickFruit",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!this.CanPick())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnGrowableGather\", this, player, eat) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.harvests++;\r\n\tthis.GiveFruit(player, this.CurrentPickAmount, eat);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryGather",
      "HookName": "OnQuarryGather",
      "ReturnBehavior": 0,
      "TargetType": "MiningQuarry",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "ProcessResources",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\tif (num2 != num3)\r\n\t\t\t{\r\n\t\t\t\tint iAmount = num3 - num2;\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(current.type, iAmount, 0uL, true);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnQuarryItem(Facepunch.Rust.Analytics.Azure.ResourceMode.Produced, item.info.shortname, item.amount, this);\r\n\t\t\t\tif (Interface.CallHook(\"OnQuarryGather\", this, item) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\titem.Remove(0f);\r\n\t\t\t\t}\r\n\t\t\t\telse if (!item.MoveToContainer(this.hopperPrefab.instance.GetComponent<global::StorageContainer>().inventory, -1, true, false, null, true))\r\n\t\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemSkinChange",
      "HookName": "OnItemSkinChange",
      "HookParameters": {
        "inventoryId": "int",
        "slot": "Item",
        "instance": "RepairBench",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RepairBench",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ChangeSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::Item slot = base.inventory.GetSlot(0);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnItemSkinChange\", inventoryId, slot, this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (isValid && slot.uid != right)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "NoLimboGroupForPlayers [patch]",
      "HookName": "NoLimboGroupForPlayers [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BaseEntity",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "UpdateNetworkGroup",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "OnMapMarkerAdd",
      "HookName": "OnMapMarkerAdd",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_AddMarker",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(8uL), global::BaseEntity.RPC_Server.FromOwner(false)]\r\npublic void Server_AddMarker(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tMapNote mapNote = msg.read.Proto<MapNote>(null);\r\n\tif (Interface.CallHook(\"OnMapMarkerAdd\", this, mapNote) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanUseMapMarkers)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnMapMarkerAdd [patch]",
      "HookName": "OnMapMarkerAdd [patch]",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_AddMarker",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnMapMarkerAdded",
      "HookName": "OnMapMarkerAdded",
      "HookParameters": {
        "instance": "BasePlayer",
        "mapNote": "MapNote"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Server_AddMarker",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tthis.State.pointsOfInterest.Add(mapNote);\r\n\tthis.DirtyPlayerState();\r\n\tthis.SendMarkersToClient();\r\n\tthis.TeamUpdate();\r\n\tInterface.CallHook(\"OnMapMarkerAdded\", this, mapNote);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClothingItemChanged",
      "HookName": "OnClothingItemChanged",
      "HookParameters": {
        "instance": "PlayerInventory",
        "item": "Item",
        "bAdded": "bool"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClothingChanged",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "bAdded": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tbase.baseEntity.ProcessMissionEvent(global::BaseMission.MissionEventType.CLOTHINGCHANGED, 0, 0f);\r\n\tInterface.CallHook(\"OnClothingItemChanged\", this, item, bAdded);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseHitch",
      "HookName": "OnHorseHitch",
      "HookParameters": {
        "hitchable": "IHitchable",
        "spot": "HitchSpot"
      },
      "ReturnBehavior": 1,
      "TargetType": "HitchTrough",
      "Category": "Animal",
      "MethodData": {
        "MethodName": "AttemptToHitch",
        "ReturnType": "bool",
        "Arguments": {
          "hitchable": "HitchTrough/IHitchable",
          "spot": "HitchTrough/HitchSpot"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (spot == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnHorseHitch\", hitchable, spot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tspot.SetOccupiedBy(hitchable);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHorseUnhitch",
      "HookName": "OnHorseUnhitch",
      "HookParameters": {
        "hitchable": "IHitchable",
        "hitchSpot": "HitchSpot"
      },
      "ReturnBehavior": 1,
      "TargetType": "HitchTrough",
      "Category": "Animal",
      "MethodData": {
        "MethodName": "UnHitch",
        "ReturnType": "void",
        "Arguments": {
          "hitchable": "HitchTrough/IHitchable"
        }
      },
      "CodeAfterInjection": "//---\r\n\tfor (int i = 0; i < array.Length; i++)\r\n\t{\r\n\t\tglobal::HitchTrough.HitchSpot hitchSpot = array[i];\r\n\t\tif (hitchSpot.GetHitchable(base.isServer) == hitchable)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnHorseUnhitch\", hitchable, hitchSpot) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\thitchSpot.SetOccupiedBy(null);\r\n\t\t\thitchable.SetHitch(null, null);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSensorDetect",
      "HookName": "OnSensorDetect",
      "ReturnBehavior": 0,
      "TargetType": "HBHFSensor",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdatePassthroughAmount",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tglobal::BuildingPrivlidge buildingPrivilege = this.GetBuildingPrivilege();\r\n\t\tforeach (global::BaseEntity current in this.myTrigger.entityContents)\r\n\t\t{\r\n\t\t\tglobal::BasePlayer basePlayer = current as global::BasePlayer;\r\n\t\t\tif (basePlayer != null && Interface.CallHook(\"OnSensorDetect\", this, basePlayer) == null && !(basePlayer == null) && !basePlayer.IsDead() && !basePlayer.IsSleeping() && basePlayer.isServer)\r\n\t\t\t{\r\n\t\t\t\tbool flag = buildingPrivilege != null && buildingPrivilege.IsAuthed(basePlayer);\r\n\t\t\t\tif ((!flag || this.ShouldIncludeAuthorized()) && (flag || this.ShouldIncludeOthers()) && current.IsVisible(base.transform.position + base.transform.forward * 0.1f, (float)this.range))\r\n\t\t\t\t{\r\n\t\t\t\t\tthis.detectedPlayers++;\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "FixItemKeyId [patch]",
      "HookName": "FixItemKeyId [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ItemCrafter",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "CraftItem",
        "ReturnType": "bool",
        "Arguments": {
          "bp": "ItemBlueprint",
          "owner": "BasePlayer",
          "instanceData": "ProtoBuf.Item/InstanceData",
          "amount": "int",
          "skinID": "int",
          "fromTempBlueprint": "Item",
          "free": "bool"
        }
      }
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [ContainerIOEntity]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "ContainerIOEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif ((this.needsBuildingPrivilegeToUse || global::StorageContainer.ShouldRequireAuthIfNoCodelock(this, this.requireAuthIfNotLocked)) && !player.CanBuild())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehiclePush",
      "HookName": "OnVehiclePush",
      "HookParameters": {
        "instance": "BaseVehicle",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseVehicle",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_WantsPush",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.OnlyOwnerAccessible() && player != this.creatorEntity)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnVehiclePush\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tplayer.metabolism.calories.Subtract(3f);\r\n\tplayer.metabolism.SendChangesToClient();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanRagdollDismount",
      "HookName": "CanRagdollDismount",
      "HookParameters": {
        "instance": "BaseRagdoll",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseRagdoll",
      "Category": "Player",
      "MethodData": {
        "MethodName": "AllowPlayerInstigatedDismount",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool AllowPlayerInstigatedDismount(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanRagdollDismount\", this, player);\r\n\treturn returnvar is bool && (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCatapultFireForce",
      "HookName": "OnCatapultFireForce",
      "HookDescription": "Called before a catapult is fired, returning a float changes the force of the shot.",
      "HookParameters": {
        "instance": "Catapult",
        "shooter": "BasePlayer",
        "num2": "float"
      },
      "ReturnBehavior": 3,
      "TargetType": "Catapult",
      "Category": "Primitive",
      "MethodData": {
        "MethodName": "Fire",
        "ReturnType": "bool",
        "Arguments": {
          "shooter": "BasePlayer",
          "force": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\tfloat num = Mathf.Lerp(2f, 1f, Mathf.Clamp01(force));\r\n\tfloat num2 = Mathf.Lerp(0.5f, 1f, Mathf.Clamp01(force));\r\n\tbool flag = true;\r\n\tVector3 firingPos = this.muzzle.position;\r\n\tglobal::BasePlayer passenger = base.GetPassenger();\r\n\tobject returnvar = Interface.CallHook(\"OnCatapultFireForce\", this, shooter, num2);\r\n\tif (returnvar is float)\r\n\t{\r\n\t\tnum2 = (float)returnvar;\r\n\t}\r\n\tif (passenger != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStashHidden",
      "HookName": "OnStashHidden",
      "HookParameters": {
        "instance": "StashContainer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_HideStash",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnStashHidden(rpc.player, this);\r\n\tthis.SetHidden(true);\r\n\tInterface.CallHook(\"OnStashHidden\", this, rpc.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [PhotoFrame]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "PhotoFrame"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhotoFrame",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool CanUpdateSign(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.IsAdmin || player.IsDeveloper || (player.CanBuild() && (!base.IsLocked() || player.userID == base.OwnerID));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignLocked [PhotoFrame]",
      "HookName": "OnSignLocked",
      "HookParameters": {
        "instance": "PhotoFrame",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhotoFrame",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "LockSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Locked, true, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tbase.OwnerID = msg.player.userID;\r\n\tInterface.CallHook(\"OnSignLocked\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [PhotoFrame]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "instance": "PhotoFrame",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhotoFrame",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tglobal::FileStorage.server.RemoveAllByEntity(this.net.ID);\r\n\tthis._overlayTextureCrc = global::FileStorage.server.Store(array, global::FileStorage.Type.png, this.net.ID, 0u);\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMixingTableToggle",
      "HookName": "OnMixingTableToggle",
      "HookParameters": {
        "instance": "MixingTable",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MixingTable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SVSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\nprivate void SVSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnMixingTableToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == base.IsOn())\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControl",
      "HookName": "OnBookmarkControl",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string",
        "remoteControllable": "IRemoteControllable"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, ent.transform.position) >= remoteControllable.MaxRange)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnBookmarkControl\", this, player, text, remoteControllable) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkDelete",
      "HookName": "OnBookmarkDelete",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "DeleteBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.controlBookmarks.Contains(text))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkDelete\", this, player, text) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.controlBookmarks.Remove(text);\r\n\t\tthis.SendControlBookmarks(player);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkAdd",
      "HookName": "OnBookmarkAdd",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "AddBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tplayer.ChatMessage(\"Too many bookmarks, delete some\");\r\n\t\treturn;\r\n\t}\r\n\tthis.nextAddTime = Time.realtimeSinceStartup + 1f;\r\n\tstring text = msg.read.String(256, false);\r\n\tif (Interface.CallHook(\"OnBookmarkAdd\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ForceAddBookmark(text);\r\n\tthis.SendControlBookmarks(player);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarksSendControl",
      "HookName": "OnBookmarksSendControl",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "SendControlBookmarks",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = this.GenerateControlBookmarkString();\r\n\tif (Interface.CallHook(\"OnBookmarksSendControl\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.ClientRPC(global::RpcTarget.Player(\"ReceiveBookmarks\", player), text);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnd",
      "HookName": "OnBookmarkControlEnd",
      "HookParameters": {
        "instance": "ComputerStation",
        "ply": "BasePlayer",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "StopControl",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void StopControl(global::BasePlayer ply)\r\n{\r\n\tglobal::BaseEntity baseEntity = this.currentlyControllingEnt.Get(true);\r\n\tif (baseEntity)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkControlEnd\", this, ply, baseEntity) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbaseEntity.GetComponent<global::IRemoteControllable>().StopControl(new global::CameraViewerId(this.currentPlayerID, 0L));\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSolarPanelSunUpdate",
      "HookName": "OnSolarPanelSunUpdate",
      "HookParameters": {
        "instance": "SolarPanel",
        "num": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "SolarPanel",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SunUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tbool arg_A6_0 = this.currentEnergy != num;\r\n\tthis.currentEnergy = num;\r\n\tif (arg_A6_0)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnSolarPanelSunUpdate\", this, num) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.MarkDirty();\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerInitialize",
      "HookName": "OnServerInitialize",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Initialize",
        "ReturnType": "bool",
        "Arguments": {
          "loadSave": "bool",
          "saveFile": "string",
          "allowOutOfDateSaves": "bool",
          "skipInitialSpawn": "bool"
        }
      },
      "CodeAfterInjection": "public bool Initialize(bool loadSave = true, string saveFile = \"\", bool allowOutOfDateSaves = false, bool skipInitialSpawn = false)\r\n{\r\n\tInterface.CallHook(\"OnServerInitialize\");\r\n\tthis.persistance = new global::UserPersistance(ConVar.Server.rootFolder);\r\n\tthis.playerStateManager = new global::PlayerStateManager(this.persistance);\r\n\tglobal::TutorialIsland.GenerateIslandSpawnPoints(true);\r\n\tglobal::BasePlayer.InitInternalState(32);\r\n\tif (SingletonComponent<global::SpawnHandler>.Instance)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDefaultItemsReceive",
      "HookName": "OnDefaultItemsReceive",
      "HookParameters": {
        "instance": "PlayerInventory"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveDefaultItems",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void GiveDefaultItems()\r\n{\r\n\tif (Interface.CallHook(\"OnDefaultItemsReceive\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.Strip();\r\n\tglobal::BaseGameMode activeGameMode = global::BaseGameMode.GetActiveGameMode(true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDefaultItemsReceived",
      "HookName": "OnDefaultItemsReceived",
      "HookParameters": {
        "instance": "PlayerInventory"
      },
      "ReturnBehavior": 0,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "GiveDefaultItems",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tthis.GiveItem(global::ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, global::ItemOwnershipPhrases.BornPhrase), this.containerBelt);\r\n\t\tthis.GiveItem(global::ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, global::ItemOwnershipPhrases.BornPhrase), this.containerBelt);\r\n\t\tthis.GiveItem(global::ItemManager.CreateByName(\"snowball\", 1, 0uL).SetItemOwnership(base.baseEntity, global::ItemOwnershipPhrases.BornPhrase), this.containerBelt);\r\n\t}\r\n\tInterface.CallHook(\"OnDefaultItemsReceived\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerBanned [Publisher/VAC]",
      "HookName": "IOnPlayerBanned",
      "HookParameters": {
        "connection": "Connection",
        "Status": "AuthResponse"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnValidateAuthTicketResponse",
        "ReturnType": "void",
        "Arguments": {
          "SteamId": "ulong",
          "OwnerId": "ulong",
          "Status": "AuthResponse"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif ((Status == AuthResponse.PublisherBanned || Status == AuthResponse.VACBanned) && !this.bannedPlayerNotices.Contains(SteamId))\r\n\t{\r\n\t\tInterface.CallHook(\"IOnPlayerBanned\", connection, Status);\r\n\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t{\r\n\t\t\t2,\r\n\t\t\t0,\r\n\t\t\t\"<color=#fff>SERVER</color> Kicking \" + connection.username.EscapeRichText(false) + \" (banned by anticheat)\"\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerSpawn",
      "HookName": "OnPlayerSpawn",
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SpawnNewPlayer",
        "ReturnType": "BasePlayer",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "public global::BasePlayer SpawnNewPlayer(Connection connection)\r\n{\r\n\tglobal::RelationshipManager.PlayerTeam playerTeam = global::RelationshipManager.ServerInstance.FindPlayersTeam(connection.userid);\r\n\tglobal::BasePlayer.SpawnPoint spawnPoint = global::ServerMgr.FindSpawnPoint(null, (playerTeam != null) ? playerTeam.teamID : 0uL);\r\n\tglobal::BasePlayer basePlayer = global::GameManager.server.CreateEntity(\"assets/prefabs/player/player.prefab\", spawnPoint.pos, spawnPoint.rot, true).ToPlayer();\r\n\tif (Interface.CallHook(\"OnPlayerSpawn\", basePlayer, connection) != null)\r\n\t{\r\n\t\treturn spawnPoint;\r\n\t}\r\n\tbasePlayer.health = 0f;\r\n\tbasePlayer.lifestate = global::BaseCombatEntity.LifeState.Dead;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBonusItemDrop",
      "HookName": "OnBonusItemDrop",
      "HookParameters": {
        "item": "Item",
        "basePlayer": "BasePlayer",
        "container": "ItemContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tif (num4 > 0)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item item = global::ItemManager.Create(global::LootContainer.scrapDef, num4, 0uL, true);\r\n\t\t\t\tif (item != null)\r\n\t\t\t\t{\r\n\t\t\t\t\tif (Interface.CallHook(\"OnBonusItemDrop\", item, basePlayer, container) != null)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\treturn;\r\n\t\t\t\t\t}\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t}\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerCorpseSpawn",
      "HookName": "OnPlayerCorpseSpawn",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {
          "flagsOnDeath": "BasePlayer/PlayerFlags",
          "posOnDeath": "UnityEngine.Vector3",
          "rotOnDeath": "UnityEngine.Quaternion",
          "triggersOnDeath": "System.Collections.Generic.List`1<TriggerBase>",
          "forceServerSide": "bool"
        }
      },
      "CodeAfterInjection": "public virtual global::BaseCorpse CreateCorpse(global::BasePlayer.PlayerFlags flagsOnDeath, Vector3 posOnDeath, Quaternion rotOnDeath, List<global::TriggerBase> triggersOnDeath, bool forceServerSide = false)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerCorpseSpawn\", this) != null)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tusing (TimeWarning.New(\"Create corpse\", 0))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerCorpseSpawned",
      "HookName": "OnPlayerCorpseSpawned",
      "HookParameters": {
        "instance": "BasePlayer",
        "enumerator": "PlayerCorpse"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {
          "flagsOnDeath": "BasePlayer/PlayerFlags",
          "posOnDeath": "UnityEngine.Vector3",
          "rotOnDeath": "UnityEngine.Quaternion",
          "triggersOnDeath": "System.Collections.Generic.List`1<TriggerBase>",
          "forceServerSide": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tif (this.lifeStory != null)\r\n\t\t\t{\r\n\t\t\t\tnum += Mathf.Clamp(Mathf.FloorToInt(this.lifeStory.secondsAlive / 180f), 0, 20);\r\n\t\t\t}\r\n\t\t\targ_1FB_0.containedItems.Add(new global::ItemAmount(global::ItemManager.FindItemDefinition(\"fat.animal\"), (float)num));\r\n\t\t\tInterface.CallHook(\"OnPlayerCorpseSpawned\", this, playerCorpse);\r\n\t\t\treturn playerCorpse;\r\n\t\t}\r\n\t}\r\n\treturn null;\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRefill",
      "HookName": "OnItemRefill",
      "HookParameters": {
        "item": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModRepair",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tif (item.conditionNormalized >= 1f)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnItemRefill\", item, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat conditionNormalized = item.conditionNormalized;\r\n\t\tfloat maxConditionNormalized = item.maxConditionNormalized;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerAdd",
      "HookName": "OnRfListenerAdd",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!global::RFManager.GetListenerSet(frequency).Add(obj))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerRemove",
      "HookName": "OnRfListenerRemove",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveListener(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfListenerRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (global::RFManager.GetListenerSet(frequency).Remove(obj))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterAdd",
      "HookName": "OnRfBroadcasterAdd",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void AddBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterAdd\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tHashSet<global::IRFObject> expr_23 = global::RFManager.GetBroadcasterSet(frequency);\r\n\tPredicate<global::IRFObject> arg_43_1;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterRemove",
      "HookName": "OnRfBroadcasterRemove",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "public static void RemoveBroadcaster(int frequency, global::IRFObject obj)\r\n{\r\n\tfrequency = global::RFManager.ClampFrequency(frequency);\r\n\tif (Interface.CallHook(\"OnRfBroadcasterRemove\", obj, frequency) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tHashSet<global::IRFObject> broadcasterSet = global::RFManager.GetBroadcasterSet(frequency);\r\n\tHashSet<global::IRFObject> arg_44_0 = broadcasterSet;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterAdded",
      "HookName": "OnRfBroadcasterAdded",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tDebug.LogWarning(string.Format(\"Found null entries in the RF broadcaster set for frequency {0}... cleaning up.\", frequency));\r\n\t}\r\n\tif (expr_23.Add(obj))\r\n\t{\r\n\t\tInterface.CallHook(\"OnRfBroadcasterAdded\", obj, frequency);\r\n\t\tbool flag;\r\n\t\tif (!global::RFManager._isFrequencyBroadcasting.TryGetValue(frequency, out flag) || !flag)\r\n\t\t{\r\n\t\t\tglobal::RFManager._isFrequencyBroadcasting[frequency] = true;\r\n\t\t\tglobal::RFManager.UpdateListenersForFrequency(frequency, true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerRemoved",
      "HookName": "OnRfListenerRemoved",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (global::RFManager.GetListenerSet(frequency).Remove(obj))\r\n\t{\r\n\t\tobj.RFSignalUpdate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnRfListenerRemoved\", obj, frequency);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfListenerAdded",
      "HookName": "OnRfListenerAdded",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "AddListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tbool flag;\r\n\tbool on = global::RFManager._isFrequencyBroadcasting.TryGetValue(frequency, out flag) & flag;\r\n\tobj.RFSignalUpdate(on);\r\n\tInterface.CallHook(\"OnRfListenerAdded\", obj, frequency);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfBroadcasterRemoved",
      "HookName": "OnRfBroadcasterRemoved",
      "HookParameters": {
        "obj": "IRFObject",
        "frequency": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveBroadcaster",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tDebug.LogWarning(string.Format(\"Found null entries in the RF broadcaster set for frequency {0}... cleaning up.\", frequency));\r\n\t}\r\n\tif (broadcasterSet.Remove(obj))\r\n\t{\r\n\t\tInterface.CallHook(\"OnRfBroadcasterRemoved\", obj, frequency);\r\n\t\tif (broadcasterSet.Count == 0)\r\n\t\t{\r\n\t\t\tglobal::RFManager._isFrequencyBroadcasting[frequency] = false;\r\n\t\t\tglobal::RFManager.UpdateListenersForFrequency(frequency, false);\r\n\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Broadcaster]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "instance": "RFBroadcaster",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFBroadcaster",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(msg.player);\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, false, this.IsPowered());\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.frequency = num;\r\n\tthis.MarkDirty();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Broadcaster]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "instance": "RFBroadcaster",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFBroadcaster",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tthis.frequency = num;\r\n\tthis.MarkDirty();\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tbase.Hurt(this.MaxHealth() * 0.01f, Rust.DamageType.Decay, this, true);\r\n\tInterface.CallHook(\"OnRfFrequencyChanged\", this, num, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Receiver]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "instance": "RFReceiver",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "RFReceiver",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (msg.player == null || !msg.player.CanBuild())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tnum = global::RFManager.ClampFrequency(num);\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Receiver]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "instance": "RFReceiver",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "RFReceiver",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tnum = global::RFManager.ClampFrequency(num);\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n\tthis.MarkDirty();\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnRfFrequencyChanged\", this, num, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [Detonator]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "instance": "Detonator",
        "freq": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Detonator",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "freq": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (global::RFManager.IsReserved(freq))\r\n\t{\r\n\t\tglobal::RFManager.ReserveErrorPrint(player);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, freq, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item ownerItem = base.GetOwnerItem();\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, freq, this, false, base.IsOn());\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [Detonator]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "instance": "Detonator",
        "freq": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Detonator",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "freq": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (ownerItem != null)\r\n\t{\r\n\t\townerItem.LoseCondition(ownerItem.maxCondition * 0.01f);\r\n\t}\r\n\tInterface.CallHook(\"OnRfFrequencyChanged\", this, freq, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChange [PagerEntity]",
      "HookName": "OnRfFrequencyChange",
      "HookParameters": {
        "instance": "PagerEntity",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PagerEntity",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.nextChangeTime = Time.time + 2f;\r\n\tint num = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnRfFrequencyChange\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRfFrequencyChanged [PagerEntity]",
      "HookName": "OnRfFrequencyChanged",
      "HookParameters": {
        "instance": "PagerEntity",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PagerEntity",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerSetFrequency",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tglobal::RFManager.ChangeFrequency(this.frequency, num, this, true, true);\r\n\tthis.frequency = num;\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n\tInterface.CallHook(\"OnRfFrequencyChanged\", this, num, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBonusItemDropped",
      "HookName": "OnBonusItemDropped",
      "HookParameters": {
        "item": "Item",
        "basePlayer": "BasePlayer",
        "container": "ItemContainer"
      },
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t(item.Drop(this.GetDropPosition() + new Vector3(0f, 0.5f, 0f), this.GetInheritedDropVelocity(), default(Quaternion)) as global::DroppedItem).DropReason = global::DroppedItem.DropReasonEnum.Loot;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnBonusItemDropped\", item, basePlayer, container);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRemoveDying",
      "HookName": "OnRemoveDying",
      "HookParameters": {
        "instance": "GrowableEntity",
        "receiver": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "RemoveDying",
        "ReturnType": "void",
        "Arguments": {
          "receiver": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.Properties.removeDyingItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRemoveDying\", this, receiver) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.Properties.removeDyingEffect.isValid)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSleepingBagDestroy",
      "HookName": "OnSleepingBagDestroy",
      "ReturnBehavior": 0,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DestroyBag",
        "ReturnType": "bool",
        "Arguments": {
          "userID": "ulong",
          "sleepingBag": "NetworkableId"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::SleepingBag sleepingBag2 = global::SleepingBag.FindForPlayer(userID, true).FirstOrDefault((global::SleepingBag x) => x.net.ID == sleepingBag);\r\n\tif (sleepingBag2 == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSleepingBagDestroy\", sleepingBag2, userID) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tglobal::SleepingBag.RemoveBagForPlayer(sleepingBag2, sleepingBag2.deployerUserID);\r\n\tsleepingBag2.deployerUserID = 0uL;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSleepingBagDestroyed",
      "HookName": "OnSleepingBagDestroyed",
      "HookParameters": {
        "sleepingBag2": "SleepingBag",
        "userID": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DestroyBag",
        "ReturnType": "bool",
        "Arguments": {
          "userID": "ulong",
          "sleepingBag": "NetworkableId"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tglobal::BasePlayer basePlayer = global::BasePlayer.FindByID(userID);\r\n\tif (basePlayer != null)\r\n\t{\r\n\t\tbasePlayer.SendRespawnOptions();\r\n\t\tInterface.CallHook(\"OnSleepingBagDestroyed\", sleepingBag2, userID);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnBagUnclaimed(basePlayer, sleepingBag2);\r\n\t}\r\n\treturn true;\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnConstructionPlace",
      "HookName": "OnConstructionPlace",
      "ReturnBehavior": 0,
      "TargetType": "Planner",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoPlacement",
        "ReturnType": "UnityEngine.GameObject",
        "Arguments": {
          "placement": "Construction/Target",
          "component": "Construction"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tfloat num2 = (buildingBlock != null) ? buildingBlock.currentGrade.maxHealth : baseCombatEntity.startHealth;\r\n\t\tbaseCombatEntity.ResetLifeStateOnSpawn = false;\r\n\t\tbaseCombatEntity.InitializeHealth(num2 * num, baseCombatEntity.StartMaxHealth());\r\n\t}\r\n\tif (Interface.CallHook(\"OnConstructionPlace\", baseEntity, component, placement, ownerPlayer) != null)\r\n\t{\r\n\t\tif (baseEntity.IsValid())\r\n\t\t{\r\n\t\t\tbaseEntity.KillMessage();\r\n\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAnalysisComplete",
      "HookName": "OnAnalysisComplete",
      "HookParameters": {
        "instance": "SurveyCrater",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "SurveyCrater",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "AnalysisComplete",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server]\r\npublic void AnalysisComplete(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tInterface.CallHook(\"OnAnalysisComplete\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkInput",
      "HookName": "OnBookmarkInput",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "inputState": "InputState"
      },
      "ReturnBehavior": 1,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "PlayerServerInput",
        "ReturnType": "void",
        "Arguments": {
          "inputState": "InputState",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override void PlayerServerInput(global::InputState inputState, global::BasePlayer player)\r\n{\r\n\tbase.PlayerServerInput(inputState, player);\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved2) && this.currentlyControllingEnt.IsValid(true))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBookmarkInput\", this, player, inputState) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.currentlyControllingEnt.Get(true).GetComponent<global::IRemoteControllable>().UserInput(inputState, new global::CameraViewerId(player.userID, 0L));\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerInitialized",
      "HookName": "IOnServerInitialized",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "OpenConnection",
        "ReturnType": "void",
        "Arguments": {
          "useSteamServer": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::EACServer.DoStartup();\r\n\tbase.InvokeRepeating(\"DoTick\", 1f, 1f / (float)ConVar.Server.tickrate);\r\n\tbase.InvokeRepeating(\"DoHeartbeat\", 1f, 1f);\r\n\tthis.runFrameUpdate = true;\r\n\tConsoleSystem.OnReplicatedVarChanged += new Action<string, string>(global::ServerMgr.OnReplicatedVarChanged);\r\n\tInterface.CallHook(\"IOnServerInitialized\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [AutoTurret]",
      "HookName": "OnEntityControl",
      "HookParameters": {
        "instance": "AutoTurret",
        "playerID": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn !this.booting && this.IsPowered() && !this.PeacekeeperMode();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [PoweredRemoteControl]",
      "HookName": "OnEntityControl",
      "HookParameters": {
        "instance": "PoweredRemoteControlEntity",
        "playerID": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "PoweredRemoteControlEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.IsPowered() || this.IsStatic();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityControl [RemoteControlEntity]",
      "HookName": "OnEntityControl",
      "HookParameters": {
        "instance": "RemoteControlEntity",
        "playerID": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "RemoteControlEntity",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "CanControl",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong"
        }
      },
      "CodeAfterInjection": "public virtual bool CanControl(ulong playerID)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEntityControl\", this, playerID);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [ContainerIOEntity]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ContainerIOEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "ContainerIOEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Open, false, false, true);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [DroppedItemContainer]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "DroppedItemContainer"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItemContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n\tif (this.inventory == null || this.inventory.itemList == null || this.inventory.itemList.Count == 0)\r\n\t{\r\n\t\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n\t}\r\n\telse\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemLock",
      "HookName": "OnItemLock",
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LockUnlock",
        "ReturnType": "void",
        "Arguments": {
          "bNewState": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.HasFlag(global::Item.Flag.IsLocked) == bNewState)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (bNewState && Interface.CallHook(\"OnItemLock\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetFlag(global::Item.Flag.IsLocked, bNewState);\r\n\tthis.MarkDirty();\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnItemUnlock",
      "HookName": "OnItemUnlock",
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LockUnlock",
        "ReturnType": "void",
        "Arguments": {
          "bNewState": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (bNewState && Interface.CallHook(\"OnItemLock\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!bNewState && Interface.CallHook(\"OnItemUnlock\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetFlag(global::Item.Flag.IsLocked, bNewState);\r\n\tthis.MarkDirty();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretRotate",
      "HookName": "OnTurretRotate",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "FlipAim",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.IsOnline() || !this.IsAuthed(rpc.player) || this.booting)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretRotate\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.transform.rotation = Quaternion.LookRotation(-base.transform.forward, base.transform.up);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterTargetChange",
      "HookName": "OnCounterTargetChange",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SERVER_SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void SERVER_SetTarget(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tint OxideGen_0 = msg.read.Int32();\r\n\tif (Interface.CallHook(\"OnCounterTargetChange\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.CanPlayerAdmin(msg.player))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterTargetChange [patch]",
      "HookName": "OnCounterTargetChange [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "SERVER_SetTarget",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      }
    },
    {
      "Type": 1,
      "Name": "OnCounterModeToggle",
      "HookName": "OnCounterModeToggle",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ToggleDisplayMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void ToggleDisplayMode(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tbool OxideGen_0 = msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnCounterModeToggle\", this, msg.player, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!msg.player.CanBuild())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCounterModeToggle [patch]",
      "HookName": "OnCounterModeToggle [patch]",
      "ReturnBehavior": 0,
      "TargetType": "PowerCounter",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "ToggleDisplayMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [ElectricSwitch]",
      "HookName": "OnSwitchToggled",
      "HookParameters": {
        "instance": "ElectricSwitch",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ElectricSwitch",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_Switch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool @switch = msg.read.Bool();\r\n\tthis.SetSwitch(@switch);\r\n\tInterface.CallHook(\"OnSwitchToggled\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [FuelGenerator]",
      "HookName": "OnSwitchToggled",
      "HookParameters": {
        "instance": "FuelGenerator",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "FuelGenerator",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool generatorState = msg.read.Bit();\r\n\tthis.SetGeneratorState(generatorState);\r\n\tInterface.CallHook(\"OnSwitchToggled\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStart [MotorRowboat]",
      "HookName": "OnEngineStart",
      "ReturnBehavior": 0,
      "TargetType": "MotorRowboat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "EngineToggle",
        "ReturnType": "void",
        "Arguments": {
          "wantsOn": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.fuelSystem.HasFuel(true))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer OxideGen_0 = this.GetDriver();\r\n\tif (wantsOn && Interface.CallHook(\"OnEngineStart\", this, OxideGen_0) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, wantsOn, false, true);\r\n\tif (wantsOn)\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStarted [MotorRowboat]",
      "HookName": "OnEngineStarted",
      "ReturnBehavior": 0,
      "TargetType": "MotorRowboat",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "EngineToggle",
        "ReturnType": "void",
        "Arguments": {
          "wantsOn": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, wantsOn, false, true);\r\n\tif (wantsOn)\r\n\t{\r\n\t\tInterface.CallHook(\"OnEngineStarted\", this, OxideGen_0);\r\n\t}\r\n\tif (wantsOn)\r\n\t{\r\n\t\tthis.rigidBody.WakeUp();\r\n\t\tthis.buoyancy.Wake();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineStatsRefresh",
      "HookName": "OnEngineStatsRefresh",
      "HookParameters": {
        "instance": "VehicleModuleEngine",
        "engineStorage": "EngineStorage"
      },
      "ReturnBehavior": 1,
      "TargetType": "VehicleModuleEngine",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshPerformanceStats",
        "ReturnType": "void",
        "Arguments": {
          "engineStorage": "Rust.Modular.EngineStorage"
        }
      },
      "CodeAfterInjection": "public void RefreshPerformanceStats(Rust.Modular.EngineStorage engineStorage)\r\n{\r\n\tif (Interface.CallHook(\"OnEngineStatsRefresh\", this, engineStorage) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (engineStorage == null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineStatsRefreshed",
      "HookName": "OnEngineStatsRefreshed",
      "HookParameters": {
        "instance": "VehicleModuleEngine",
        "engineStorage": "EngineStorage"
      },
      "ReturnBehavior": 0,
      "TargetType": "VehicleModuleEngine",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshPerformanceStats",
        "ReturnType": "void",
        "Arguments": {
          "engineStorage": "Rust.Modular.EngineStorage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tthis.PerformanceFractionAcceleration = this.GetPerformanceFraction(engineStorage.accelerationBoostPercent);\r\n\t\tthis.PerformanceFractionTopSpeed = this.GetPerformanceFraction(engineStorage.topSpeedBoostPercent);\r\n\t\tthis.PerformanceFractionFuelEconomy = this.GetPerformanceFraction(engineStorage.fuelEconomyBoostPercent);\r\n\t}\r\n\tthis.OverallPerformanceFraction = (this.PerformanceFractionAcceleration + this.PerformanceFractionTopSpeed + this.PerformanceFractionFuelEconomy) / 3f;\r\n\tInterface.CallHook(\"OnEngineStatsRefreshed\", this, engineStorage);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModulesAssign",
      "HookName": "OnVehicleModulesAssign",
      "HookParameters": {
        "instance": "ModularCar",
        "socketItemDefs": "ItemModVehicleModule"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCar",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SpawnPreassignedModules",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (this.spawnSettings.configurationOptions.IsNullOrEmpty<global::ModularCarPresetConfig>())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ModularCarPresetConfig modularCarPresetConfig = this.spawnSettings.configurationOptions[UnityEngine.Random.Range(0, this.spawnSettings.configurationOptions.Length)];\r\n\tif (Interface.CallHook(\"OnVehicleModulesAssign\", this, modularCarPresetConfig.socketItemDefs) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i < modularCarPresetConfig.socketItemDefs.Length; i++)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModulesAssigned",
      "HookName": "OnVehicleModulesAssigned",
      "HookParameters": {
        "instance": "ModularCar",
        "socketItemDefs": "ItemModVehicleModule"
      },
      "ReturnBehavior": 0,
      "TargetType": "ModularCar",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SpawnPreassignedModules",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t{\r\n\t\t\t\titem.Remove(0f);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnVehicleModulesAssigned\", this, modularCarPresetConfig.socketItemDefs);\r\n\tbase.Invoke(new Action(this.HandleAdminBonus), 0f);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleSelect",
      "HookName": "OnVehicleModuleSelect",
      "HookParameters": {
        "vehicleItem": "Item",
        "instance": "ModularCarGarage",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item vehicleItem = this.carOccupant.GetVehicleItem(itemUID);\r\n\tif (vehicleItem != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnVehicleModuleSelect\", vehicleItem, this, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbool flag = player.inventory.loot.RemoveContainerAt(3);\r\n\t\tglobal::BaseVehicleModule baseVehicleModule;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleSelected",
      "HookName": "OnVehicleModuleSelected",
      "HookParameters": {
        "vehicleItem": "Item",
        "instance": "ModularCarGarage",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tplayer.inventory.loot.SendImmediate();\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnVehicleModuleSelected\", vehicleItem, this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnVehicleModuleSelectedFix [patch]",
      "HookName": "OnVehicleModuleSelectedFix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_SelectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleDeselected",
      "HookName": "OnVehicleModuleDeselected",
      "HookParameters": {
        "instance": "ModularCarGarage",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_DeselectedLootItem",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (player.inventory.loot.RemoveContainerAt(3))\r\n\t{\r\n\t\tplayer.inventory.loot.SendImmediate();\r\n\t}\r\n\tInterface.CallHook(\"OnVehicleModuleDeselected\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationRespond",
      "HookName": "OnNpcConversationRespond",
      "HookParameters": {
        "instance": "NPCTalking",
        "player": "BasePlayer",
        "conversationFor": "ConversationData",
        "genericMissionById": "ResponseNode"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t}\r\n\tglobal::ConversationData.ResponseNode responseNode = conversationFor.speeches[num].responses[num2];\r\n\tif (responseNode != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnNpcConversationRespond\", this, player, conversationFor, responseNode) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (responseNode.conditions.Length != 0)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationResponded",
      "HookName": "OnNpcConversationResponded",
      "HookParameters": {
        "instance": "NPCTalking",
        "player": "BasePlayer",
        "conversationFor": "ConversationData",
        "genericMissionById": "ResponseNode"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tthis.ForceEndConversation(player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.ForceSpeechNode(player, speechNodeIndex);\r\n\t}\r\n\tInterface.CallHook(\"OnNpcConversationResponded\", this, player, conversationFor, responseNode);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNpcConversationResponded [patch]",
      "HookName": "OnNpcConversationResponded [patch]",
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_ResponsePressed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnVehicleLockableCheck",
      "HookName": "OnVehicleLockableCheck",
      "HookParameters": {
        "instance": "ModularCarCodeLock"
      },
      "ReturnBehavior": 4,
      "TargetType": "ModularCarCodeLock",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanHaveALock",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanHaveALock()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnVehicleLockableCheck\", this);\r\n\tif (returnvar != null)\r\n\t{\r\n\t\treturn returnvar is bool && (bool)returnvar;\r\n\t}\r\n\treturn !this.owner.IsDead() && this.owner.HasDriverMountPoints();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnElevatorCall",
      "HookName": "OnElevatorCall",
      "HookParameters": {
        "instance": "Elevator",
        "elevatorEnt": "Elevator"
      },
      "ReturnBehavior": 1,
      "TargetType": "Elevator",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "<CallElevator>b__26_0",
        "ReturnType": "void",
        "Arguments": {
          "elevatorEnt": "Elevator"
        }
      },
      "CodeAfterInjection": "[CompilerGenerated]\r\nprivate void <CallElevator>b__26_0(global::Elevator elevatorEnt)\r\n{\r\n\tif (elevatorEnt.IsTop)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnElevatorCall\", this, elevatorEnt) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tfloat num;\r\n\t\televatorEnt.RequestMoveLiftTo(this.Floor, out num, this);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnElevatorMove",
      "HookName": "OnElevatorMove",
      "ReturnBehavior": 0,
      "TargetType": "Elevator",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "RequestMoveLiftTo",
        "ReturnType": "bool",
        "Arguments": {
          "targetFloor": "int",
          "timeToTravel": "System.Single&",
          "fromElevator": "Elevator"
        }
      },
      "CodeAfterInjection": "protected bool RequestMoveLiftTo(int targetFloor, out float timeToTravel, global::Elevator fromElevator)\r\n{\r\n\ttimeToTravel = 0f;\r\n\tif (Interface.CallHook(\"OnElevatorMove\", this, targetFloor) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (base.IsBusy())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggle",
      "HookName": "OnHotAirBalloonToggle",
      "HookParameters": {
        "instance": "HotAirBalloon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void EngineSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnHotAirBalloonToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (player == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggled [on]",
      "HookName": "OnHotAirBalloonToggled",
      "HookParameters": {
        "instance": "HotAirBalloon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbool b = msg.read.Bit();\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, b, false, true);\r\n\tif (base.IsOn())\r\n\t{\r\n\t\tbase.Invoke(new Action(this.ScheduleOff), 60f);\r\n\t\tInterface.CallHook(\"OnHotAirBalloonToggled\", this, msg.player);\r\n\t\treturn;\r\n\t}\r\n\tbase.CancelInvoke(new Action(this.ScheduleOff));\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHotAirBalloonToggled [off]",
      "HookName": "OnHotAirBalloonToggled",
      "HookParameters": {
        "instance": "HotAirBalloon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "HotAirBalloon",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "EngineSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbool b = msg.read.Bit();\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, b, false, true);\r\n\tif (base.IsOn())\r\n\t{\r\n\t\tbase.Invoke(new Action(this.ScheduleOff), 60f);\r\n\t\tInterface.CallHook(\"OnHotAirBalloonToggled\", this, msg.player);\r\n\t\treturn;\r\n\t}\r\n\tbase.CancelInvoke(new Action(this.ScheduleOff));\r\n\tInterface.CallHook(\"OnHotAirBalloonToggled\", this, msg.player);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEngineLoadoutRefresh",
      "HookName": "OnEngineLoadoutRefresh",
      "HookParameters": {
        "instance": "EngineStorage"
      },
      "ReturnBehavior": 1,
      "TargetType": "Rust.Modular.EngineStorage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RefreshLoadoutData",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void RefreshLoadoutData()\r\n{\r\n\tif (Interface.CallHook(\"OnEngineLoadoutRefresh\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool arg_50_1;\r\n\tif (base.inventory.IsFull(false))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnReactiveTargetReset",
      "HookName": "OnReactiveTargetReset",
      "HookParameters": {
        "instance": "ReactiveTarget"
      },
      "ReturnBehavior": 0,
      "TargetType": "ReactiveTarget",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ResetTarget",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tbase.CancelInvoke(new Action(this.ResetTarget));\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, false, false, true);\r\n\tthis.knockdownHealth = 100f;\r\n\tthis.SendPowerBurst();\r\n\tInterface.CallHook(\"OnReactiveTargetReset\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentStarted",
      "HookName": "OnExperimentStarted",
      "HookParameters": {
        "instance": "Workbench",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_BeginExperiment",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.inventory.SetLocked(true, false);\r\n\tbase.CancelInvoke(new Action(this.ExperimentComplete));\r\n\tbase.Invoke(new Action(this.ExperimentComplete), 5f);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnExperimentStarted\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentEnd",
      "HookName": "OnExperimentEnd",
      "HookParameters": {
        "instance": "Workbench"
      },
      "ReturnBehavior": 4,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ExperimentComplete",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tint scrapForExperiment = this.GetScrapForExperiment();\r\n\tif (this.pendingBlueprint == null)\r\n\t{\r\n\t\tDebug.LogWarning(\"Pending blueprint was null!\");\r\n\t}\r\n\tif (Interface.CallHook(\"OnExperimentEnd\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (experimentResourceItem != null && experimentResourceItem.amount >= scrapForExperiment && this.pendingBlueprint != null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExperimentEnded",
      "HookName": "OnExperimentEnded",
      "HookParameters": {
        "instance": "Workbench"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ExperimentComplete",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tthis.pendingBlueprint = null;\r\n\tbase.inventory.SetLocked(false, false);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnExperimentEnded\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleModuleMove",
      "HookName": "OnVehicleModuleMove",
      "HookParameters": {
        "moduleForItem": "BaseVehicleModule",
        "instance": "BaseModularVehicle",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseModularVehicle",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "CanMoveFrom",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "item": "Item"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BaseVehicleModule moduleForItem = this.GetModuleForItem(item);\r\n\tif (!(moduleForItem != null))\r\n\t{\r\n\t\treturn true;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnVehicleModuleMove\", moduleForItem, this, player);\r\n\tif (returnvar != null)\r\n\t{\r\n\t\treturn returnvar is bool && (bool)returnvar;\r\n\t}\r\n\treturn moduleForItem.CanBeMovedNow();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSwapToSeat [BaseMountable]",
      "HookName": "CanSwapToSeat",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanSwapToThis",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanSwapToThis(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanSwapToSeat\", player, this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSwapToSeat [ModularCarSeat]",
      "HookName": "CanSwapToSeat",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ModularCarSeat"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarSeat",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanSwapToThis",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public override bool CanSwapToThis(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanSwapToSeat\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.associatedSeatingModule.DoorsAreLockable)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRidableAnimalClaim [RidableHorse]",
      "HookName": "OnRidableAnimalClaim",
      "HookParameters": {
        "instance": "RidableHorse",
        "player": "BasePlayer",
        "purchaseToken": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "RidableHorse",
      "Category": "Animal",
      "MethodData": {
        "MethodName": "SERVER_Claim",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tint tokenItemID = msg.read.Int32();\r\n\tglobal::Item purchaseToken = this.GetPurchaseToken(player, tokenItemID);\r\n\tif (purchaseToken != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnRidableAnimalClaim\", this, player, purchaseToken) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.ItemIsSaddle(purchaseToken))\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRidableAnimalClaimed [RidableHorse]",
      "HookName": "OnRidableAnimalClaimed",
      "HookParameters": {
        "instance": "RidableHorse",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "RidableHorse",
      "Category": "Animal",
      "MethodData": {
        "MethodName": "SERVER_Claim",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, false, false, true);\r\n\t\t\tthis.OnClaimedWithToken(purchaseToken);\r\n\t\t\tpurchaseToken.UseItem(1);\r\n\t\t\tFacepunch.Rust.Analytics.Azure.OnVehiclePurchased(msg.player, this);\r\n\t\t\tthis.AttemptMount(player, false);\r\n\t\t\tInterface.CallHook(\"OnRidableAnimalClaimed\", this, player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneNameUpdated",
      "HookName": "OnPhoneNameUpdated",
      "HookParameters": {
        "instance": "PhoneController",
        "PhoneName": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "UpdatePhoneName",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PhoneName = text;\r\n\tbase.baseEntity.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnPhoneNameUpdated\", this, this.PhoneName, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnEntitySaved",
      "HookName": "IOnEntitySaved",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "saveInfo": "SaveInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ToStream",
        "ReturnType": "void",
        "Arguments": {
          "stream": "System.IO.Stream",
          "saveInfo": "BaseNetworkable/SaveInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tif (saveInfo.msg.baseNetworkable == null)\r\n\t\t{\r\n\t\t\tDebug.LogError(((this != null) ? this.ToString() : null) + \": ToStream - no baseNetworkable!?\");\r\n\t\t}\r\n\t\tInterface.CallHook(\"IOnEntitySaved\", this, saveInfo);\r\n\t\tsaveInfo.msg.WriteToStream(stream, false, 2097152);\r\n\t\tthis.PostSave(saveInfo);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntitySnapshot",
      "HookName": "OnEntitySnapshot",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SendAsSnapshot",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection",
          "justCreated": "bool"
        }
      },
      "CodeAfterInjection": "public void SendAsSnapshot(Connection connection, bool justCreated = false)\r\n{\r\n\tif (Interface.CallHook(\"OnEntitySnapshot\", this, connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite netWrite = Net.sv.StartWrite();\r\n\tconnection.validate.entityUpdates = connection.validate.entityUpdates + 1u;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntitySnapshot [BasePlayer]",
      "HookName": "OnEntitySnapshot",
      "HookParameters": {
        "ent": "BaseNetworkable",
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SendEntitySnapshot",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseNetworkable"
        }
      },
      "CodeAfterInjection": "private void SendEntitySnapshot(global::BaseNetworkable ent)\r\n{\r\n\tif (Interface.CallHook(\"OnEntitySnapshot\", ent, this.net.connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"SendEntitySnapshot\", 0))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkGroupEntered",
      "HookName": "OnNetworkGroupEntered",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "group": "Group"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "OnNetworkGroupEnter",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group"
        }
      },
      "CodeAfterInjection": "public virtual void OnNetworkGroupEnter(Group group)\r\n{\r\n\tInterface.CallHook(\"OnNetworkGroupEntered\", this, group);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkGroupLeft",
      "HookName": "OnNetworkGroupLeft",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "group": "Group"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "OnNetworkGroupLeave",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group"
        }
      },
      "CodeAfterInjection": "public virtual void OnNetworkGroupLeave(Group group)\r\n{\r\n\tInterface.CallHook(\"OnNetworkGroupLeft\", this, group);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStart",
      "HookName": "OnDemoRecordingStart",
      "HookParameters": {
        "text": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (this.net.connection.IsRecording)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = string.Format(\"demos/{0}/{1:yyyy-MM-dd-hhmmss}.dem\", this.UserIDString, DateTime.Now);\r\n\tif (Interface.CallHook(\"OnDemoRecordingStart\", text, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording started: \" + text);\r\n\tthis.net.connection.StartRecording(text, new ConVar.Demo.Header\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStarted",
      "HookName": "OnDemoRecordingStarted",
      "HookParameters": {
        "text": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StartDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tthis.SendFullSnapshot();\r\n\tthis.SendEntityUpdate();\r\n\tglobal::TreeManager.SendSnapshot(this);\r\n\tglobal::ServerMgr.SendReplicatedVars(this.net.connection);\r\n\tbase.InvokeRepeating(new Action(this.MonitorDemoRecording), 10f, 10f);\r\n\tInterface.CallHook(\"OnDemoRecordingStarted\", text, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStop",
      "HookName": "OnDemoRecordingStop",
      "HookParameters": {
        "RecordFilename": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StopDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.net.connection.IsRecording)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnDemoRecordingStop\", this.net.connection.recordFilename, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording stopped: \" + this.net.connection.RecordFilename);\r\n\tthis.net.connection.StopRecording();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDemoRecordingStopped",
      "HookName": "OnDemoRecordingStopped",
      "HookParameters": {
        "RecordFilename": "string",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "StopDemoRecording",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(this.ToString() + \" recording stopped: \" + this.net.connection.RecordFilename);\r\n\tthis.net.connection.StopRecording();\r\n\tbase.CancelInvoke(new Action(this.MonitorDemoRecording));\r\n\tInterface.CallHook(\"OnDemoRecordingStopped\", this.net.connection.recordFilename, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenCook",
      "HookName": "OnOvenCook",
      "HookParameters": {
        "instance": "BaseOven",
        "item": "Item"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Cook",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved8))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item item = this.FindBurnable();\r\n\tif (Interface.CallHook(\"OnOvenCook\", this, item) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (item == null && !this.CanRunWithNoFuel)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenCooked",
      "HookName": "OnOvenCooked",
      "HookParameters": {
        "instance": "BaseOven",
        "item": "Item",
        "enumerator": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Cook",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tthis.ConsumeFuel(item, itemModBurnable);\r\n\t\t}\r\n\t}\r\n\tthis.OnCooked();\r\n\tInterface.CallHook(\"OnOvenCooked\", this, item, slot);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelConsumed",
      "HookName": "OnFuelConsumed",
      "HookParameters": {
        "instance": "BaseOven",
        "fuel": "Item",
        "burnable": "ItemModBurnable"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseOven",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "ConsumeFuel",
        "ReturnType": "void",
        "Arguments": {
          "fuel": "Item",
          "burnable": "ItemModBurnable"
        }
      },
      "CodeAfterInjection": "//---\r\n\tint fuelRate = this.GetFuelRate();\r\n\tfuel.UseItem(fuelRate);\r\n\tFacepunch.Rust.Analytics.Azure.AddPendingItems(this, fuel.info.shortname, fuelRate, \"smelt\", true, false);\r\n\tfuel.fuel = burnable.fuelAmount;\r\n\tfuel.MarkDirty();\r\n\tInterface.CallHook(\"OnFuelConsumed\", this, fuel, burnable);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelAmountCheck",
      "HookName": "OnFuelAmountCheck",
      "HookParameters": {
        "instance": "EntityFuelSystem",
        "fuelItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "GetFuelAmount",
        "ReturnType": "int",
        "Arguments": {}
      },
      "CodeAfterInjection": "public int GetFuelAmount()\r\n{\r\n\tglobal::Item fuelItem = this.GetFuelItem();\r\n\tobject returnvar = Interface.CallHook(\"OnFuelAmountCheck\", this, fuelItem);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tif (fuelItem == null || fuelItem.amount < 1)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelItemCheck",
      "HookName": "OnFuelItemCheck",
      "HookParameters": {
        "instance": "EntityFuelSystem",
        "fuelContainer": "StorageContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "GetFuelItem",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "public global::Item GetFuelItem()\r\n{\r\n\tglobal::StorageContainer fuelContainer = this.GetFuelContainer();\r\n\tobject returnvar = Interface.CallHook(\"OnFuelItemCheck\", this, fuelContainer);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tif (fuelContainer == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFuelCheck",
      "HookName": "OnFuelCheck",
      "HookParameters": {
        "instance": "EntityFuelSystem"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "HasFuel",
        "ReturnType": "bool",
        "Arguments": {
          "forceCheck": "bool"
        }
      },
      "CodeAfterInjection": "public bool HasFuel(bool forceCheck = false)\r\n{\r\n\tif (Time.time > this.nextFuelCheckTime | forceCheck)\r\n\t{\r\n\t\tobject returnvar = Interface.CallHook(\"OnFuelCheck\", this);\r\n\t\tif (returnvar is bool)\r\n\t\t{\r\n\t\t\treturn (bool)returnvar;\r\n\t\t}\r\n\t\tthis.cachedHasFuel = ((float)this.GetFuelAmount() > 0f);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanCheckFuel",
      "HookName": "CanCheckFuel",
      "HookParameters": {
        "instance": "EntityFuelSystem",
        "fuelContainer": "StorageContainer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "IsInFuelInteractionRange",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool IsInFuelInteractionRange(global::BasePlayer player)\r\n{\r\n\tglobal::StorageContainer fuelContainer = this.GetFuelContainer();\r\n\tobject returnvar = Interface.CallHook(\"CanCheckFuel\", this, fuelContainer, player);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (fuelContainer != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseFuel",
      "HookName": "CanUseFuel",
      "HookParameters": {
        "instance": "EntityFuelSystem",
        "fuelContainer": "StorageContainer",
        "seconds": "float",
        "fuelUsedPerSecond": "float"
      },
      "ReturnBehavior": 4,
      "TargetType": "EntityFuelSystem",
      "Category": "Fuel",
      "MethodData": {
        "MethodName": "TryUseFuel",
        "ReturnType": "int",
        "Arguments": {
          "seconds": "float",
          "fuelUsedPerSecond": "float"
        }
      },
      "CodeAfterInjection": "public int TryUseFuel(float seconds, float fuelUsedPerSecond)\r\n{\r\n\tglobal::StorageContainer fuelContainer = this.GetFuelContainer();\r\n\tobject returnvar = Interface.CallHook(\"CanUseFuel\", this, fuelContainer, seconds, fuelUsedPerSecond);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tif (fuelContainer == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlockTechTreeNode",
      "HookName": "CanUnlockTechTreeNode",
      "HookParameters": {
        "player": "BasePlayer",
        "node": "NodeInstance",
        "instance": "TechTreeData"
      },
      "ReturnBehavior": 1,
      "TargetType": "TechTreeData",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "PlayerCanUnlock",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "node": "TechTreeData/NodeInstance"
        }
      },
      "CodeAfterInjection": "public bool PlayerCanUnlock(global::BasePlayer player, global::TechTreeData.NodeInstance node)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlockTechTreeNode\", player, node, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.PlayerHasPathForUnlock(player, node) && !this.HasPlayerUnlocked(player, node);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlockTechTreeNodePath",
      "HookName": "CanUnlockTechTreeNodePath",
      "HookParameters": {
        "player": "BasePlayer",
        "node": "NodeInstance",
        "instance": "TechTreeData"
      },
      "ReturnBehavior": 1,
      "TargetType": "TechTreeData",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "PlayerHasPathForUnlock",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "node": "TechTreeData/NodeInstance"
        }
      },
      "CodeAfterInjection": "public bool PlayerHasPathForUnlock(global::BasePlayer player, global::TechTreeData.NodeInstance node)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlockTechTreeNodePath\", player, node, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::TechTreeData.NodeInstance entryNode = this.GetEntryNode();\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnIORefCleared [patch]",
      "HookName": "OnIORefCleared [patch]",
      "ReturnBehavior": 0,
      "TargetType": "IOEntity/IORef",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnIORefCleared",
      "HookName": "OnIORefCleared",
      "HookParameters": {
        "instance": "IORef",
        "OxideGen_0": "IOEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "IOEntity/IORef",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Clear",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void Clear()\r\n{\r\n\tglobal::IOEntity OxideGen_0 = this.ioEnt;\r\n\tthis.ioEnt = null;\r\n\tthis.entityRef.Set(null);\r\n\tInterface.CallHook(\"OnIORefCleared\", this, OxideGen_0);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTechTreeNodeUnlock",
      "HookName": "OnTechTreeNodeUnlock",
      "HookParameters": {
        "instance": "Workbench",
        "byID": "NodeInstance",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Workbench",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "RPC_TechTreeUnlock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tDebug.Log(\"Player unlocked group :\" + byID.groupName);\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (byID.itemDef != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnTechTreeNodeUnlock\", this, byID, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint num2;\r\n\t\t\tint num = global::Workbench.ScrapForResearch(byID.itemDef, techTreeForLevel.techTreeLevel, out num2);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTechTreeNodeUnlocked",
      "HookName": "OnTechTreeNodeUnlocked",
      "HookParameters": {
        "instance": "Workbench",
        "byID": "NodeInstance",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Workbench",
      "Category": "TechTree",
      "MethodData": {
        "MethodName": "RPC_TechTreeUnlock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tint itemid = global::ItemManager.FindItemDefinition(\"scrap\").itemid;\r\n\t\t\tif (player.inventory.GetAmount(itemid) >= num + num2)\r\n\t\t\t{\r\n\t\t\t\tplayer.inventory.Take(null, itemid, num + num2);\r\n\t\t\t\tplayer.blueprints.Unlock(byID.itemDef);\r\n\t\t\t\tInterface.CallHook(\"OnTechTreeNodeUnlocked\", this, byID, player);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnBlueprintLearned(player, byID.itemDef, \"techtree\", num + num2, this);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneAnswer",
      "HookName": "OnPhoneAnswer",
      "HookParameters": {
        "instance": "PhoneController",
        "activeCallTo": "PhoneController"
      },
      "ReturnBehavior": 4,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "AnswerPhone",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (this.activeCallTo == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (Interface.CallHook(\"OnPhoneAnswer\", this, this.activeCallTo) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.UpdateServerPlayer(player);\r\n\tthis.BeginCall();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneCallStart",
      "HookName": "OnPhoneCallStart",
      "HookParameters": {
        "instance": "PhoneController",
        "activeCallTo": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "BeginCall",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void BeginCall()\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneCallStart\", this, this.activeCallTo, this.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsMobile && this.activeCallTo != null && !this.activeCallTo.RequirePower)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneCallStarted",
      "HookName": "OnPhoneCallStarted",
      "HookParameters": {
        "instance": "PhoneController",
        "activeCallTo": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "BeginCall",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tthis.currentPlayer != null;\r\n\t}\r\n\tthis.SetPhoneStateWithPlayer(global::Telephone.CallState.InProcess);\r\n\tbase.Invoke(new Action(this.TimeOutCall), (float)global::TelephoneManager.MaxCallLength);\r\n\tInterface.CallHook(\"OnPhoneCallStarted\", this, this.activeCallTo, this.currentPlayer);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanReceiveCall",
      "HookName": "CanReceiveCall",
      "HookParameters": {
        "instance": "PhoneController"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "CanReceiveCall",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "private bool CanReceiveCall()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanReceiveCall\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn (!this.RequirePower || this.IsPowered()) && (!this.RequireParent || base.baseEntity.HasParent());\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDial",
      "HookName": "OnPhoneDial",
      "HookParameters": {
        "instance": "PhoneController",
        "telephone": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "CallPhone",
        "ReturnType": "void",
        "Arguments": {
          "number": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!(telephone != null))\r\n\t{\r\n\t\tthis.OnDialFailed(global::Telephone.DialFailReason.WrongNumber);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPhoneDial\", this, telephone, this.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (telephone.serverState == global::Telephone.CallState.Idle && telephone.CanReceiveCall())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDialFail",
      "HookName": "OnPhoneDialFail",
      "HookParameters": {
        "instance": "PhoneController",
        "reason": "DialFailReason",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "OnDialFailed",
        "ReturnType": "void",
        "Arguments": {
          "reason": "Telephone/DialFailReason"
        }
      },
      "CodeAfterInjection": "public void OnDialFailed(global::Telephone.DialFailReason reason)\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneDialFail\", this, reason, this.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetPhoneState(global::Telephone.CallState.Idle);\r\n\tbase.baseEntity.ClientRPC(global::RpcTarget.NetworkGroup(\"ClientOnDialFailed\"), (int)reason);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDialTimeout",
      "HookName": "OnPhoneDialTimeout",
      "HookParameters": {
        "activeCallTo": "PhoneController",
        "instance": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "TimeOutDialing",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void TimeOutDialing()\r\n{\r\n\tif (Interface.CallHook(\"OnPhoneDialTimeout\", this.activeCallTo, this, this.activeCallTo.currentPlayer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.activeCallTo != null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDialFailed",
      "HookName": "OnPhoneDialFailed",
      "HookParameters": {
        "instance": "PhoneController",
        "reason": "DialFailReason",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "OnDialFailed",
        "ReturnType": "void",
        "Arguments": {
          "reason": "Telephone/DialFailReason"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (base.IsInvoking(new Action(this.TimeOutDialing)))\r\n\t{\r\n\t\tbase.CancelInvoke(new Action(this.TimeOutDialing));\r\n\t}\r\n\tInterface.CallHook(\"OnPhoneDialFailed\", this, reason, this.currentPlayer);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneDialTimedOut",
      "HookName": "OnPhoneDialTimedOut",
      "HookParameters": {
        "activeCallTo": "PhoneController",
        "instance": "PhoneController",
        "currentPlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "TimeOutDialing",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (this.activeCallTo != null)\r\n\t{\r\n\t\tthis.activeCallTo.ServerPlayAnsweringMessage(this);\r\n\t}\r\n\tthis.SetPhoneState(global::Telephone.CallState.Idle);\r\n\tInterface.CallHook(\"OnPhoneDialTimedOut\", this.activeCallTo, this, this.activeCallTo.currentPlayer);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhoneAnswered",
      "HookName": "OnPhoneAnswered",
      "HookParameters": {
        "instance": "PhoneController",
        "activeCallTo": "PhoneController"
      },
      "ReturnBehavior": 0,
      "TargetType": "PhoneController",
      "Category": "Phone",
      "MethodData": {
        "MethodName": "AnswerPhone",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tthis.UpdateServerPlayer(player);\r\n\tthis.BeginCall();\r\n\tthis.activeCallTo.BeginCall();\r\n\tInterface.CallHook(\"OnPhoneAnswered\", this, this.activeCallTo);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryNetworkUpdate",
      "HookName": "OnInventoryNetworkUpdate",
      "HookParameters": {
        "instance": "PlayerInventory",
        "container": "ItemContainer",
        "updateItemContainer": "UpdateItemContainer",
        "type": "Type",
        "mode": "NetworkInventoryMode"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendUpdatedInventoryInternal",
        "ReturnType": "void",
        "Arguments": {
          "type": "PlayerInventory/Type",
          "container": "ItemContainer",
          "mode": "PlayerInventory/NetworkInventoryMode"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tcontainer.dirty = false;\r\n\t\t\tupdateItemContainer.container = Pool.Get<List<ProtoBuf.ItemContainer>>();\r\n\t\t\tbool bIncludeContainer = type != global::PlayerInventory.Type.Wear || mode == global::PlayerInventory.NetworkInventoryMode.LocalPlayer;\r\n\t\t\tupdateItemContainer.container.Add(container.Save(bIncludeContainer));\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnInventoryNetworkUpdate\", this, container, updateItemContainer, type, mode) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (mode == global::PlayerInventory.NetworkInventoryMode.Everyone)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnResearchCostDetermine [ItemDef]",
      "HookName": "OnResearchCostDetermine",
      "HookParameters": {
        "info": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "ResearchTable",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ScrapForResearch",
        "ReturnType": "int",
        "Arguments": {
          "info": "ItemDefinition"
        }
      },
      "CodeAfterInjection": "public static int ScrapForResearch(global::ItemDefinition info)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnResearchCostDetermine\", info);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tif (info.isRedirectOf != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityFlagsNetworkUpdate",
      "HookName": "OnEntityFlagsNetworkUpdate",
      "HookParameters": {
        "instance": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SendNetworkUpdate_Flags",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"SendNetworkUpdate_Flags\", 0))\r\n\t{\r\n\t\tbase.LogEntry(global::RustLog.EntryType.Network, 3, \"SendNetworkUpdate_Flags\");\r\n\t\tif (Interface.CallHook(\"OnEntityFlagsNetworkUpdate\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tList<Connection> subscribers = base.GetSubscribers();\r\n\t\tif (subscribers != null && subscribers.Count > 0)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootNetworkUpdate",
      "HookName": "OnLootNetworkUpdate",
      "HookParameters": {
        "instance": "PlayerLoot"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerLoot",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tthis.isInvokingSendUpdate = false;\r\n\tif (!base.baseEntity.IsValid())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLootNetworkUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (PlayerUpdateLoot playerUpdateLoot = Pool.Get<PlayerUpdateLoot>())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingTransaction",
      "HookName": "OnVendingTransaction",
      "HookParameters": {
        "instance": "VendingMachine",
        "buyer": "BasePlayer",
        "sellOrderId": "int",
        "numberOfTransactions": "int",
        "targetContainer": "ItemContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "DoTransaction",
        "ReturnType": "bool",
        "Arguments": {
          "buyer": "BasePlayer",
          "sellOrderId": "int",
          "numberOfTransactions": "int",
          "targetContainer": "ItemContainer",
          "onCurrencyRemoved": "System.Action`2<BasePlayer,Item>",
          "onItemPurchased": "System.Action`2<BasePlayer,Item>",
          "droneMarketTerminal": "MarketTerminal"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (targetContainer == null && Vector3.Distance(buyer.transform.position, base.transform.position) > 4f)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnVendingTransaction\", this, buyer, sellOrderId, numberOfTransactions, targetContainer);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tProtoBuf.VendingMachine.SellOrder sellOrder = this.sellOrders.sellOrders[sellOrderId];\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFindSpawnPoint",
      "HookName": "OnFindSpawnPoint",
      "HookParameters": {
        "forPlayer": "BasePlayer",
        "teamId": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "FindSpawnPoint",
        "ReturnType": "BasePlayer/SpawnPoint",
        "Arguments": {
          "forPlayer": "BasePlayer",
          "teamId": "ulong"
        }
      },
      "CodeAfterInjection": "public static global::BasePlayer.SpawnPoint FindSpawnPoint(global::BasePlayer forPlayer = null, ulong teamId = 0uL)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnFindSpawnPoint\", forPlayer, teamId);\r\n\tif (returnvar is global::BasePlayer.SpawnPoint)\r\n\t{\r\n\t\treturn (global::BasePlayer.SpawnPoint)returnvar;\r\n\t}\r\n\tbool flag = false;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLock [key]",
      "HookName": "CanLock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "KeyLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "KeyLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Lock",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (base.IsLocked())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLock\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.HasLockPermission(player))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlStarted",
      "HookName": "OnBookmarkControlStarted",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "text": "string",
        "remoteControllable": "IRemoteControllable"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tthis.SendControlBookmarks(player);\r\n\tif (GameInfo.HasAchievements && remoteControllable.GetEnt() is global::CCTV_RC)\r\n\t{\r\n\t\tbase.InvokeRepeating(new Action(this.CheckCCTVAchievement), 1f, 3f);\r\n\t}\r\n\tInterface.CallHook(\"OnBookmarkControlStarted\", this, player, text, remoteControllable);\r\n\tbase.InvokeRepeating(new Action(this.ControlCheck), 0f, 0f);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnded",
      "HookName": "OnBookmarkControlEnded",
      "HookParameters": {
        "instance": "ComputerStation",
        "ply": "BasePlayer",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "StopControl",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tthis.currentPlayerID = 0uL;\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, false, false, false);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tthis.SendControlBookmarks(ply);\r\n\tbase.CancelInvoke(new Action(this.ControlCheck));\r\n\tInterface.CallHook(\"OnBookmarkControlEnded\", this, ply, baseEntity);\r\n\tbase.CancelInvoke(new Action(this.CheckCCTVAchievement));\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnPlayerAddModifiers",
      "HookName": "OnPlayerAddModifiers",
      "ReturnBehavior": 0,
      "TargetType": "ItemModConsume",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DoAction",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tplayer.metabolism.ApplyChange(current.type, current.amount * num3 * num4, current.time * num3 * num4);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tplayer.ProcessMissionEvent(global::BaseMission.MissionEventType.CONSUME, item.info.itemid, 1f);\r\n\tif (player.modifiers != null && Interface.CallHook(\"OnPlayerAddModifiers\", player, item, consumable) == null)\r\n\t{\r\n\t\tplayer.modifiers.Add(consumable.modifiers, 1f, 1f);\r\n\t}\r\n\tif (this.product != null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoPlaneSignaled",
      "HookName": "OnCargoPlaneSignaled",
      "HookParameters": {
        "baseEntity": "BaseEntity",
        "instance": "SupplySignal"
      },
      "ReturnBehavior": 0,
      "TargetType": "SupplySignal",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tVector3 b = new Vector3(UnityEngine.Random.Range(-20f, 20f), 0f, UnityEngine.Random.Range(-20f, 20f));\r\n\t\tbaseEntity.SendMessage(\"InitDropPosition\", base.transform.position + b, SendMessageOptions.DontRequireReceiver);\r\n\t\tbaseEntity.Spawn();\r\n\t}\r\n\tInterface.CallHook(\"OnCargoPlaneSignaled\", baseEntity, this);\r\n\tbase.Invoke(new Action(this.FinishUp), 210f);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCargoPlaneSignaled [Patch]",
      "HookName": "OnCargoPlaneSignaled [Patch]",
      "ReturnBehavior": 0,
      "TargetType": "SupplySignal",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnSupplyDropDropped",
      "HookName": "OnSupplyDropDropped",
      "HookParameters": {
        "baseEntity": "BaseEntity",
        "instance": "CargoPlane"
      },
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tbaseEntity.globalBroadcast = true;\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnSupplyDropDropped\", baseEntity, this);\r\n\tbase.transform.position = Vector3.Lerp(this.startPos, this.endPos, num);\r\n\tbase.transform.hasChanged = true;\r\n\tif (num >= 1f)\r\n\t{\r\n\t\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 1]",
      "HookName": "OnSupplyDropDropped [patch 1]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 2]",
      "HookName": "OnSupplyDropDropped [patch 2]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "OnSupplyDropDropped [patch 3]",
      "HookName": "OnSupplyDropDropped [patch 3]",
      "ReturnBehavior": 0,
      "TargetType": "CargoPlane",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnBookmarkControlEnded [2]",
      "HookName": "OnBookmarkControlEnded",
      "HookParameters": {
        "instance": "ComputerStation",
        "player": "BasePlayer",
        "b": "IRemoteControllable"
      },
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tif (component != null)\r\n\t\t{\r\n\t\t\tcomponent.StopControl(new global::CameraViewerId(this.currentPlayerID, 0L));\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnBookmarkControlEnded\", this, player, component);\r\n\tplayer.net.SwitchSecondaryGroup(ent.net.group);\r\n\tplayer.SetRcEntityPosition(new Vector3?(ent.transform.position));\r\n\tthis.currentlyControllingEnt.uid = ent.net.ID;\r\n\tthis.currentPlayerID = player.userID;\r\n\tbool b = remoteControllable.InitializeControl(new global::CameraViewerId(this.currentPlayerID, 0L));\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBookmarkControlEnded [2] [patch]",
      "HookName": "OnBookmarkControlEnded [2] [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ComputerStation",
      "Category": "Bookmark",
      "MethodData": {
        "MethodName": "BeginControllingBookmark",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      }
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 1]",
      "HookName": "LimitNetworkingNoEffect [patch 1]",
      "ReturnBehavior": 0,
      "TargetType": "Effect/server",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ImpactEffect",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo",
          "customEffect": "string"
        }
      }
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 2]",
      "HookName": "LimitNetworkingNoEffect [patch 2]",
      "ReturnBehavior": 0,
      "TargetType": "BaseProjectile",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "CLProject",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      }
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingNoEffect [patch 3]",
      "HookName": "LimitNetworkingNoEffect [patch 3]",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnItemSubmit",
      "HookName": "OnItemSubmit",
      "HookParameters": {
        "slot": "Item",
        "instance": "Mailbox",
        "fromPlayer": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Mailbox",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SubmitInputItems",
        "ReturnType": "void",
        "Arguments": {
          "fromPlayer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tfor (int i = 0; i < this.InputContainer.capacity; i++)\r\n\t{\r\n\t\tglobal::Item slot = this.InputContainer.GetSlot(i);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemSubmit\", slot, this, fromPlayer) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (slot.MoveToContainer(base.inventory, -1, true, false, null, true))\r\n\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemStacked [1]",
      "HookName": "OnItemStacked",
      "HookParameters": {
        "slot2": "Item",
        "instance": "Item",
        "newcontainer": "ItemContainer",
        "num2": "int"
      },
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MoveToContainer",
        "ReturnType": "bool",
        "Arguments": {
          "newcontainer": "ItemContainer",
          "iTargetPos": "int",
          "allowStack": "bool",
          "ignoreStackLimit": "bool",
          "sourcePlayer": "BasePlayer",
          "allowSwap": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\texpr_2D1(slot2, num2);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis.amount -= num2;\r\n\t\t\t\t\t\t\tslot2.MarkDirty();\r\n\t\t\t\t\t\t\tInterface.CallHook(\"OnItemStacked\", slot2, this, newcontainer, num2);\r\n\t\t\t\t\t\t\tthis.MarkDirty();\r\n\t\t\t\t\t\t\tthis.MigrateItemOwnership(slot2, num2);\r\n\t\t\t\t\t\t\tif (this.amount <= 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tthis.RemoveFromWorld();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnThreatLevelUpdate",
      "HookName": "OnThreatLevelUpdate",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EnsureUpdated",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tthis.lastUpdateTime = Time.realtimeSinceStartup;\r\n\tthis.cachedThreatLevel = 0f;\r\n\tif (!this.IsSleeping())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnThreatLevelUpdate\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (this.inventory.containerWear.itemList.Count > 2)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWaterPurify",
      "HookName": "OnWaterPurify",
      "HookParameters": {
        "instance": "WaterPurifier",
        "timeCooked": "float"
      },
      "ReturnBehavior": 4,
      "TargetType": "WaterPurifier",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ConvertWater",
        "ReturnType": "void",
        "Arguments": {
          "timeCooked": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::Item slot = this.purifiedWaterStorage.inventory.GetSlot(0);\r\n\tif (this.stopWhenOutputFull && slot != null && slot.amount >= slot.MaxStackable())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnWaterPurify\", this, timeCooked) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = timeCooked * ((float)this.waterToProcessPerMinute / 60f);\r\n\tif (slot != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWaterPurified",
      "HookName": "OnWaterPurified",
      "HookParameters": {
        "instance": "WaterPurifier",
        "timeCooked": "float"
      },
      "ReturnBehavior": 0,
      "TargetType": "WaterPurifier",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ConvertWater",
        "ReturnType": "void",
        "Arguments": {
          "timeCooked": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tslot3.amount += num4;\r\n\t\t\tslot3.amount = Mathf.Clamp(slot3.amount, 0, this.purifiedWaterStorage.maxStackSize);\r\n\t\t\tthis.purifiedWaterStorage.inventory.MarkDirty();\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnWaterPurified\", this, timeCooked);\r\n\t\tthis.purifiedWaterStorage.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseGesture",
      "HookName": "CanUseGesture",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "GestureConfig"
      },
      "ReturnBehavior": 1,
      "TargetType": "GestureConfig",
      "Category": "Player",
      "MethodData": {
        "MethodName": "IsOwnedBy",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "allowCinematic": "bool"
        }
      },
      "CodeAfterInjection": "public bool IsOwnedBy(global::BasePlayer player, bool allowCinematic = false)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseGesture\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.forceUnlock)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientDisconnect",
      "HookName": "OnClientDisconnect",
      "HookParameters": {
        "connection": "Connection",
        "text": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ReadDisconnectReason",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tstring text = packet.read.String(4096, false);\r\n\tstring text2 = packet.connection.ToString();\r\n\tif (!string.IsNullOrEmpty(text) && !string.IsNullOrEmpty(text2))\r\n\t{\r\n\t\tInterface.CallHook(\"OnClientDisconnect\", packet.connection, text);\r\n\t\tDebugEx.Log(text2 + \" disconnecting: \" + text, StackTraceLogType.None);\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnIngredientsCollect",
      "HookName": "OnIngredientsCollect",
      "HookParameters": {
        "instance": "ItemCrafter",
        "bp": "ItemBlueprint",
        "task": "ItemCraftTask",
        "amount": "int",
        "player": "BasePlayer",
        "takeBroken": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CollectIngredients",
        "ReturnType": "void",
        "Arguments": {
          "bp": "ItemBlueprint",
          "task": "ItemCraftTask",
          "amount": "int",
          "player": "BasePlayer",
          "takeBroken": "bool"
        }
      },
      "CodeAfterInjection": "private void CollectIngredients(global::ItemBlueprint bp, global::ItemCraftTask task, int amount = 1, global::BasePlayer player = null, bool takeBroken = true)\r\n{\r\n\tif (Interface.CallHook(\"OnIngredientsCollect\", this, bp, task, amount, player, takeBroken) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tList<global::Item> list = new List<global::Item>();\r\n\tforeach (global::ItemAmount current in bp.GetIngredients())\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRespawnInformationGiven",
      "HookName": "OnRespawnInformationGiven",
      "HookParameters": {
        "instance": "BasePlayer",
        "list": "List`1"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendRespawnOptions",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tthis.<SendRespawnOptions>g__CollectExternalAndSend|508_0();\r\n\t\treturn;\r\n\t}\r\n\tList<RespawnInformation.SpawnOptions> list = Pool.Get<List<RespawnInformation.SpawnOptions>>();\r\n\tglobal::BasePlayer.GetRespawnOptionsForPlayer(list, this.userID);\r\n\tInterface.CallHook(\"OnRespawnInformationGiven\", this, list);\r\n\tthis.<SendRespawnOptions>g__SendToPlayer|508_1(list, false);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCentralizedBanCheck",
      "HookName": "OnCentralizedBanCheck",
      "ReturnBehavior": 0,
      "TargetType": "Auth_CentralizedBans/<Run>d__0",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "bool IEnumerator.MoveNext()\r\n{\r\n\tobject OxideGen_3 = Interface.CallHook(\"OnCentralizedBanCheck\", this.connection);\r\n\tif (OxideGen_3 != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tswitch (this.<>1__state)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientCommand",
      "HookName": "OnClientCommand",
      "HookParameters": {
        "connection": "Connection",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleNetwork",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientCommand",
        "ReturnType": "void",
        "Arguments": {
          "packet": "Network.Message"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (packet.connection == null || !packet.connection.connected)\r\n\t{\r\n\t\tDebug.LogWarning(\"Client without connection tried to run command: \" + text);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnClientCommand\", packet.connection, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text2 = ConsoleSystem.Run(ConsoleSystem.Option.Server.FromConnection(packet.connection).Quiet(), text, Array.Empty<object>());\r\n\tif (!string.IsNullOrEmpty(text2))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSleepingBagValidCheck",
      "HookName": "OnSleepingBagValidCheck",
      "HookParameters": {
        "instance": "SleepingBag",
        "playerID": "ulong",
        "ignoreTimers": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ValidForPlayer",
        "ReturnType": "bool",
        "Arguments": {
          "playerID": "ulong",
          "ignoreTimers": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool ValidForPlayer(ulong playerID, bool ignoreTimers)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnSleepingBagValidCheck\", this, playerID, ignoreTimers);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.deployerUserID == playerID && (ignoreTimers || this.unlockTime < Time.realtimeSinceStartup);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardAuthorize [ItemModDeployable]",
      "HookName": "OnCupboardAuthorize",
      "HookParameters": {
        "buildingPrivlidge": "BuildingPrivlidge",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemModDeployable",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "OnDeployed",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tplayer.GiveAchievement(this.UnlockAchievement, false);\r\n\t}\r\n\tglobal::BuildingPrivlidge buildingPrivlidge = ent as global::BuildingPrivlidge;\r\n\tif (buildingPrivlidge != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnCupboardAuthorize\", buildingPrivlidge, player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbuildingPrivlidge.AddPlayer(player, player.userID);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNpcTarget [AIBrainSenses]",
      "HookName": "OnNpcTarget",
      "ReturnBehavior": 0,
      "TargetType": "AIBrainSenses",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetNearest",
        "ReturnType": "BaseEntity",
        "Arguments": {
          "entities": "System.Collections.Generic.List`1<BaseEntity>",
          "rangeFraction": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tfloat num = float.PositiveInfinity;\r\n\tglobal::BaseEntity result = null;\r\n\tforeach (global::BaseEntity current in entities)\r\n\t{\r\n\t\tif (!(current == null) && current.Health() > 0f && Interface.CallHook(\"OnNpcTarget\", this.owner, current) == null)\r\n\t\t{\r\n\t\t\tfloat num2 = Vector3.Distance(current.transform.position, this.owner.transform.position);\r\n\t\t\tif (num2 <= rangeFraction * this.maxRange && num2 < num)\r\n\t\t\t{\r\n\t\t\t\tresult = current;\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "ContinueTargetScan [patch]",
      "HookName": "ContinueTargetScan [patch]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "LimitNetworkingAcquaintances [patch]",
      "HookName": "LimitNetworkingAcquaintances [patch]",
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "UpdateAcquaintancesFor",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "deltaSeconds": "float"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnWaterCollect [WaterCatcher]",
      "HookName": "OnWaterCollect",
      "HookParameters": {
        "instance": "WaterCatcher"
      },
      "ReturnBehavior": 1,
      "TargetType": "WaterCatcher",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CollectWater",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.IsFull())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnWaterCollect\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = this.collectionRates.baseRate;\r\n\tnum += global::Climate.GetFog(base.transform.position) * this.collectionRates.fogRate;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiquidVesselFill",
      "HookName": "OnLiquidVesselFill",
      "HookParameters": {
        "instance": "BaseLiquidVessel",
        "ownerPlayer": "BasePlayer",
        "facingLiquidContainer": "LiquidContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseLiquidVessel",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "FillCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tfloat f = (Time.realtimeSinceStartup - this.lastFillTime) * this.fillMlPerSec;\r\n\tVector3 pos = ownerPlayer.transform.position - new Vector3(0f, 1f, 0f);\r\n\tglobal::LiquidContainer facingLiquidContainer = this.GetFacingLiquidContainer();\r\n\tif (Interface.CallHook(\"OnLiquidVesselFill\", this, ownerPlayer, facingLiquidContainer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (facingLiquidContainer == null && this.CanFillFromWorld())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCCTVDirectionChange",
      "HookName": "OnCCTVDirectionChange",
      "HookParameters": {
        "instance": "CCTV_RC",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "CCTV_RC",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "Server_SetDir",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!player.CanBuild() || !player.IsBuildingAuthed())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCCTVDirectionChange\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 vector = Vector3Ex.Direction(player.eyes.position, this.yaw.transform.position);\r\n\tvector = base.transform.InverseTransformDirection(vector);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSetRelationship",
      "HookName": "CanSetRelationship",
      "HookParameters": {
        "player": "BasePlayer",
        "otherPlayer": "BasePlayer",
        "type": "RelationshipType",
        "weight": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SetRelationship",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "otherPlayer": "BasePlayer",
          "type": "RelationshipManager/RelationshipType",
          "weight": "int",
          "sendImmediate": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (otherPlayer != null && otherPlayer.IsNpc)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanSetRelationship\", player, otherPlayer, type, weight) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::RelationshipManager.PlayerRelationships playerRelationships = this.GetRelationships(num);\r\n\tif (!this.CleanupOldContacts(playerRelationships, num, global::RelationshipManager.RelationshipType.Acquaintance))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRecover",
      "HookName": "OnPlayerRecover",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RecoverFromWounded",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void RecoverFromWounded()\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerRecover\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsCrawling())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerWound",
      "HookName": "OnPlayerWound",
      "HookParameters": {
        "instance": "BasePlayer",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "BecomeWounded",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.IsWounded())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWound\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = info != null && info.damageTypes.GetMajorityDamageType() == Rust.DamageType.Fall;\r\n\tif (this.IsCrawling())\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerRecovered",
      "HookName": "OnPlayerRecovered",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RecoverFromWounded",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tthis.SetPlayerFlag(global::BasePlayer.PlayerFlags.Incapacitated, false);\r\n\tif (global::BaseGameMode.GetActiveGameMode(base.isServer))\r\n\t{\r\n\t\tglobal::BaseGameMode.GetActiveGameMode(base.isServer).OnPlayerRevived(null, this);\r\n\t}\r\n\tInterface.CallHook(\"OnPlayerRecovered\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDismountFailed",
      "HookName": "OnPlayerDismountFailed",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseMountable"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMountable",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_WantsDismount",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\npublic void RPC_WantsDismount(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!this.HasValidDismountPosition(player))\r\n\t{\r\n\t\tInterface.CallHook(\"OnPlayerDismountFailed\", player, this);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerWantsDismount\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAccessVendingMachine",
      "HookName": "CanAccessVendingMachine",
      "HookParameters": {
        "config": "DeliveryDroneConfig",
        "vendingMachine": "VendingMachine"
      },
      "ReturnBehavior": 1,
      "TargetType": "MarketTerminal",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "<GetDeliveryEligibleVendingMachines>g__IsEligible|42_0",
        "ReturnType": "bool",
        "Arguments": {
          "vendingMachine": "VendingMachine",
          "offset": "UnityEngine.Vector3",
          "n": "int"
        }
      },
      "CodeAfterInjection": "[CompilerGenerated]\r\nprivate bool <GetDeliveryEligibleVendingMachines>g__IsEligible|42_0(global::VendingMachine vendingMachine, Vector3 offset, int n)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanAccessVendingMachine\", this.config, vendingMachine);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tRaycastHit raycastHit;\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "ConsumptionAmountField [AutoTurret] [2]",
      "HookName": "ConsumptionAmountField [AutoTurret]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ConsumptionAmount",
        "ReturnType": "int",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "ConsumptionAmountField [AutoTurret]",
      "HookName": "ConsumptionAmountField [AutoTurret]",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": ".ctor",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnDecayHeal",
      "HookName": "OnDecayHeal",
      "HookParameters": {
        "instance": "DecayEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnDecay",
        "ReturnType": "void",
        "Arguments": {
          "decay": "Decay",
          "decayDeltaTime": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tif (this.upkeepTimer < 1f)\r\n\t\t{\r\n\t\t\tif (base.healthFraction < 1f && this.GetEntityHealScale() > 0f && base.SecondsSinceAttacked > 600f)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"OnDecayHeal\", this) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tfloat num2 = decayDeltaTime / this.GetEntityDecayDuration() * this.GetEntityHealScale();\r\n\t\t\t\tthis.Heal(this.MaxHealth() * num2);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDecayDamage",
      "HookName": "OnDecayDamage",
      "HookParameters": {
        "instance": "DecayEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnDecay",
        "ReturnType": "void",
        "Arguments": {
          "decay": "Decay",
          "decayDeltaTime": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t{\r\n\t\t\t\t\tnum3 -= decayPoint.protection;\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnDecayDamage\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (num3 > 0f)\r\n\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWindmillUpdate",
      "HookName": "OnWindmillUpdate",
      "HookParameters": {
        "instance": "ElectricWindmill"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElectricWindmill",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WindUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void WindUpdate()\r\n{\r\n\tif (Interface.CallHook(\"OnWindmillUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.serverWindSpeed = this.GetWindSpeedScale();\r\n\tif (!this.AmIVisible())\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWindmillUpdated",
      "HookName": "OnWindmillUpdated",
      "HookParameters": {
        "instance": "ElectricWindmill"
      },
      "ReturnBehavior": 0,
      "TargetType": "ElectricWindmill",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "WindUpdate",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (arg_55_0)\r\n\t{\r\n\t\tthis.MarkDirty();\r\n\t}\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnWindmillUpdated\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanElevatorLiftMove",
      "HookName": "CanElevatorLiftMove",
      "HookParameters": {
        "instance": "ElevatorLift"
      },
      "ReturnBehavior": 1,
      "TargetType": "ElevatorLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "CanMove",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool CanMove()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanElevatorLiftMove\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.VehicleTrigger.HasContents && this.VehicleTrigger.entityContents != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGrowableStateChange",
      "HookName": "OnGrowableStateChange",
      "HookParameters": {
        "instance": "GrowableEntity",
        "state": "State"
      },
      "ReturnBehavior": 1,
      "TargetType": "GrowableEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "ChangeState",
        "ReturnType": "void",
        "Arguments": {
          "state": "PlantProperties/State",
          "resetAge": "bool",
          "loading": "bool"
        }
      },
      "CodeAfterInjection": "private void ChangeState(global::PlantProperties.State state, bool resetAge, bool loading = false)\r\n{\r\n\tif (Interface.CallHook(\"OnGrowableStateChange\", this, state) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.isServer && this.State == state)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeRecycled",
      "HookName": "CanBeRecycled",
      "HookParameters": {
        "item": "Item",
        "instance": "Recycler"
      },
      "ReturnBehavior": 1,
      "TargetType": "Recycler",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CanBeRecycled",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item"
        }
      },
      "CodeAfterInjection": "private bool CanBeRecycled(global::Item item)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeRecycled\", item, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn item != null && item.info.Blueprint != null;\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBigWheelLoss",
      "HookName": "OnBigWheelLoss",
      "ReturnBehavior": 0,
      "TargetType": "BigWheelGame",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Payout",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tfor (int i = 0; i < 5; i++)\r\n\t\t\t{\r\n\t\t\t\tglobal::Item slot2 = current.inventory.GetSlot(i);\r\n\t\t\t\tif (slot2 != null && Interface.CallHook(\"OnBigWheelLoss\", this, slot2, current) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGamblingResult(current.lastPlayer, current, slot2.amount, 0, new Guid?(value));\r\n\t\t\t\t\tslot2.Remove(0f);\r\n\t\t\t\t\tflag2 = true;\r\n\t\t\t\t}\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBigWheelWin",
      "HookName": "OnBigWheelWin",
      "ReturnBehavior": 0,
      "TargetType": "BigWheelGame",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Payout",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\tglobal::Item slot = current.inventory.GetSlot((int)currentHitType.hitType);\r\n\t\t\tif (slot != null)\r\n\t\t\t{\r\n\t\t\t\tint num = currentHitType.ColorToMultiplier(currentHitType.hitType);\r\n\t\t\t\tint amount = slot.amount;\r\n\t\t\t\tif (Interface.CallHook(\"OnBigWheelWin\", this, slot, current, num) == null)\r\n\t\t\t\t{\r\n\t\t\t\t\tslot.amount += slot.amount * num;\r\n\t\t\t\t\tslot.RemoveFromContainer();\r\n\t\t\t\t\tslot.MoveToContainer(current.inventory, 5, true, false, null, true);\r\n\t\t\t\t\tflag = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityPickedUp",
      "HookName": "OnEntityPickedUp",
      "HookParameters": {
        "instance": "BaseCombatEntity",
        "createdItem": "Item",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseCombatEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnPickedUp",
        "ReturnType": "void",
        "Arguments": {
          "createdItem": "Item",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void OnPickedUp(global::Item createdItem, global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnEntityPickedUp\", this, createdItem, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerRestartInterrupt",
      "HookName": "OnServerRestartInterrupt",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "RestartServer",
        "ReturnType": "void",
        "Arguments": {
          "strNotice": "string",
          "iSeconds": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (SingletonComponent<global::ServerMgr>.Instance.restartCoroutine != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnServerRestartInterrupt\") != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::ServerMgr.ShowToastToAllClients(global::GameTip.Styles.Server_Event, global::ServerMgr.RESTART_INTERRUPTED_PHRASE, false, Array.Empty<string>());\r\n\t\tSingletonComponent<global::ServerMgr>.Instance.StopCoroutine(SingletonComponent<global::ServerMgr>.Instance.restartCoroutine);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerRestart",
      "HookName": "OnServerRestart",
      "HookParameters": {
        "strNotice": "string",
        "iSeconds": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "RestartServer",
        "ReturnType": "void",
        "Arguments": {
          "strNotice": "string",
          "iSeconds": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tglobal::ServerMgr.ShowToastToAllClients(global::GameTip.Styles.Server_Event, global::ServerMgr.RESTART_INTERRUPTED_PHRASE, false, Array.Empty<string>());\r\n\t\tSingletonComponent<global::ServerMgr>.Instance.StopCoroutine(SingletonComponent<global::ServerMgr>.Instance.restartCoroutine);\r\n\t\tSingletonComponent<global::ServerMgr>.Instance.restartCoroutine = null;\r\n\t}\r\n\tif (Interface.CallHook(\"OnServerRestart\", strNotice, iSeconds) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tSingletonComponent<global::ServerMgr>.Instance.restartCoroutine = SingletonComponent<global::ServerMgr>.Instance.ServerRestartWarning(strNotice, iSeconds);\r\n\tSingletonComponent<global::ServerMgr>.Instance.StartCoroutine(SingletonComponent<global::ServerMgr>.Instance.restartCoroutine);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseHelicopter",
      "HookName": "CanUseHelicopter",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CH47HelicopterAIController"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47HelicopterAIController",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "AttemptMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "doMountChecks": "bool"
        }
      },
      "CodeAfterInjection": "public override void AttemptMount(global::BasePlayer player, bool doMountChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanUseHelicopter\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!player.IsNpc && !player.IsAdmin)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "AllowNpcNonAdminHeliUse [patch]",
      "HookName": "AllowNpcNonAdminHeliUse [patch]",
      "ReturnBehavior": 0,
      "TargetType": "CH47HelicopterAIController",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "AttemptMount",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "doMountChecks": "bool"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnWildlifeTrap",
      "HookName": "OnWildlifeTrap",
      "HookParameters": {
        "instance": "WildlifeTrap",
        "trapped": "TrappableWildlife"
      },
      "ReturnBehavior": 1,
      "TargetType": "WildlifeTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "TrapWildlife",
        "ReturnType": "void",
        "Arguments": {
          "trapped": "TrappableWildlife"
        }
      },
      "CodeAfterInjection": "public void TrapWildlife(global::TrappableWildlife trapped)\r\n{\r\n\tif (Interface.CallHook(\"OnWildlifeTrap\", this, trapped) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Item item = global::ItemManager.Create(trapped.inventoryObject, UnityEngine.Random.Range(trapped.minToCatch, trapped.maxToCatch + 1), 0uL, true);\r\n\tif (base.LastLootedByPlayer != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFishingStopped",
      "HookName": "OnFishingStopped",
      "HookParameters": {
        "instance": "BaseFishingRod",
        "reason": "FailReason"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_Cancel",
        "ReturnType": "void",
        "Arguments": {
          "reason": "BaseFishingRod/FailReason"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (ownerPlayer != null)\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnFailedFish(ownerPlayer, reason);\r\n\t}\r\n\tInterface.CallHook(\"OnFishingStopped\", this, reason);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "CanCastFishingRod",
      "HookName": "CanCastFishingRod",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_RequestCast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.EvaluateFishingPosition(ref vector, ownerPlayer, out reason, out this.surfaceBody))\r\n\t{\r\n\t\tthis.FailedCast(reason);\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemModCompostable itemModCompostable = Interface.CallHook(\"CanCastFishingRod\", ownerPlayer, this, currentLure, vector);\r\n\tif (itemModCompostable is bool && !(bool)itemModCompostable)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::FishingBobber component = base.gameManager.CreateEntity(this.FishingBobberRef.resourcePath, base.transform.position + Vector3.up * 2.8f + ownerPlayer.eyes.BodyForward() * 1.8f, base.GetOwnerPlayer().ServerRotation, true).GetComponent<global::FishingBobber>();\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "CanCatchFish",
      "HookName": "CanCatchFish",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "CatchProcessBudgeted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tthis.CurrentState = global::BaseFishingRod.CatchState.Caught;\r\n\t\tif (this.currentFishTarget != null)\r\n\t\t{\r\n\t\t\tglobal::Item item = global::ItemManager.Create(this.currentFishTarget, 1, 0uL, true);\r\n\t\t\titem.SetItemOwnership(ownerPlayer, global::ItemOwnershipPhrases.Fishing);\r\n\t\t\tobject OxideGen_15 = Interface.CallHook(\"CanCatchFish\", ownerPlayer, this, item);\r\n\t\t\tif (OxideGen_15 is bool && !(bool)OxideGen_15)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\townerPlayer.GiveItem(item, global::BaseEntity.GiveItemReason.Crafted);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFishingRodCast",
      "HookName": "OnFishingRodCast",
      "HookParameters": {
        "instance": "BaseFishingRod",
        "ownerPlayer": "BasePlayer",
        "currentLure": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "Server_RequestCast",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer ownerPlayer2 = base.GetOwnerPlayer();\r\n\tif (ownerPlayer2 != null)\r\n\t{\r\n\t\tFacepunch.Rust.Analytics.Azure.OnStartFish(ownerPlayer2, currentLure, vector);\r\n\t}\r\n\tInterface.CallHook(\"OnFishingRodCast\", this, ownerPlayer, currentLure);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretAuthorize",
      "HookName": "OnTurretAuthorize",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "AddSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.AtMaxAuthCapacity())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretAuthorize\", this, player2) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.RemoveWhere((PlayerNameID x) => x.userid == player.userID);\r\n\tPlayerNameID playerNameID = new PlayerNameID();\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnFishCatch",
      "HookName": "OnFishCatch",
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "CatchProcessBudgeted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\tobject OxideGen_15 = Interface.CallHook(\"CanCatchFish\", ownerPlayer, this, item);\r\n\t\t\tif (OxideGen_15 is bool && !(bool)OxideGen_15)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tobject OxideGen_16 = Interface.CallHook(\"OnFishCatch\", item, this, ownerPlayer);\r\n\t\t\tif (OxideGen_16 is global::Item && OxideGen_16 as global::Item != item)\r\n\t\t\t{\r\n\t\t\t\titem.Remove(0f);\r\n\t\t\t\titem = (global::Item)OxideGen_16;\r\n\t\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFishCaught",
      "HookName": "OnFishCaught",
      "HookParameters": {
        "currentFishTarget": "ItemDefinition",
        "instance": "BaseFishingRod",
        "ownerPlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFishingRod",
      "Category": "Fishing",
      "MethodData": {
        "MethodName": "CatchProcessBudgeted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\townerPlayer.SignalBroadcast(global::BaseEntity.Signal.Alt_Attack, null);\r\n\t\tbase.Invoke(new Action(this.ResetLine), 6f);\r\n\t\tfishingBobber.Kill(global::BaseNetworkable.DestroyMode.None);\r\n\t\tthis.currentBobber.Set(null);\r\n\t\tbase.CancelInvoke(new Action(this.CatchProcess));\r\n\t\tInterface.CallHook(\"OnFishCaught\", this.currentFishTarget, this, ownerPlayer);\r\n\t\treturn;\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDrink",
      "HookName": "OnPlayerDrink",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "LiquidContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "LiquidContainer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SVDrink",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!rpc.player.metabolism.CanConsume())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerDrink\", rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (global::Item current in base.inventory.itemList)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanPurchaseItem",
      "HookName": "CanPurchaseItem",
      "HookParameters": {
        "buyer": "BasePlayer",
        "num7": "Item",
        "onItemPurchased": "Action`2",
        "instance": "VendingMachine",
        "targetContainer": "ItemContainer"
      },
      "ReturnBehavior": 4,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "DoTransaction",
        "ReturnType": "bool",
        "Arguments": {
          "buyer": "BasePlayer",
          "sellOrderId": "int",
          "numberOfTransactions": "int",
          "targetContainer": "ItemContainer",
          "onCurrencyRemoved": "System.Action`2<BasePlayer,Item>",
          "onItemPurchased": "System.Action`2<BasePlayer,Item>",
          "droneMarketTerminal": "MarketTerminal"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t\tDebug.LogError(\"Vending machine error, contact developers!\");\r\n\t\t\t\t\t}\r\n\t\t\t\t\telse\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tnum7 += item4.amount;\r\n\t\t\t\t\t\tobject returnvar2 = Interface.CallHook(\"CanPurchaseItem\", buyer, item4, onItemPurchased, this, targetContainer);\r\n\t\t\t\t\t\tif (returnvar2 != null)\r\n\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\treturn returnvar2 is bool && (bool)returnvar2;\r\n\t\t\t\t\t\t}\r\n\t\t\t\t\t\tthis.RecordSaleAnalytics(item4, sellOrderId, sellOrder.currencyAmountPerItem);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpen [NPCTalking]",
      "HookName": "OnVendingShopOpen",
      "HookParameters": {
        "itemDefinition": "InvisibleVendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCTalking",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "OnConversationAction",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "action": "string"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tglobal::InvisibleVendingMachine vendingMachine = base.GetVendingMachine();\r\n\t\tif (vendingMachine != null && Vector3.Distance(player.transform.position, base.transform.position) < 5f)\r\n\t\t{\r\n\t\t\tthis.ForceEndConversation(player);\r\n\t\t\tif (Interface.CallHook(\"OnVendingShopOpen\", vendingMachine, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvendingMachine.PlayerOpenLoot(player, \"vendingmachine.customer\", false);\r\n\t\t\treturn;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLootEntityEnd [FuseBox]",
      "HookName": "OnLootEntityEnd",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ItemBasedFlowRestrictor"
      },
      "ReturnBehavior": 0,
      "TargetType": "ItemBasedFlowRestrictor",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerStoppedLooting",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void PlayerStoppedLooting(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnLootEntityEnd\", player, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretAssign",
      "HookName": "OnTurretAssign",
      "HookParameters": {
        "instance": "AutoTurret",
        "num": "ulong",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tulong num = msg.read.UInt64();\r\n\tif (num == 0uL || this.IsAuthed(num))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTurretAssign\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring username = global::BasePlayer.SanitizePlayerNameString(msg.read.String(256, false), num);\r\n\tPlayerNameID playerNameID = new PlayerNameID();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretAssigned",
      "HookName": "OnTurretAssigned",
      "HookParameters": {
        "instance": "AutoTurret",
        "num": "ulong",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "AssignToFriend",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnEntityAuthChanged(this, arg_CC_1, arg_C1_0.Select(arg_C1_1), \"added\", num);\r\n\tthis.authorizedPlayers.Add(playerNameID);\r\n\tthis.UpdateMaxAuthCapacity();\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnTurretAssigned\", this, num, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionFailed",
      "HookName": "OnMissionFailed",
      "HookParameters": {
        "instance": "BaseMission",
        "missionInstance": "MissionInstance",
        "assignee": "BasePlayer",
        "failReason": "MissionFailReason"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionFailed",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer",
          "failReason": "BaseMission/MissionFailReason"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tglobal::BaseMission.DoMissionEffect(this.failedEffect.resourcePath, assignee);\r\n\tFacepunch.Rust.Analytics.Azure.OnMissionComplete(assignee, this, new global::BaseMission.MissionFailReason?(failReason));\r\n\tinstance.status = global::BaseMission.MissionStatus.Failed;\r\n\tthis.MissionEnded(instance, assignee);\r\n\tInterface.CallHook(\"OnMissionFailed\", this, instance, assignee, failReason);\r\n\tif (failReason == global::BaseMission.MissionFailReason.ResetPlayerState)\r\n\t{\r\n\t\tinstance.endTime = 0f;\r\n\t\tinstance.status = global::BaseMission.MissionStatus.Default;\r\n\t\tassignee.MissionDirty(true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionSucceeded",
      "HookName": "OnMissionSucceeded",
      "HookParameters": {
        "instance": "BaseMission",
        "missionInstance": "MissionInstance",
        "assignee": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionSuccess",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void MissionSuccess(global::BaseMission.MissionInstance instance, global::BasePlayer assignee)\r\n{\r\n\tinstance.status = global::BaseMission.MissionStatus.Accomplished;\r\n\tthis.MissionEnded(instance, assignee);\r\n\tthis.MissionComplete(instance, assignee);\r\n\tInterface.CallHook(\"OnMissionSucceeded\", this, instance, assignee);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionStart",
      "HookName": "OnMissionStart",
      "HookParameters": {
        "instance": "BaseMission",
        "missionInstance": "MissionInstance",
        "assignee": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionStart",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void MissionStart(global::BaseMission.MissionInstance instance, global::BasePlayer assignee)\r\n{\r\n\tif (Interface.CallHook(\"OnMissionStart\", this, instance, assignee) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i < this.objectives.Length; i++)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanAssignMission",
      "HookName": "CanAssignMission",
      "HookParameters": {
        "assignee": "BasePlayer",
        "mission": "BaseMission",
        "provider": "IMissionProvider"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "AssignMission",
        "ReturnType": "bool",
        "Arguments": {
          "assignee": "BasePlayer",
          "provider": "IMissionProvider",
          "mission": "BaseMission"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!mission.IsEligableForMission(assignee, provider))\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanAssignMission\", assignee, mission, provider);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tIReadOnlyList<global::BaseMission.MissionInstance> arg_62_0 = assignee.missions;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionAssigned",
      "HookName": "OnMissionAssigned",
      "HookParameters": {
        "mission": "BaseMission",
        "provider": "IMissionProvider",
        "assignee": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "AssignMission",
        "ReturnType": "bool",
        "Arguments": {
          "assignee": "BasePlayer",
          "provider": "IMissionProvider",
          "mission": "BaseMission"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tmissionInstance.objectiveStatuses[i] = new global::BaseMission.MissionInstance.ObjectiveStatus();\r\n\t}\r\n\tmission.MissionStart(missionInstance, assignee);\r\n\tassignee.SetActiveMission(activeMission);\r\n\tassignee.MissionDirty(true);\r\n\tInterface.CallHook(\"OnMissionAssigned\", mission, provider, assignee);\r\n\treturn true;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMissionStarted",
      "HookName": "OnMissionStarted",
      "HookParameters": {
        "instance": "BaseMission",
        "missionInstance": "MissionInstance",
        "assignee": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMission",
      "Category": "Mission",
      "MethodData": {
        "MethodName": "MissionStart",
        "ReturnType": "void",
        "Arguments": {
          "instance": "BaseMission/MissionInstance",
          "assignee": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.AllowedTutorialItems != global::BasePlayer.TutorialItemAllowance.None)\r\n\t{\r\n\t\tassignee.SetTutorialAllowance(this.AllowedTutorialItems);\r\n\t}\r\n\tInterface.CallHook(\"OnMissionStarted\", this, instance, assignee);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUpdateSign [CarvablePumpkin]",
      "HookName": "CanUpdateSign",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CarvablePumpkin"
      },
      "ReturnBehavior": 1,
      "TargetType": "CarvablePumpkin",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUpdateSign",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual bool CanUpdateSign(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUpdateSign\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.IsAdmin || player.IsDeveloper || (player.CanBuild() && (!base.IsLocked() || player.userID == base.OwnerID));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWaterCollect [WaterPump]",
      "HookName": "OnWaterCollect",
      "HookParameters": {
        "instance": "WaterPump",
        "itemDefinition": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "WaterPump",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CreateWater",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemDefinition itemDefinition = global::WaterResource.SV_GetAtPoint(this.WaterResourceLocation.position);\r\n\tif (itemDefinition != null)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnWaterCollect\", this, itemDefinition) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbase.inventory.AddItem(itemDefinition, this.AmountPerPump, 0uL, global::ItemContainer.LimitStack.Existing);\r\n\t\tbase.UpdateOnFlag();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFlameExplosion",
      "HookName": "OnFlameExplosion",
      "HookParameters": {
        "instance": "FlameExplosive",
        "component": "Collider"
      },
      "ReturnBehavior": 0,
      "TargetType": "FlameExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "FlameExplode",
        "ReturnType": "void",
        "Arguments": {
          "surfaceNormal": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tfloat y = UnityEngine.Random.Range(0f, 360f);\r\n\t\t\tQuaternion rotation = Quaternion.Euler(0f, y, 0f);\r\n\t\t\tbaseEntity.transform.SetPositionAndRotation(position, rotation);\r\n\t\t\tbaseEntity.creatorEntity = ((this.creatorEntity == null) ? baseEntity : this.creatorEntity);\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t\tInterface.CallHook(\"OnFlameExplosion\", this, component);\r\n\t\t\tVector3 vector = modifiedAimConeDirection.normalized * UnityEngine.Random.Range(this.minVelocity, this.maxVelocity) * this.velocityCurve.Evaluate(num2 * UnityEngine.Random.Range(1f, 1.1f));\r\n\t\t\tglobal::FireBall component2 = baseEntity.GetComponent<global::FireBall>();\r\n\t\t\tif (component2 != null)\r\n\t\t\t{\r\n\t\t\t\tcomponent2.SetDelayedVelocity(vector);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEyePosValidate",
      "HookName": "OnEyePosValidate",
      "HookParameters": {
        "instance": "AttackEntity",
        "player": "BasePlayer",
        "eyePos": "Vector3",
        "checkLineOfSight": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "AttackEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "ValidateEyePos",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "eyePos": "UnityEngine.Vector3",
          "checkLineOfSight": "bool"
        }
      },
      "CodeAfterInjection": "protected bool ValidateEyePos(global::BasePlayer player, Vector3 eyePos, bool checkLineOfSight = true)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnEyePosValidate\", this, player, eyePos, checkLineOfSight);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tbool flag = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnImpactEffectCreate",
      "HookName": "OnImpactEffectCreate",
      "HookParameters": {
        "info": "HitInfo",
        "customEffect": "string"
      },
      "ReturnBehavior": 4,
      "TargetType": "Effect/server",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "ImpactEffect",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo",
          "customEffect": "string"
        }
      },
      "CodeAfterInjection": "public static void ImpactEffect(global::HitInfo info, string customEffect = null)\r\n{\r\n\tif (Interface.CallHook(\"OnImpactEffectCreate\", info, customEffect) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!info.DoHitEffects)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSamSiteTargetScan",
      "HookName": "OnSamSiteTargetScan",
      "ReturnBehavior": 0,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TargetScan",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (this.IsDead())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tList<global::SamSite.ISamSiteTarget> list = Pool.Get<List<global::SamSite.ISamSiteTarget>>();\r\n\tif (Interface.CallHook(\"OnSamSiteTargetScan\", this, list) == null)\r\n\t{\r\n\t\tif (!this.IsInDefenderMode())\r\n\t\t{\r\n\t\t\tthis.AddTargetSet(list, global::SamSite.targetTypeVehicle.scanRadius);\r\n\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemUnwrap",
      "HookName": "OnItemUnwrap",
      "HookParameters": {
        "item": "Item",
        "player": "BasePlayer",
        "instance": "ItemModUnwrap"
      },
      "ReturnBehavior": 4,
      "TargetType": "ItemModUnwrap",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ServerCommand",
        "ReturnType": "void",
        "Arguments": {
          "item": "Item",
          "command": "string",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tif (item.amount <= 0)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnItemUnwrap\", item, player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\titem.UseItem(1);\r\n\t\tint num = UnityEngine.Random.Range(this.minTries, this.maxTries + 1);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnSendModelState",
      "HookName": "OnSendModelState",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendModelState",
        "ReturnType": "void",
        "Arguments": {
          "force": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tthis.modelState.mounted = this.isMounted;\r\n\tthis.modelState.ragdolling = this.IsRagdolling();\r\n\tthis.modelState.relaxed = this.IsRelaxed();\r\n\tthis.modelState.onPhone = (this.HasActiveTelephone && !this.activeTelephone.IsMobile);\r\n\tthis.modelState.crawling = this.IsCrawling();\r\n\tif (base.limitNetworking || Interface.CallHook(\"OnSendModelState\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.modelState.loading = this.IsLoadingAfterTransfer();\r\n\tbase.ClientRPC(global::RpcTarget.NetworkGroup(\"OnModelState\"), this.modelState);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStart",
      "HookName": "OnEngineStart",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "TryStartEngine",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.CanRunEngine())\r\n\t{\r\n\t\tthis.owner.OnEngineStartFailed();\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEngineStart\", this.owner, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.owner.SetFlag(this.engineStartingFlag, true, false, true);\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStarted",
      "HookName": "OnEngineStarted",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "TryStartEngine",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tthis.owner.SetFlag(this.engineStartingFlag, true, false, true);\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tthis.owner.Invoke(new Action(this.FinishStartingEngine), this.engineStartupTime);\r\n\tInterface.CallHook(\"OnEngineStarted\", this.owner, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStop",
      "HookName": "OnEngineStop",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.IsOff)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnEngineStop\", this.owner) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.CancelEngineStart();\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStopped",
      "HookName": "OnEngineStopped",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tthis.CancelEngineStart();\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tthis.owner.SetFlag(this.engineStartingFlag, false, false, true);\r\n\tInterface.CallHook(\"OnEngineStopped\", this.owner);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNpcTarget [HumanNPC]",
      "HookName": "OnNpcTarget",
      "ReturnBehavior": 0,
      "TargetType": "HumanNPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "GetBestTarget",
        "ReturnType": "BaseEntity",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tglobal::BaseEntity result = null;\r\n\tfloat num = -1f;\r\n\tforeach (global::BaseEntity current in this.Brain.Senses.Players)\r\n\t{\r\n\t\tif (!(current == null) && current.Health() > 0f && Interface.CallHook(\"OnNpcTarget\", this, current) == null)\r\n\t\t{\r\n\t\t\tfloat value = Vector3.Distance(current.transform.position, base.transform.position);\r\n\t\t\tfloat num2 = 1f - Mathf.InverseLerp(1f, this.Brain.SenseRange, value);\r\n\t\t\tfloat value2 = Vector3.Dot((current.transform.position - base.eyes.position).normalized, base.eyes.BodyForward());\r\n\t\t\tnum2 += Mathf.InverseLerp(this.Brain.VisionCone, 1f, value2) / 2f;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnXmasLootDistribute",
      "HookName": "OnXmasLootDistribute",
      "HookParameters": {
        "instance": "XMasRefill"
      },
      "ReturnBehavior": 1,
      "TargetType": "XMasRefill",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "ServerInit",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tthis.goodKids = ((global::BasePlayer.activePlayerList != null) ? new List<global::BasePlayer>(global::BasePlayer.activePlayerList) : new List<global::BasePlayer>());\r\n\tthis.stockings = ((global::Stocking.stockings != null) ? new List<global::Stocking>(global::Stocking.stockings.Values) : new List<global::Stocking>());\r\n\tbase.Invoke(new Action(this.RemoveMe), 60f);\r\n\tif (Interface.CallHook(\"OnXmasLootDistribute\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.InvokeRepeating(new Action(this.DistributeLoot), 3f, 0.02f);\r\n\tbase.Invoke(new Action(this.SendBells), 0.5f);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnXmasStockingFill",
      "HookName": "OnXmasStockingFill",
      "HookParameters": {
        "instance": "Stocking"
      },
      "ReturnBehavior": 1,
      "TargetType": "Stocking",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "SpawnLoot",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tDebug.Log(\"CONTACT DEVELOPERS! Stocking::PopulateLoot has null inventory!!! \" + base.name);\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsEmpty())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnXmasStockingFill\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbase.SpawnLoot();\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnXmasGiftsDistribute",
      "HookName": "OnXmasGiftsDistribute",
      "ReturnBehavior": 0,
      "TargetType": "XMasRefill",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "DistributeGiftsForPlayer",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool DistributeGiftsForPlayer(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnXmasGiftsDistribute\", this, player) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tint num = this.GiftsPerPlayer();\r\n\tint num2 = this.GiftSpawnAttempts();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBradleyApcThink",
      "HookName": "OnBradleyApcThink",
      "HookParameters": {
        "instance": "BradleyAPC"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "DoSimpleAI",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (base.isClient)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved5, TOD_Sky.Instance.IsNight, false, true);\r\n\tif (Interface.CallHook(\"OnBradleyApcThink\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!this.DoAI)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTerrainCreate",
      "HookName": "OnTerrainCreate",
      "HookParameters": {
        "instance": "TerrainGenerator"
      },
      "ReturnBehavior": 0,
      "TargetType": "TerrainGenerator",
      "Category": "World",
      "MethodData": {
        "MethodName": "CreateTerrain",
        "ReturnType": "UnityEngine.GameObject",
        "Arguments": {
          "heightmapResolution": "int",
          "alphamapResolution": "int"
        }
      },
      "CodeAfterInjection": "public GameObject CreateTerrain(int heightmapResolution, int alphamapResolution)\r\n{\r\n\tInterface.CallHook(\"OnTerrainCreate\", this);\r\n\tTerrain component = Terrain.CreateTerrainGameObject(new TerrainData\r\n\t{\r\n\t\tbaseMapResolution = global::TerrainGenerator.GetBaseMapRes(),\r\n\t\theightmapResolution = heightmapResolution,\r\n\t\talphamapResolution = alphamapResolution,\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerColliderEnable",
      "HookName": "OnPlayerColliderEnable",
      "HookParameters": {
        "instance": "BasePlayer",
        "playerCollider": "CapsuleCollider"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EnablePlayerCollider",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.playerCollider.enabled)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerColliderEnable\", this, this.playerCollider) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.RefreshColliderSize(true);\r\n\tthis.playerCollider.enabled = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerSleepEnded",
      "HookName": "OnPlayerSleepEnded",
      "HookParameters": {
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "EndSleeping",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tbase.ForceUpdateTriggers(true, true, true);\r\n\t}\r\n\tthis.inventory.containerMain.OnChanged();\r\n\tthis.inventory.containerBelt.OnChanged();\r\n\tthis.inventory.containerWear.OnChanged();\r\n\tInterface.CallHook(\"OnPlayerSleepEnded\", this);\r\n\tglobal::EACServer.LogPlayerSpawn(this);\r\n\tif (this.TotalPingCount > 0)\r\n\t{\r\n\t\tthis.SendPingsToClient();\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorSuppliesRequest",
      "HookName": "OnExcavatorSuppliesRequest",
      "HookParameters": {
        "instance": "ExcavatorSignalComputer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ExcavatorSignalComputer",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "RequestSupplies",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(5uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void RequestSupplies(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (base.HasFlag(global::BaseEntity.Flags.Reserved7) && this.IsPowered() && this.chargePower >= global::ExcavatorSignalComputer.chargeNeededForSupplies)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnExcavatorSuppliesRequest\", this, rpc.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.supplyPlanePrefab.resourcePath, default(Vector3), default(Quaternion), true);\r\n\t\tif (baseEntity)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnExcavatorSuppliesRequested",
      "HookName": "OnExcavatorSuppliesRequested",
      "HookParameters": {
        "instance": "ExcavatorSignalComputer",
        "player": "BasePlayer",
        "baseEntity": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "ExcavatorSignalComputer",
      "Category": "Electronic",
      "MethodData": {
        "MethodName": "RequestSupplies",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tVector3 position = this.dropPoints[UnityEngine.Random.Range(0, this.dropPoints.Length)].position;\r\n\t\t\tVector3 b = new Vector3(UnityEngine.Random.Range(-3f, 3f), 0f, UnityEngine.Random.Range(-3f, 3f));\r\n\t\t\tbaseEntity.SendMessage(\"InitDropPosition\", position + b, SendMessageOptions.DontRequireReceiver);\r\n\t\t\tbaseEntity.Spawn();\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnExcavatorSuppliesRequested\", this, rpc.player, baseEntity);\r\n\t\tthis.chargePower -= global::ExcavatorSignalComputer.chargeNeededForSupplies;\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved7, false, false, true);\r\n\t\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientProjectileEffectCreate",
      "HookName": "OnClientProjectileEffectCreate",
      "HookParameters": {
        "sourceConnection": "Connection",
        "instance": "BaseProjectile",
        "prefabName": "string"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseProjectile",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CreateProjectileEffectClientside",
        "ReturnType": "void",
        "Arguments": {
          "prefabName": "string",
          "pos": "UnityEngine.Vector3",
          "velocity": "UnityEngine.Vector3",
          "seed": "int",
          "sourceConnection": "Network.Connection",
          "silenced": "bool",
          "forceClientsideEffects": "bool",
          "targets": "System.Collections.Generic.List`1<Network.Connection>",
          "distanceOverride": "float"
        }
      },
      "CodeAfterInjection": "protected void CreateProjectileEffectClientside(string prefabName, Vector3 pos, Vector3 velocity, int seed, Connection sourceConnection, bool silenced = false, bool forceClientsideEffects = false, List<Connection> targets = null, float distanceOverride = 0f)\r\n{\r\n\tif (Interface.CallHook(\"OnClientProjectileEffectCreate\", sourceConnection, this, prefabName) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::Effect effect = global::BaseProjectile.reusableInstance;\r\n\teffect.Init(global::Effect.Type.Projectile, pos, velocity, sourceConnection);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDesignFirework",
      "HookName": "CanDesignFirework",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "PatternFirework"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "PlayerCanModify",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (player == null || !player.CanInteract())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanDesignFirework\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::BuildingPrivlidge buildingPrivilege = this.GetBuildingPrivilege();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkStarted",
      "HookName": "OnFireworkStarted",
      "HookParameters": {
        "instance": "BaseFirework"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "Begin",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void Begin()\r\n{\r\n\tbase.SetFlag(global::BaseEntity.Flags.OnFire, false, false, true);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, false);\r\n\tbase.SendNetworkUpdate_Flags();\r\n\tInterface.CallHook(\"OnFireworkStarted\", this);\r\n\tbase.Invoke(new Action(this.OnExhausted), this.activityLength);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkExhausted",
      "HookName": "OnFireworkExhausted",
      "HookParameters": {
        "instance": "BaseFirework"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "OnExhausted",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, true, false, false);\r\n\tbase.SetFlag(global::BaseEntity.Flags.OnFire, false, false, false);\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, false);\r\n\tbase.EnableGlobalBroadcast(false);\r\n\tbase.SendNetworkUpdate_Flags();\r\n\tInterface.CallHook(\"OnFireworkExhausted\", this);\r\n\tbase.Invoke(new Action(this.Cleanup), this.corpseDuration);\r\n\tglobal::BaseFirework._activeFireworks.Remove(this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDamage",
      "HookName": "OnFireworkDamage",
      "HookParameters": {
        "instance": "BaseFirework",
        "info": "HitInfo"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbase.OnAttacked(info);\r\n\tif (!base.isServer)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnFireworkDamage\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (info.damageTypes.Has(Rust.DamageType.Heat))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDesignChange",
      "HookName": "OnFireworkDesignChange",
      "HookParameters": {
        "instance": "PatternFirework",
        "design": "Design",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "ServerSetFireworkDesign",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.PlayerCanModify(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tProtoBuf.PatternFirework.Design design = rpc.read.Proto<ProtoBuf.PatternFirework.Design>(null);\r\n\tif (Interface.CallHook(\"OnFireworkDesignChange\", this, design, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (((design != null) ? design.stars : null) != null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFireworkDesignChanged",
      "HookName": "OnFireworkDesignChanged",
      "HookParameters": {
        "instance": "PatternFirework",
        "design": "Design",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "PatternFirework",
      "Category": "Firework",
      "MethodData": {
        "MethodName": "ServerSetFireworkDesign",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (expr_153 != null)\r\n\t{\r\n\t\texpr_153.Dispose();\r\n\t}\r\n\tthis.Design = design;\r\n\tInterface.CallHook(\"OnFireworkDesignChanged\", this, design, rpc.player);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnServerInformationUpdated",
      "HookName": "OnServerInformationUpdated",
      "HookParameters": {},
      "ReturnBehavior": 0,
      "TargetType": "ServerMgr",
      "Category": "Server",
      "MethodData": {
        "MethodName": "UpdateServerInformation",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tSteamServer.SetKey(\"fps\", global::Performance.report.frameRate.ToString());\r\n\t\tSteamServer.SetKey(\"fps_avg\", global::Performance.report.frameRateAverage.ToString(\"0.00\"));\r\n\t\tSteamServer.SetKey(\"ent_cnt\", global::BaseNetworkable.serverEntities.Count.ToString());\r\n\t\tSteamServer.SetKey(\"build\", BuildInfo.Current.Scm.ChangeId);\r\n\t}\r\n\tInterface.CallHook(\"OnServerInformationUpdated\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignUpdated [CarvablePumpkin]",
      "HookName": "OnSignUpdated",
      "HookParameters": {
        "instance": "CarvablePumpkin",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "CarvablePumpkin",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "UpdateSign",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tthis.textureIDs[num] = global::FileStorage.server.Store(array, global::FileStorage.Type.png, this.net.ID, (uint)num);\r\n\t}\r\n\tthis.LogEdit(msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n\tInterface.CallHook(\"OnSignUpdated\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsFire",
      "HookName": "OnMlrsFire",
      "HookParameters": {
        "instance": "MLRS",
        "owner": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Fire",
        "ReturnType": "void",
        "Arguments": {
          "owner": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.GetMounted() == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnMlrsFire\", this, owner) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved6, true, false, true);\r\n\tthis.radiusModIndex = 0;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsFired",
      "HookName": "OnMlrsFired",
      "HookParameters": {
        "instance": "MLRS",
        "owner": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "Fire",
        "ReturnType": "void",
        "Arguments": {
          "owner": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved6, true, false, true);\r\n\tthis.radiusModIndex = 0;\r\n\tthis.nextRocketIndex = Mathf.Min(this.RocketAmmoCount - 1, this.rocketTubes.Length - 1);\r\n\tthis.rocketOwnerRef.Set(owner);\r\n\tbase.InvokeRepeating(new Action(this.FireNextRocket), 0f, 0.5f);\r\n\tInterface.CallHook(\"OnMlrsFired\", this, owner);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsRocketFired",
      "HookName": "OnMlrsRocketFired",
      "HookParameters": {
        "instance": "MLRS",
        "serverProjectile": "ServerProjectile"
      },
      "ReturnBehavior": 0,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "FireNextRocket",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tVector3 aimToTarget = global::Ballistics.GetAimToTarget(this.firingPoint.position, target, this.rocketSpeed, this.vRotMax, this.rocketBaseGravity, this.minRange, out num);\r\n\tglobal::ServerProjectile serverProjectile;\r\n\tif (base.TryFireProjectile(rocketContainer, AmmoTypes.MLRS_ROCKET, firingPos, aimToTarget, this.rocketOwnerRef.Get(true) as global::BasePlayer, 0f, 0f, out serverProjectile))\r\n\t{\r\n\t\tserverProjectile.gravityModifier = num / -Physics.gravity.y;\r\n\t\tInterface.CallHook(\"OnMlrsRocketFired\", this, serverProjectile);\r\n\t\tthis.nextRocketIndex--;\r\n\t\treturn;\r\n\t}\r\n\tthis.EndFiring();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsFiringEnded",
      "HookName": "OnMlrsFiringEnded",
      "HookParameters": {
        "instance": "MLRS"
      },
      "ReturnBehavior": 0,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "EndFiring",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved6, false, false, false);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Broken, true, false, false);\r\n\tbase.SendNetworkUpdate_Flags();\r\n\tthis.timeSinceBroken = 0f;\r\n\tInterface.CallHook(\"OnMlrsFiringEnded\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsTarget",
      "HookName": "OnMlrsTarget",
      "HookParameters": {
        "instance": "MLRS",
        "worldPos": "Vector3",
        "_mounted": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetUserTargetHitPos",
        "ReturnType": "void",
        "Arguments": {
          "worldPos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tVector3 vector = position + global::TerrainMeta.Size;\r\n\t\tworldPos.x = Mathf.Clamp(worldPos.x, position.x, vector.x);\r\n\t\tworldPos.z = Mathf.Clamp(worldPos.z, position.z, vector.z);\r\n\t\tworldPos.y = this.GetSurfaceHeight(worldPos);\r\n\t}\r\n\tif (Interface.CallHook(\"OnMlrsTarget\", this, worldPos, this._mounted) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.UserTargetHitPos = worldPos;\r\n\tif (base.isServer)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMlrsTargetSet",
      "HookName": "OnMlrsTargetSet",
      "HookParameters": {
        "instance": "MLRS",
        "trueTargetHitPos": "Vector3",
        "_mounted": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "MLRS",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "SetUserTargetHitPos",
        "ReturnType": "void",
        "Arguments": {
          "worldPos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tthis.trueTargetHitPos.y = this.GetSurfaceHeight(this.trueTargetHitPos);\r\n\t\t\t\tbreak;\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnMlrsTargetSet\", this, this.trueTargetHitPos, this._mounted);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityReskin",
      "HookName": "OnEntityReskin",
      "HookParameters": {
        "baseEntity": "BaseEntity",
        "skin": "Skin",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "ChangeItemSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tglobal::ItemDefinition itemDefinition2 = null;\r\n\t\t\tulong skinID = global::ItemDefinition.FindSkin((itemDefinition.isRedirectOf != null) ? itemDefinition.isRedirectOf.itemid : itemDefinition.itemid, <>c__DisplayClass48_.targetSkin);\r\n\t\t\tglobal::ItemSkinDirectory.Skin skin = ((itemDefinition.isRedirectOf != null) ? itemDefinition.isRedirectOf : itemDefinition).skins.FirstOrDefault((global::ItemSkinDirectory.Skin x) => x.id == <>c__DisplayClass48_.targetSkin);\r\n\t\t\tif (Interface.CallHook(\"OnEntityReskin\", baseEntity, skin, msg.player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tif (skin.invItem != null)\r\n\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityReskinned",
      "HookName": "OnEntityReskinned",
      "HookParameters": {
        "baseEntity": "BaseEntity",
        "skin": "Skin",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "ChangeItemSkin",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tif (decayEntity3 != null && !flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tdecayEntity3.StopBeingDemolishable();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tInterface.CallHook(\"OnEntityReskinned\", baseEntity, skin, msg.player);\r\n\t\t\tbase.ClientRPC(global::RpcTarget.NetworkGroup(\"Client_ReskinResult\"), 1, baseEntity.net.ID);\r\n\t\t}\r\n\t}\r\n\tif (!base.UsingInfiniteAmmoCheat)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemStacked [2]",
      "HookName": "OnItemStacked",
      "HookParameters": {
        "entityOwner2": "Item",
        "instance": "Item",
        "newcontainer": "ItemContainer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Item",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MoveToContainer",
        "ReturnType": "bool",
        "Arguments": {
          "newcontainer": "ItemContainer",
          "iTargetPos": "int",
          "allowStack": "bool",
          "ignoreStackLimit": "bool",
          "sourcePlayer": "BasePlayer",
          "allowSwap": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\texpr_2D1(slot2, num2);\r\n\t\t\t\t\t\t\t}\r\n\t\t\t\t\t\t\tthis.amount -= num2;\r\n\t\t\t\t\t\t\tslot2.MarkDirty();\r\n\t\t\t\t\t\t\tInterface.CallHook(\"OnItemStacked\", slot2, this, newcontainer, num2);\r\n\t\t\t\t\t\t\tthis.MarkDirty();\r\n\t\t\t\t\t\t\tthis.MigrateItemOwnership(slot2, num2);\r\n\t\t\t\t\t\t\tif (this.amount <= 0)\r\n\t\t\t\t\t\t\t{\r\n\t\t\t\t\t\t\t\tthis.RemoveFromWorld();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConnectionDequeue",
      "HookName": "OnConnectionDequeue",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "RemoveConnection",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "public void RemoveConnection(Connection connection)\r\n{\r\n\tif (Interface.CallHook(\"OnConnectionDequeue\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.queue.Remove(connection))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConnectionQueue",
      "HookName": "OnConnectionQueue",
      "HookParameters": {
        "connection": "Connection"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "Join",
        "ReturnType": "void",
        "Arguments": {
          "connection": "Network.Connection"
        }
      },
      "CodeAfterInjection": "internal void Join(Connection connection)\r\n{\r\n\tif (Interface.CallHook(\"OnConnectionQueue\", connection) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.nextMessageTime = 0f;\r\n\tif ((this.Queued == 0 && !this.IsServerFull) || this.CanJumpQueue(connection))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQueueUpdate",
      "HookName": "OnQueueUpdate",
      "HookParameters": {
        "c": "Connection",
        "position": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "SendQueueUpdate",
        "ReturnType": "void",
        "Arguments": {
          "c": "Network.Connection",
          "position": "int"
        }
      },
      "CodeAfterInjection": "private void SendQueueUpdate(Connection c, int position)\r\n{\r\n\tif (Interface.CallHook(\"OnQueueUpdate\", c, position) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tNetWrite expr_1F = Net.sv.StartWrite();\r\n\texpr_1F.PacketID(Message.Type.QueueUpdate);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQueueCycle",
      "HookName": "OnQueueCycle",
      "HookParameters": {
        "availableSlots": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConnectionQueue",
      "Category": "Queue",
      "MethodData": {
        "MethodName": "Cycle",
        "ReturnType": "void",
        "Arguments": {
          "availableSlots": "int"
        }
      },
      "CodeAfterInjection": "public void Cycle(int availableSlots)\r\n{\r\n\tif (Interface.CallHook(\"OnQueueCycle\", availableSlots) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Time.realtimeSinceStartup > this.nextCleanupReservedSlots)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprinklerSplashed",
      "HookName": "OnSprinklerSplashed",
      "HookParameters": {
        "instance": "Sprinkler"
      },
      "ReturnBehavior": 0,
      "TargetType": "Sprinkler",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DoSplash",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tif (this.DecayPerSplash > 0f)\r\n\t\t{\r\n\t\t\tbase.Hurt(this.DecayPerSplash);\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnSprinklerSplashed\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanWaterBallSplash",
      "HookName": "CanWaterBallSplash",
      "HookParameters": {
        "liquidDef": "ItemDefinition",
        "position": "Vector3",
        "radius": "float",
        "amount": "int",
        "funWater": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "WaterBall",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DoSplash",
        "ReturnType": "bool",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "radius": "float",
          "liquidDef": "ItemDefinition",
          "amount": "int",
          "funWater": "bool"
        }
      },
      "CodeAfterInjection": "public static bool DoSplash(Vector3 position, float radius, global::ItemDefinition liquidDef, int amount, bool funWater = false)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanWaterBallSplash\", liquidDef, position, radius, amount, funWater);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tList<global::BaseEntity> list = Pool.Get<List<global::BaseEntity>>();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanFireLiquidWeapon",
      "HookName": "CanFireLiquidWeapon",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "LiquidWeapon"
      },
      "ReturnBehavior": 1,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "CanFire",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "private bool CanFire(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanFireLiquidWeapon\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.RequiresPumping && this.pressure < this.PressureLossPerTick)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiquidWeaponFired",
      "HookName": "OnLiquidWeaponFired",
      "HookParameters": {
        "instance": "LiquidWeapon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StartFiring",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tthis.StartCooldown(this.FireRate);\r\n\tif (base.isServer)\r\n\t{\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnLiquidWeaponFired\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLiquidWeaponFiringStopped",
      "HookName": "OnLiquidWeaponFiringStopped",
      "HookParameters": {
        "instance": "LiquidWeapon"
      },
      "ReturnBehavior": 0,
      "TargetType": "LiquidWeapon",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "StopFiring",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, false, false, true);\r\n\tif (base.isServer)\r\n\t{\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnLiquidWeaponFiringStopped\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhotoCapture",
      "HookName": "OnPhotoCapture",
      "HookParameters": {
        "photoEntity": "PhotoEntity",
        "item": "Item",
        "player": "BasePlayer",
        "array": "Byte[]"
      },
      "ReturnBehavior": 1,
      "TargetType": "InstantCameraTool",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TakePhoto",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\titem2.Remove(0f);\r\n\t\tDebug.LogError(\"Sub-entity is not a photo\");\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPhotoCapture\", photoEntity, item, player, array) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tphotoEntity.SetImageData(player.userID, array);\r\n\tif (!player.inventory.GiveItem(item2, null))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPhotoCaptured",
      "HookName": "OnPhotoCaptured",
      "HookParameters": {
        "photoEntity": "PhotoEntity",
        "item": "Item",
        "player": "BasePlayer",
        "array": "Byte[]"
      },
      "ReturnBehavior": 0,
      "TargetType": "InstantCameraTool",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "TakePhoto",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t}\r\n\t\t}\r\n\t\tPool.FreeUnmanaged<global::BasePlayer>(ref list);\r\n\t}\r\n\titem.LoseCondition(1f);\r\n\tInterface.CallHook(\"OnPhotoCaptured\", photoEntity, item, player, array);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDoorKnocked [DoorKnocker]",
      "HookName": "OnDoorKnocked",
      "HookParameters": {
        "instance": "DoorKnocker",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "DoorKnocker",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Knock",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void Knock(global::BasePlayer player)\r\n{\r\n\tbase.ClientRPC(global::RpcTarget.NetworkGroup(\"ClientKnock\"), player.transform.position);\r\n\tInterface.CallHook(\"OnDoorKnocked\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcTargetSense",
      "HookName": "OnNpcTargetSense",
      "HookParameters": {
        "owner": "BaseEntity",
        "ent": "BaseEntity",
        "brainSenses": "AIBrainSenses"
      },
      "ReturnBehavior": 1,
      "TargetType": "Rust.Ai.SimpleAIMemory",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "SetKnown",
        "ReturnType": "void",
        "Arguments": {
          "ent": "BaseEntity",
          "owner": "BaseEntity",
          "brainSenses": "AIBrainSenses"
        }
      },
      "CodeAfterInjection": "public void SetKnown(global::BaseEntity ent, global::BaseEntity owner, global::AIBrainSenses brainSenses)\r\n{\r\n\tif (Interface.CallHook(\"OnNpcTargetSense\", owner, ent, brainSenses) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::IAISenses iAISenses = owner as global::IAISenses;\r\n\tglobal::BasePlayer basePlayer = ent as global::BasePlayer;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTreeMarkerHit",
      "HookName": "OnTreeMarkerHit",
      "HookParameters": {
        "instance": "TreeEntity",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "TreeEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DidHitMarker",
        "ReturnType": "bool",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.xMarker == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnTreeMarkerHit\", this, info);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (global::PrefabAttribute.server.Find<global::TreeMarkerData>(this.prefabID) != null)\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnEngineStartFinished",
      "HookName": "OnEngineStartFinished",
      "ReturnBehavior": 0,
      "TargetType": "VehicleEngineController`1",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "FinishStartingEngine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.owner.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tthis.owner.SetFlag(this.engineStartingFlag, false, false, true);\r\n\tInterface.CallHook(\"OnEngineStartFinished\", this.owner);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNetworkSubscriptionsGather",
      "HookName": "OnNetworkSubscriptionsGather",
      "HookParameters": {
        "instance": "NetworkVisibilityGrid",
        "group": "Group",
        "groups": "ListHashSet`1",
        "radius": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "NetworkVisibilityGrid",
      "Category": "Network",
      "MethodData": {
        "MethodName": "GetVisibleFrom",
        "ReturnType": "void",
        "Arguments": {
          "group": "Network.Visibility.Group",
          "groups": "ListHashSet`1<Network.Visibility.Group>",
          "radius": "int"
        }
      },
      "CodeAfterInjection": "private void GetVisibleFrom(Group group, ListHashSet<Group> groups, int radius)\r\n{\r\n\tif (Interface.CallHook(\"OnNetworkSubscriptionsGather\", this, group, groups, radius) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::NetworkVisibilityGrid.<>c__DisplayClass37_0 <>c__DisplayClass37_;\r\n\t<>c__DisplayClass37_.groups = groups;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpened [VendingMachine]",
      "HookName": "OnVendingShopOpened",
      "HookParameters": {
        "instance": "VendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "VendingMachine",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "RPC_OpenShop",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (Interface.CallHook(\"OnVendingShopOpen\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.OpenShop(msg.player);\r\n\tInterface.CallHook(\"OnVendingShopOpened\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpened [NPCTalking]",
      "HookName": "OnVendingShopOpened",
      "HookParameters": {
        "itemDefinition": "InvisibleVendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "OnConversationAction",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "action": "string"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tif (Interface.CallHook(\"OnVendingShopOpen\", vendingMachine, player) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tvendingMachine.PlayerOpenLoot(player, \"vendingmachine.customer\", false);\r\n\t\t\tInterface.CallHook(\"OnVendingShopOpened\", vendingMachine, player);\r\n\t\t\treturn;\r\n\t\t}\r\n\t}\r\n\tglobal::ItemDefinition itemDefinition = global::ItemManager.FindItemDefinition(\"scrap\");\r\n\tglobal::NPCTalking.NPCConversationResultAction[] array = this.conversationResultActions;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAdventGiftAward",
      "HookName": "OnAdventGiftAward",
      "HookParameters": {
        "instance": "AdventCalendar",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "AwardGift",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void AwardGift(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnAdventGiftAward\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDateTime now = DateTime.Now;\r\n\tint num = ((global::AdventCalendar.overrideAdventCalendarDay > 0) ? global::AdventCalendar.overrideAdventCalendarDay : now.Day) - this.startDay;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAdventGiftAwarded",
      "HookName": "OnAdventGiftAwarded",
      "HookParameters": {
        "instance": "AdventCalendar",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "AwardGift",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tif (itemAmount.itemDef.IsAllowed(EraRestriction.Loot))\r\n\t\t{\r\n\t\t\tplayer.GiveItem(global::ItemManager.CreateByItemID(itemAmount.itemid, Mathf.CeilToInt(itemAmount.amount), 0uL).SetItemOwnership(player, global::ItemOwnershipPhrases.AdventCalendar), global::BaseEntity.GiveItemReason.PickedUp);\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnAdventGiftAwarded\", this, player);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "CanBeAwardedAdventGift",
      "HookName": "CanBeAwardedAdventGift",
      "ReturnBehavior": 0,
      "TargetType": "AdventCalendar",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "WasAwardedTodaysGift",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool WasAwardedTodaysGift(global::BasePlayer player)\r\n{\r\n\tobject OxideGen_2 = Interface.CallHook(\"CanBeAwardedAdventGift\", this, player);\r\n\tif (OxideGen_2 is bool)\r\n\t{\r\n\t\treturn !(bool)OxideGen_2;\r\n\t}\r\n\tif (!global::AdventCalendar.playerRewardHistory.ContainsKey(player.userID))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemPainted",
      "HookName": "OnItemPainted",
      "HookParameters": {
        "instance": "PaintedItemStorageEntity",
        "enumerator": "Item",
        "player": "BasePlayer",
        "current": "Byte[]"
      },
      "ReturnBehavior": 0,
      "TargetType": "PaintedItemStorageEntity",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Server_UpdateImage",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\titem.LoseCondition(0.25f);\r\n\t\t}\r\n\t\tthis.lastEditedBy = msg.player.userID;\r\n\t}\r\n\tInterface.CallHook(\"OnItemPainted\", this, item, msg.player, array);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemRecycleAmount",
      "HookName": "OnItemRecycleAmount",
      "HookParameters": {
        "slot": "Item",
        "num2": "int",
        "instance": "Recycler"
      },
      "ReturnBehavior": 3,
      "TargetType": "Recycler",
      "Category": "Item",
      "MethodData": {
        "MethodName": "RecycleThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tint num2 = 1;\r\n\t\t\t\tif (slot.amount > 1)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum2 = Mathf.CeilToInt(Mathf.Min((float)slot.amount, (float)slot.MaxStackable() * 0.1f));\r\n\t\t\t\t}\r\n\t\t\t\tobject returnvar = Interface.CallHook(\"OnItemRecycleAmount\", slot, num2, this);\r\n\t\t\t\tif (returnvar is int)\r\n\t\t\t\t{\r\n\t\t\t\t\tnum2 = (int)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tif (slot.info.Blueprint.scrapFromRecycle > 0)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTrainCarUncouple",
      "HookName": "OnTrainCarUncouple",
      "HookParameters": {
        "instance": "TrainCar",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "TrainCar",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_WantsUncouple",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (Vector3.SqrMagnitude(base.transform.position - player.transform.position) > 200f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnTrainCarUncouple\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool front = msg.read.Bit();\r\n\tthis.coupling.Uncouple(front);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanTrainCarCouple",
      "HookName": "CanTrainCarCouple",
      "HookParameters": {
        "owner": "TrainCar",
        "owner2": "TrainCar"
      },
      "ReturnBehavior": 1,
      "TargetType": "TrainCoupling",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "TryCouple",
        "ReturnType": "bool",
        "Arguments": {
          "theirCoupling": "TrainCoupling",
          "reflect": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.IsCoupled)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanTrainCarCouple\", this.owner, theirCoupling.owner);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (reflect && !theirCoupling.TryCouple(this, false))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSamSiteModeToggle",
      "HookName": "OnSamSiteModeToggle",
      "HookParameters": {
        "instance": "SamSite",
        "player": "BasePlayer",
        "flag": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "SamSite",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "ToggleDefenderMode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tbool flag = msg.read.Bit();\r\n\tif (flag == this.IsInDefenderMode())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSamSiteModeToggle\", this, player, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag(this.Flag_ManuallySetMode, flag, false, true);\r\n\tbase.SetFlag(this.Flag_TargetMode, flag, false, true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprayCreate",
      "HookName": "OnSprayCreate",
      "HookParameters": {
        "instance": "SprayCan",
        "vector": "Vector3",
        "quaternion": "Quaternion"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCan",
      "Category": "Crafting",
      "MethodData": {
        "MethodName": "CreateSpray",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (num != 0 && !flag && !msg.player.blueprints.CheckSkinOwnership(num, msg.player.userID))\r\n\t{\r\n\t\tDebug.Log(string.Format(\"SprayCan.ChangeItemSkin player does not have item :{0}:\", num));\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSprayCreate\", this, vector, quaternion) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong skinID = global::ItemDefinition.FindSkin(this.SprayDecalItem.itemid, num);\r\n\tglobal::BaseEntity expr_169 = global::GameManager.server.CreateEntity(this.SprayDecalEntityRef.resourcePath, vector, quaternion, true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLockerSwap",
      "HookName": "OnLockerSwap",
      "HookParameters": {
        "instance": "Locker",
        "num": "int",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Locker",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_Equip",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tint num = msg.read.Int32();\r\n\tif (num < 0 || num >= 3)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLockerSwap\", this, num, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.IsEquipping())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWeaponModChange",
      "HookName": "OnWeaponModChange",
      "HookParameters": {
        "instance": "BaseProjectile",
        "GetOwnerPlayer()": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "DelayedModsChanged",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void DelayedModsChanged()\r\n{\r\n\tif (Interface.CallHook(\"OnWeaponModChange\", this, this.GetOwnerPlayer()) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFunc<global::ProjectileWeaponMod, global::ProjectileWeaponMod.Modifier> arg_5A_1;\r\n\tif ((arg_5A_1 = global::BaseProjectile.<>c.<>9__96_0) == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSprayRemove",
      "HookName": "OnSprayRemove",
      "HookParameters": {
        "instance": "SprayCanSpray",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "SprayCanSpray",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Server_RequestWaterClear",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.Menu_WaterClear_ShowIf(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSprayRemove\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n}\r\n"
    },
    {
      "Type": 1,
      "Name": "SplashThresholdField [SprayCanSpray]",
      "HookName": "SplashThresholdField [SprayCanSpray]",
      "ReturnBehavior": 0,
      "TargetType": "SprayCanSpray",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "WantsSplash",
        "ReturnType": "bool",
        "Arguments": {
          "splashType": "ItemDefinition",
          "amount": "int"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnComposterUpdate",
      "HookName": "OnComposterUpdate",
      "HookParameters": {
        "instance": "Composter"
      },
      "ReturnBehavior": 1,
      "TargetType": "Composter",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateComposting",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void UpdateComposting()\r\n{\r\n\tif (Interface.CallHook(\"OnComposterUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfor (int i = 0; i < base.inventory.capacity; i++)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemsCount",
      "HookName": "OnInventoryItemsCount",
      "HookParameters": {
        "instance": "PlayerInventory",
        "itemid": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmount",
        "ReturnType": "int",
        "Arguments": {
          "itemid": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (itemid == 0)\r\n\t{\r\n\t\treturn 0;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryItemsCount\", this, itemid);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tint num = 0;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemsTake",
      "HookName": "OnInventoryItemsTake",
      "HookParameters": {
        "instance": "PlayerInventory",
        "collect": "List`1",
        "itemid": "int",
        "amount": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "Take",
        "ReturnType": "int",
        "Arguments": {
          "collect": "System.Collections.Generic.List`1<Item>",
          "itemid": "int",
          "amount": "int"
        }
      },
      "CodeAfterInjection": "public int Take(List<global::Item> collect, int itemid, int amount)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryItemsTake\", this, collect, itemid, amount);\r\n\tif (returnvar is int)\r\n\t{\r\n\t\treturn (int)returnvar;\r\n\t}\r\n\tint num = 0;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemsFind",
      "HookName": "OnInventoryItemsFind",
      "HookParameters": {
        "instance": "PlayerInventory",
        "id": "int",
        "list": "List`1"
      },
      "ReturnBehavior": 4,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindItemsByItemID",
        "ReturnType": "void",
        "Arguments": {
          "list": "System.Collections.Generic.List`1<Item>",
          "id": "int"
        }
      },
      "CodeAfterInjection": "public void FindItemsByItemID(List<global::Item> list, int id)\r\n{\r\n\tif (Interface.CallHook(\"OnInventoryItemsFind\", this, id, list) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.containerMain != null)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoFind",
      "HookName": "OnInventoryAmmoFind",
      "HookParameters": {
        "instance": "PlayerInventory",
        "list": "List`1",
        "ammoType": "AmmoTypes"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindAmmo",
        "ReturnType": "void",
        "Arguments": {
          "list": "System.Collections.Generic.List`1<Item>",
          "ammoType": "Rust.AmmoTypes"
        }
      },
      "CodeAfterInjection": "public void FindAmmo(List<global::Item> list, AmmoTypes ammoType)\r\n{\r\n\tif (Interface.CallHook(\"OnInventoryAmmoFind\", this, list, ammoType) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemContainer expr_1C = this.containerMain;\r\n\tif (expr_1C != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBackpackDrop",
      "HookName": "OnBackpackDrop",
      "HookParameters": {
        "anyBackpack": "Item",
        "instance": "PlayerInventory"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "TryDropBackpack",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void TryDropBackpack()\r\n{\r\n\tglobal::Item anyBackpack = this.GetAnyBackpack();\r\n\tif (anyBackpack != null && base.baseEntity.isServer)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnBackpackDrop\", anyBackpack, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tanyBackpack.Drop(base.baseEntity.GetDropPosition(), base.baseEntity.GetDropVelocity(), default(Quaternion));\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDroppedItemCombined",
      "HookName": "OnDroppedItemCombined",
      "HookParameters": {
        "instance": "DroppedItem"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "OnDroppedOn",
        "ReturnType": "void",
        "Arguments": {
          "di": "DroppedItem"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (di.DropReason == global::DroppedItem.DropReasonEnum.Player)\r\n\t{\r\n\t\tthis.DropReason = global::DroppedItem.DropReasonEnum.Player;\r\n\t}\r\n\tInterface.CallHook(\"OnDroppedItemCombined\", this);\r\n\tdi.item.MigrateItemOwnership(this.item, di.item.amount);\r\n\tdi.DestroyItem();\r\n\tdi.Kill(global::BaseNetworkable.DestroyMode.None);\r\n\tint arg_29E_0 = this.item.info.GetWorldModelIndex(this.item.amount);\r\n\tthis.item.amount = num2;\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRandomItemAward",
      "HookName": "OnRandomItemAward",
      "ReturnBehavior": 0,
      "TargetType": "RandomItemDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "TryAward",
        "ReturnType": "bool",
        "Arguments": {
          "itemChance": "RandomItemDispenser/RandomItemChance",
          "forPlayer": "BasePlayer",
          "distributorPosition": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "private bool TryAward(global::RandomItemDispenser.RandomItemChance itemChance, global::BasePlayer forPlayer, Vector3 distributorPosition)\r\n{\r\n\tif (Interface.CallHook(\"OnRandomItemAward\", this, itemChance, forPlayer, distributorPosition) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tfloat num = UnityEngine.Random.Range(0f, 1f);\r\n\tif (itemChance.Chance >= num)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRemoteIdentifierUpdate",
      "HookName": "OnRemoteIdentifierUpdate",
      "HookParameters": {
        "instance": "PoweredRemoteControlEntity",
        "newID": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "PoweredRemoteControlEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "UpdateIdentifier",
        "ReturnType": "void",
        "Arguments": {
          "newID": "string",
          "clientSend": "bool"
        }
      },
      "CodeAfterInjection": "public void UpdateIdentifier(string newID, bool clientSend = false)\r\n{\r\n\tif (Interface.CallHook(\"OnRemoteIdentifierUpdate\", this, newID) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring arg_16_0 = this.rcIdentifier;\r\n\tif (base.isServer)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenStart",
      "HookName": "OnOvenStart",
      "HookParameters": {
        "instance": "BaseOven"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartCooking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual void StartCooking()\r\n{\r\n\tif (Interface.CallHook(\"OnOvenStart\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.FindBurnable() == null && !this.CanRunWithNoFuel)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenStarted",
      "HookName": "OnOvenStarted",
      "HookParameters": {
        "instance": "BaseOven"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartCooking",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (this.visualFood)\r\n\t{\r\n\t\tbase.InvokeRepeating(new Action(this.CookVisuals), 0f, 0.05f);\r\n\t}\r\n\tbase.SetFlag(global::BaseEntity.Flags.On, true, false, true);\r\n\tInterface.CallHook(\"OnOvenStarted\", this);\r\n\tif (this.hasOpenFlame)\r\n\t{\r\n\t\tSingletonComponent<global::NpcFireManager>.Instance.Add(this);\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerBanned [EAC]",
      "HookName": "OnPlayerBanned",
      "HookParameters": {
        "connection": "Connection",
        "ToString()": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "EACServer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientActionRequired",
        "ReturnType": "void",
        "Arguments": {
          "data": "Epic.OnlineServices.AntiCheatCommon.OnClientActionRequiredCallbackInfo&"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\t2,\r\n\t\t\t\t\t\t0,\r\n\t\t\t\t\t\t\"<color=#fff>SERVER</color> Kicking \" + connection.username + \" (banned by anticheat)\"\r\n\t\t\t\t\t});\r\n\t\t\t\t\tInterface.CallHook(\"OnPlayerBanned\", connection, actionReasonDetailsString.ToString());\r\n\t\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned)\r\n\t\t\t\t\t{\r\n\t\t\t\t\t\tConVar.Entity.DeleteBy(connection.userid);\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerKicked [EAC]",
      "HookName": "OnPlayerKicked",
      "HookParameters": {
        "connection": "Connection",
        "ToString()": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "EACServer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnClientActionRequired",
        "ReturnType": "void",
        "Arguments": {
          "data": "Epic.OnlineServices.AntiCheatCommon.OnClientActionRequiredCallbackInfo&"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\telse\r\n\t\t\t{\r\n\t\t\t\tDebug.Log(string.Format(\"[EAC] Kicking {0} / {1} ({2})\", connection.userid, connection.username, actionReasonDetailsString));\r\n\t\t\t\tconnection.authStatusEAC = \"eac\";\r\n\t\t\t\tNetwork.Net.sv.Kick(connection, \"EAC: \" + actionReasonDetailsString, false);\r\n\t\t\t\tInterface.CallHook(\"OnPlayerKicked\", connection, actionReasonDetailsString.ToString());\r\n\t\t\t\tif (data.ActionReasonCode == AntiCheatCommonClientActionReason.PermanentBanned || data.ActionReasonCode == AntiCheatCommonClientActionReason.TemporaryBanned)\r\n\t\t\t\t{\r\n\t\t\t\t\tconnection.authStatusEAC = \"eacbanned\";\r\n\t\t\t\t\tglobal::ConsoleNetwork.BroadcastToAllClients(\"chat.add\", new object[]\r\n\t\t\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnOvenTemperature",
      "HookName": "OnOvenTemperature",
      "HookParameters": {
        "instance": "BaseOven",
        "slot": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseOven",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "GetTemperature",
        "ReturnType": "float",
        "Arguments": {
          "slot": "int"
        }
      },
      "CodeAfterInjection": "public float GetTemperature(int slot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnOvenTemperature\", this, slot);\r\n\tif (returnvar is float)\r\n\t{\r\n\t\treturn (float)returnvar;\r\n\t}\r\n\tif (!base.HasFlag(global::BaseEntity.Flags.On))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBuildingMerge",
      "HookName": "OnBuildingMerge",
      "HookParameters": {
        "instance": "ServerBuildingManager",
        "building1": "Building",
        "building2": "Building"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerBuildingManager",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Merge",
        "ReturnType": "void",
        "Arguments": {
          "building1": "BuildingManager/Building",
          "building2": "BuildingManager/Building"
        }
      },
      "CodeAfterInjection": "private void Merge(global::BuildingManager.Building building1, global::BuildingManager.Building building2)\r\n{\r\n\tInterface.CallHook(\"OnBuildingMerge\", this, building1, building2);\r\n\twhile (building2.HasDecayEntities())\r\n\t{\r\n\t\tbuilding2.decayEntities[0].AttachToBuilding(building1.ID);\r\n\t}\r\n\tif (ConVar.AI.nav_carve_use_building_optimization)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPortalUse",
      "HookName": "OnPortalUse",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BasePortal"
      },
      "ReturnBehavior": 4,
      "TargetType": "BasePortal",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UsePortal",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void UsePortal(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnPortalUse\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.LinkPortal();\r\n\tif (this.targetPortal != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPortalUsed",
      "HookName": "OnPortalUsed",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BasePortal"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePortal",
      "Category": "Player",
      "MethodData": {
        "MethodName": "UsePortal",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tglobal::Effect.server.Run(this.transitionSoundEffect.resourcePath, this.targetPortal.relativeAnchor.transform.position, Vector3.up, null, false, null);\r\n\t\t}\r\n\t\tplayer.UpdateNetworkGroup();\r\n\t\tplayer.SetPlayerFlag(global::BasePlayer.PlayerFlags.ReceivingSnapshot, true);\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t\tInterface.CallHook(\"OnPortalUsed\", player, this);\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(\"No portal...\");\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemDespawn",
      "HookName": "OnItemDespawn",
      "HookParameters": {
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "DroppedItem",
      "Category": "Item",
      "MethodData": {
        "MethodName": "IdleDestroy",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void IdleDestroy()\r\n{\r\n\tInterface.CallHook(\"OnItemDespawn\", this.item);\r\n\tFacepunch.Rust.Analytics.Azure.OnItemDespawn(this, this.item, (int)this.DropReason, this.DroppedBy);\r\n\tif (this.item != null)\r\n\t{\r\n\t\tglobal::BuriedItems.Instance.Register(this.item, base.transform.position);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUnlock [ModularCarCodeLock]",
      "HookName": "CanUnlock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ModularCarCodeLock",
        "codeEntered": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarCodeLock",
      "Category": "Player",
      "MethodData": {
        "MethodName": "TryOpenWithCode",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "codeEntered": "string"
        }
      },
      "CodeAfterInjection": "public bool TryOpenWithCode(global::BasePlayer player, string codeEntered)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUnlock\", player, this, codeEntered);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (this.CodeEntryBlocked(player))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleLockRequest",
      "HookName": "OnVehicleLockRequest",
      "HookParameters": {
        "instance": "ModularCarGarage",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_RequestAddLock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String(256, false);\r\n\tif (Interface.CallHook(\"OnVehicleLockRequest\", this, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemAmount itemAmount = this.lockResourceCost;\r\n\tif ((float)player.inventory.GetAmount(itemAmount.itemDef.itemid) >= itemAmount.amount && this.carOccupant.CarLock.TryAddALock(text, player.userID))\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "CanLootEntity [IndustrialCrafter]",
      "HookName": "CanLootEntity",
      "ReturnBehavior": 0,
      "TargetType": "IndustrialCrafter",
      "Category": "Player",
      "MethodData": {
        "MethodName": "PlayerOpenLoot",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "panelToOpen": "string",
          "doPositionChecks": "bool"
        }
      },
      "CodeAfterInjection": "public virtual bool PlayerOpenLoot(global::BasePlayer player, string panelToOpen = \"\", bool doPositionChecks = true)\r\n{\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tif (this.NeedsBuildingPrivilegeToUse && !player.CanBuild())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnConveyorFiltersChange",
      "HookName": "OnConveyorFiltersChange",
      "HookParameters": {
        "instance": "IndustrialConveyor",
        "player": "BasePlayer",
        "itemFilterList": "ItemFilterList"
      },
      "ReturnBehavior": 4,
      "TargetType": "IndustrialConveyor",
      "Category": "Industrial",
      "MethodData": {
        "MethodName": "RPC_ChangeFilters",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tthis.filterItems.Clear();\r\n\tusing (ProtoBuf.IndustrialConveyor.ItemFilterList itemFilterList = msg.read.Proto<ProtoBuf.IndustrialConveyor.ItemFilterList>(null))\r\n\t{\r\n\t\tif (itemFilterList.filters != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnConveyorFiltersChange\", this, msg.player, itemFilterList) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tint num = Mathf.Min(itemFilterList.filters.Count, 60);\r\n\t\t\tint num2 = 0;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggle [IndustrialConveyor]",
      "HookName": "OnSwitchToggle",
      "HookParameters": {
        "instance": "IndustrialConveyor",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "IndustrialConveyor",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SvSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.CallsPerSecond(2uL), global::BaseEntity.RPC_Server.IsVisible(3f)]\r\nprivate void SvSwitch(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSwitchToggled [IndustrialConveyor]",
      "HookName": "OnSwitchToggled",
      "HookParameters": {
        "instance": "IndustrialConveyor",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "IndustrialConveyor",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SvSwitch",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (Interface.CallHook(\"OnSwitchToggle\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.SetSwitch(!base.IsOn());\r\n\tInterface.CallHook(\"OnSwitchToggled\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemCraft [IndustrialCrafter]",
      "HookName": "OnItemCraft",
      "HookParameters": {
        "instance": "IndustrialCrafter",
        "blueprint": "ItemBlueprint"
      },
      "ReturnBehavior": 1,
      "TargetType": "IndustrialCrafter",
      "Category": "Industrial",
      "MethodData": {
        "MethodName": "RunJob",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tglobal::Item targetBlueprint = this.GetTargetBlueprint(i);\r\n\t\tif (targetBlueprint != null && !(this.GetWorkbench() == null) && this.GetWorkbench().Workbenchlevel >= targetBlueprint.blueprintTargetDef.Blueprint.GetWorkbenchLevel())\r\n\t\t{\r\n\t\t\tglobal::ItemBlueprint blueprint = targetBlueprint.blueprintTargetDef.Blueprint;\r\n\t\t\tif (Interface.CallHook(\"OnItemCraft\", this, blueprint) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbool flag = true;\r\n\t\t\tforeach (global::ItemAmount current in blueprint.GetIngredients())\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVehicleHornPressed",
      "HookName": "OnVehicleHornPressed",
      "HookParameters": {
        "instance": "VehicleModuleSeating",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "VehicleModuleSeating",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "PlayerServerInput",
        "ReturnType": "void",
        "Arguments": {
          "inputState": "InputState",
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved8, flag, false, true);\r\n\t\t}\r\n\t\tif (flag)\r\n\t\t{\r\n\t\t\tInterface.CallHook(\"OnVehicleHornPressed\", this, player);\r\n\t\t\tthis.hornPlayer = player;\r\n\t\t}\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanExplosiveStick",
      "HookName": "CanExplosiveStick",
      "HookParameters": {
        "instance": "TimedExplosive",
        "entity": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "TimedExplosive",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CanStickTo",
        "ReturnType": "bool",
        "Arguments": {
          "entity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "public virtual bool CanStickTo(global::BaseEntity entity)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanExplosiveStick\", this, entity);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::DecorDeployable decorDeployable;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoItemFind [Chainsaw]",
      "HookName": "OnInventoryAmmoItemFind",
      "HookParameters": {
        "inventory": "PlayerInventory",
        "fuelType": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "Chainsaw",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmmo",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryAmmoItemFind\", ownerPlayer.inventory, this.fuelType);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\treturn ownerPlayer.inventory.FindItemByItemName(this.fuelType.shortname);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoItemFind [FlameThrower]",
      "HookName": "OnInventoryAmmoItemFind",
      "HookParameters": {
        "inventory": "PlayerInventory",
        "fuelType": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "FlameThrower",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GetAmmo",
        "ReturnType": "Item",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer ownerPlayer = base.GetOwnerPlayer();\r\n\tif (!ownerPlayer)\r\n\t{\r\n\t\treturn null;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryAmmoItemFind\", ownerPlayer.inventory, this.fuelType);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\treturn ownerPlayer.inventory.FindItemByItemName(this.fuelType.shortname);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 1]",
      "HookName": "OnBonusItemDropped [patch 1]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      }
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 2]",
      "HookName": "OnBonusItemDropped [patch 2]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      }
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 3]",
      "HookName": "OnBonusItemDropped [patch 3]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      }
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 4]",
      "HookName": "OnBonusItemDropped [patch 4]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      }
    },
    {
      "Type": 1,
      "Name": "OnBonusItemDropped [patch 5]",
      "HookName": "OnBonusItemDropped [patch 5]",
      "ReturnBehavior": 0,
      "TargetType": "LootContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "DropBonusItems",
        "ReturnType": "void",
        "Arguments": {
          "initiator": "BaseEntity",
          "container": "ItemContainer"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnStashOcclude",
      "HookName": "OnStashOcclude",
      "HookParameters": {
        "instance": "StashContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "StashContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "DoOccludedCheck",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void DoOccludedCheck()\r\n{\r\n\tif (Physics.SphereCast(new Ray(base.transform.position + Vector3.up * 5f, Vector3.down), 0.25f, 5f, 2097152))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnStashOcclude\", this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.DropItems(null);\r\n\t\tbase.Kill(global::BaseNetworkable.DestroyMode.None);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardAuthorize [VehiclePrivilege]",
      "HookName": "OnCupboardAuthorize",
      "HookParameters": {
        "instance": "VehiclePrivilege",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VehiclePrivilege",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "AddSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.IsDriver(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCupboardAuthorize\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.AddPlayer(rpc.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardDeauthorize [VehiclePrivilege]",
      "HookName": "OnCupboardDeauthorize",
      "HookParameters": {
        "instance": "VehiclePrivilege",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VehiclePrivilege",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RemoveSelfAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.IsDriver(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCupboardDeauthorize\", this, rpc2.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.RemoveAll((PlayerNameID x) => x.userid == rpc.player.userID);\r\n\tglobal::BasePlayer arg_B1_1 = rpc.player;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCupboardClearList [VehiclePrivilege]",
      "HookName": "OnCupboardClearList",
      "HookParameters": {
        "instance": "VehiclePrivilege",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "VehiclePrivilege",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "ClearList",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.IsDriver(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnCupboardClearList\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.authorizedPlayers.Clear();\r\n\tbase.UpdateMaxAuthCapacity();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBedMade",
      "HookName": "OnBedMade",
      "HookParameters": {
        "instance": "SleepingBag",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "SleepingBag",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_MakeBed",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tulong num = this.deployerUserID;\r\n\tthis.deployerUserID = msg.player.userID;\r\n\tthis.NotifyPlayer(num);\r\n\tthis.NotifyPlayer(this.deployerUserID);\r\n\tglobal::SleepingBag.OnBagChangedOwnership(this, num);\r\n\tInterface.CallHook(\"OnBedMade\", this, msg.player);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnPlayerChat",
      "HookName": "IOnPlayerChat",
      "HookParameters": {
        "userId": "ulong",
        "username": "string",
        "<strChatText>5__2": "string",
        "targetChannel": "ChatChannel",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 3,
      "TargetType": "ConVar.Chat/<sayAs>d__19",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\tif (this.<strChatText>5__2.Length <= 0)\r\n\t\t\t{\r\n\t\t\t\tresult = false;\r\n\t\t\t\tgoto IL_93D;\r\n\t\t\t}\r\n\t\t\tobject returnvar = Interface.CallHook(\"IOnPlayerChat\", this.userId, this.username, this.<strChatText>5__2, this.targetChannel, this.player);\r\n\t\t\tif (returnvar is bool)\r\n\t\t\t{\r\n\t\t\t\tresult = (bool)returnvar;\r\n\t\t\t}\r\n\t\t\tif (this.<strChatText>5__2.StartsWith(\"/\") || this.<strChatText>5__2.StartsWith(\"\\\\\"))\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "IOnPlayerChat[patch]",
      "HookName": "IOnPlayerChat[patch]",
      "ReturnBehavior": 0,
      "TargetType": "ConVar.Chat/<sayAs>d__19",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 1,
      "Name": "IOnPlayerChat[patch2]",
      "HookName": "IOnPlayerChat[patch2]",
      "ReturnBehavior": 0,
      "TargetType": "ConVar.Chat/<sayAs>d__19",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnCodeChanged",
      "HookName": "OnCodeChanged",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CodeLock",
        "text": "string",
        "flag": "bool"
      },
      "ReturnBehavior": 0,
      "TargetType": "CodeLock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "RPC_ChangeCode",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tthis.guestCode = text;\r\n\t\tthis.hasGuestCode = (this.guestCode.Length > 0);\r\n\t\tthis.guestPlayers.Clear();\r\n\t\tthis.guestPlayers.Add(rpc.player.userID);\r\n\t}\r\n\tInterface.CallHook(\"OnCodeChanged\", rpc.player, this, text, flag);\r\n\tthis.DoEffect(this.effectCodeChanged.resourcePath);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMagazineReload",
      "HookName": "OnMagazineReload",
      "HookParameters": {
        "instance": "BaseProjectile",
        "ammoSource": "IAmmoContainer",
        "GetOwnerPlayer()": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseProjectile",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "TryReloadMagazine",
        "ReturnType": "bool",
        "Arguments": {
          "ammoSource": "IAmmoContainer",
          "desiredAmount": "int"
        }
      },
      "CodeAfterInjection": "public virtual bool TryReloadMagazine(global::IAmmoContainer ammoSource, int desiredAmount = -1)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnMagazineReload\", this, ammoSource, this.GetOwnerPlayer());\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!this.TryReload(ammoSource, desiredAmount, true))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponMount",
      "HookName": "OnRackedWeaponMount",
      "HookParameters": {
        "item": "Item",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 4,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MountWeapon",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "player": "BasePlayer",
          "gridCellIndex": "int",
          "rotation": "int",
          "sendUpdate": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (player == null)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"OnRackedWeaponMount\", item, player, this);\r\n\tif (returnvar != null)\r\n\t{\r\n\t\treturn returnvar is bool && (bool)returnvar;\r\n\t}\r\n\tint itemid = item.info.itemid;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponMounted",
      "HookName": "OnRackedWeaponMounted",
      "HookParameters": {
        "item": "Item",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 0,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "MountWeapon",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "player": "BasePlayer",
          "gridCellIndex": "int",
          "rotation": "int",
          "sendUpdate": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (sendUpdate)\r\n\t{\r\n\t\tglobal::ItemManager.DoRemoves();\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnRackedWeaponMounted\", item, player, this);\r\n\treturn true;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponSwap",
      "HookName": "OnRackedWeaponSwap",
      "HookParameters": {
        "expr_06": "Item",
        "forItemDef": "WeaponRackSlot",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 1,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SwapPlayerWeapon",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "gridCellIndex": "int",
          "takeFromBeltIndex": "int",
          "rotation": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\tint bestPlacementCellIndex = this.GetBestPlacementCellIndex(this.GetXYForIndex(gridCellIndex), forItemDef, rotation, weaponAtIndex);\r\n\tif (bestPlacementCellIndex == -1)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRackedWeaponSwap\", item, weaponAtIndex, player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\titem.RemoveFromContainer();\r\n\tthis.GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, false, true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponSwapped",
      "HookName": "OnRackedWeaponSwapped",
      "HookParameters": {
        "expr_06": "Item",
        "forItemDef": "WeaponRackSlot",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 0,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SwapPlayerWeapon",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "gridCellIndex": "int",
          "takeFromBeltIndex": "int",
          "rotation": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\titem.RemoveFromContainer();\r\n\tthis.GivePlayerWeapon(player, mountSlotIndex, takeFromBeltIndex, false, true);\r\n\tthis.MountWeapon(item, player, bestPlacementCellIndex, rotation, false);\r\n\tglobal::ItemManager.DoRemoves();\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n\tInterface.CallHook(\"OnRackedWeaponSwapped\", item, weaponAtIndex, player, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponTake",
      "HookName": "OnRackedWeaponTake",
      "HookParameters": {
        "slot": "Item",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 1,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GivePlayerWeapon",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "mountSlotIndex": "int",
          "playerBeltIndex": "int",
          "tryHold": "bool",
          "sendUpdate": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRackedWeaponTake\", slot, player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ClearSlot(weaponAtIndex);\r\n\tbool flag = false;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponTaken",
      "HookName": "OnRackedWeaponTaken",
      "HookParameters": {
        "slot": "Item",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 0,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "GivePlayerWeapon",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "mountSlotIndex": "int",
          "playerBeltIndex": "int",
          "tryHold": "bool",
          "sendUpdate": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (sendUpdate)\r\n\t{\r\n\t\tglobal::ItemManager.DoRemoves();\r\n\t\tbase.SendNetworkUpdateImmediate(false);\r\n\t}\r\n\tInterface.CallHook(\"OnRackedWeaponTaken\", slot, player, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponUnload",
      "HookName": "OnRackedWeaponUnload",
      "HookParameters": {
        "slot": "Item",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 1,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "UnloadWeapon",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "mountSlotIndex": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::Item slot = base.inventory.GetSlot(weaponAtIndex.InventoryIndex);\r\n\tif (slot == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRackedWeaponUnload\", slot, player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::BaseEntity heldEntity = slot.GetHeldEntity();\r\n\tif (heldEntity == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponUnloaded",
      "HookName": "OnRackedWeaponUnloaded",
      "HookParameters": {
        "slot": "Item",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 0,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "UnloadWeapon",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "mountSlotIndex": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::ItemDefinition ammoType = component.primaryMagazine.ammoType;\r\n\tcomponent.UnloadAmmo(slot, player);\r\n\tthis.SetSlotAmmoDetails(weaponAtIndex, slot);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n\tbase.ClientRPC(global::RpcTarget.Player(\"PlayAmmoSound\", player), ammoType.itemid, 1);\r\n\tInterface.CallHook(\"OnRackedWeaponUnloaded\", slot, player, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponLoad",
      "HookName": "OnRackedWeaponLoad",
      "HookParameters": {
        "slot": "Item",
        "itemDefinition": "ItemDefinition",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 1,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LoadWeaponAmmo",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::ItemDefinition itemDefinition = global::ItemManager.FindItemDefinition(num);\r\n\tif (itemDefinition == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnRackedWeaponLoad\", slot, itemDefinition, player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (itemDefinition == global::SnowballGun.SnowballInventoryItem)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnRackedWeaponLoaded",
      "HookName": "OnRackedWeaponLoaded",
      "HookParameters": {
        "slot": "Item",
        "itemDefinition": "ItemDefinition",
        "player": "BasePlayer",
        "instance": "WeaponRack"
      },
      "ReturnBehavior": 0,
      "TargetType": "WeaponRack",
      "Category": "Item",
      "MethodData": {
        "MethodName": "LoadWeaponAmmo",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tcomponent.primaryMagazine.ammoType = itemDefinition;\r\n\tcomponent.TryReloadMagazine(player.inventory, -1);\r\n\tthis.SetSlotAmmoDetails(weaponAtIndex, slot);\r\n\tbase.SendNetworkUpdateImmediate(false);\r\n\tbase.ClientRPC(global::RpcTarget.Player(\"PlayAmmoSound\", player), itemDefinition.itemid, 0);\r\n\tInterface.CallHook(\"OnRackedWeaponLoaded\", slot, itemDefinition, player, this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEntityLoaded",
      "HookName": "OnEntityLoaded",
      "HookDescription": "Called after a network object is loaded from a save (including trees)\r\nNo return behavior",
      "HookParameters": {
        "instance": "BaseNetworkable",
        "info": "LoadInfo"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseNetworkable",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Load",
        "ReturnType": "void",
        "Arguments": {
          "info": "BaseNetworkable/LoadInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (info.msg.baseNetworkable == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tInterface.CallHook(\"OnEntityLoaded\", this, info);\r\n\tProtoBuf.BaseNetworkable baseNetworkable = info.msg.baseNetworkable;\r\n\tif (this.prefabID != baseNetworkable.prefabID)\r\n\t{\r\n\t\tstring[] expr_40 = new string[6];\r\n\t\texpr_40[0] = \"Prefab IDs don't match! \";\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTimedExplosiveExplode",
      "HookName": "OnTimedExplosiveExplode",
      "HookParameters": {
        "instance": "TimedExplosive",
        "explosionFxPos": "Vector3"
      },
      "ReturnBehavior": 1,
      "TargetType": "TimedExplosive",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "Explode",
        "ReturnType": "void",
        "Arguments": {
          "explosionFxPos": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tglobal::Effect.server.Run(this.watersurfaceExplosionEffect.resourcePath, explosionFxPos.WithY(waterInfo.surfaceLevel), this.GetExplosionNormal(), null, true, null);\r\n\t}\r\n\tif (this.GetDamageList(null).Count > 0)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTimedExplosiveExplode\", this, explosionFxPos) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tVector3 vector2 = this.ExplosionCenter();\r\n\t\tif (this.onlyDamageParent)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanFastTrackCraftTask",
      "HookName": "CanFastTrackCraftTask",
      "HookParameters": {
        "instance": "ItemCrafter",
        "itemCraftTask": "ItemCraftTask",
        "taskID": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "ItemCrafter",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FastTrackTask",
        "ReturnType": "bool",
        "Arguments": {
          "taskID": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (itemCraftTask == value)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanFastTrackCraftTask\", this, itemCraftTask, taskID2);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tvalue.endTime = 0f;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeHomingTargeted [BaseHelicopter]",
      "HookName": "CanBeHomingTargeted",
      "HookParameters": {
        "instance": "BaseHelicopter"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseHelicopter",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "IsValidHomingTarget",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public virtual bool IsValidHomingTarget()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeHomingTargeted\", this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeHomingTargeted [CH47Helicopter]",
      "HookName": "CanBeHomingTargeted",
      "HookParameters": {
        "instance": "CH47Helicopter"
      },
      "ReturnBehavior": 1,
      "TargetType": "CH47Helicopter",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "IsValidHomingTarget",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public override bool IsValidHomingTarget()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeHomingTargeted\", this);\r\n\treturn returnvar is bool && (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeHomingTargeted [PlayerHelicopter]",
      "HookName": "CanBeHomingTargeted",
      "HookParameters": {
        "instance": "PlayerHelicopter"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerHelicopter",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "IsValidHomingTarget",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public override bool IsValidHomingTarget()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeHomingTargeted\", this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn base.IsOn();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeHomingTargeted [PatrolHelicopter]",
      "HookName": "CanBeHomingTargeted",
      "HookParameters": {
        "instance": "PatrolHelicopter"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopter",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "IsValidHomingTarget",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool IsValidHomingTarget()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeHomingTargeted\", this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeHomingTargeted [AttackHeliPilotFlare]",
      "HookName": "CanBeHomingTargeted",
      "HookParameters": {
        "instance": "AttackHeliPilotFlare"
      },
      "ReturnBehavior": 1,
      "TargetType": "AttackHeliPilotFlare",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "IsValidHomingTarget",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool IsValidHomingTarget()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeHomingTargeted\", this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanBeHomingTargeted [RoadFlare]",
      "HookName": "CanBeHomingTargeted",
      "HookParameters": {
        "instance": "RoadFlare"
      },
      "ReturnBehavior": 1,
      "TargetType": "RoadFlare",
      "Category": "Weapon",
      "MethodData": {
        "MethodName": "IsValidHomingTarget",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "public bool IsValidHomingTarget()\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanBeHomingTargeted\", this);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInterferenceUpdate",
      "HookName": "OnInterferenceUpdate",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "UpdateInterference",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!base.IsOn())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnInterferenceUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat num = 0f;\r\n\tforeach (global::AutoTurret current in this.nearbyTurrets)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInterferenceOthersUpdate",
      "HookName": "OnInterferenceOthersUpdate",
      "HookParameters": {
        "instance": "AutoTurret"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "UpdateInterferenceOnOthers",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void UpdateInterferenceOnOthers()\r\n{\r\n\tif (Interface.CallHook(\"OnInterferenceOthersUpdate\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (global::AutoTurret current in this.nearbyTurrets)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEventCollectablePickup",
      "HookName": "OnEventCollectablePickup",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "CollectableEasterEgg"
      },
      "ReturnBehavior": 4,
      "TargetType": "CollectableEasterEgg",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "RPC_PickUp",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tif (!global::EggHuntEvent.serverEvent.IsEventActive())\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnEventCollectablePickup\", msg.player, this) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tglobal::EggHuntEvent.serverEvent.OnEggCollected(msg.player, this);\r\n\t\tint iAmount = 1;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHuntEventStart",
      "HookName": "OnHuntEventStart",
      "HookParameters": {
        "instance": "EggHuntEvent"
      },
      "ReturnBehavior": 4,
      "TargetType": "EggHuntEvent",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "StartEvent",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void StartEvent()\r\n{\r\n\tif (Interface.CallHook(\"OnHuntEventStart\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint count = global::BasePlayer.activePlayerList.Count;\r\n\tif (global::EggHuntEvent.includeBots)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnHuntEventEnd",
      "HookName": "OnHuntEventEnd",
      "HookParameters": {
        "instance": "EggHuntEvent"
      },
      "ReturnBehavior": 4,
      "TargetType": "EggHuntEvent",
      "Category": "Seasonal",
      "MethodData": {
        "MethodName": "Update",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, true, false, true);\r\n\t\t}\r\n\t\tif (this.timeAlive - this.warmupTime > global::EggHuntEvent.durationSeconds && !base.IsInvoking(new Action(this.Cooldown)))\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnHuntEventEnd\", this) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, true, false, true);\r\n\t\t\tthis.CleanupEggs();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPatrolHelicopterTakeDamage",
      "HookName": "OnPatrolHelicopterTakeDamage",
      "HookParameters": {
        "instance": "PatrolHelicopter",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopter",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "public override void Hurt(global::HitInfo info)\r\n{\r\n\tif (Interface.CallHook(\"OnPatrolHelicopterTakeDamage\", this, info) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = false;\r\n\tif (info.damageTypes.Total() >= base.health)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLockerAcceptItem",
      "HookName": "CanLockerAcceptItem",
      "HookParameters": {
        "instance": "Locker",
        "item": "Item",
        "targetSlot": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "Locker",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ItemFilter",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "public override bool ItemFilter(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanLockerAcceptItem\", this, item, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!base.ItemFilter(item, targetSlot))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCoalingTowerStart",
      "HookName": "OnCoalingTowerStart",
      "HookParameters": {
        "instance": "CoalingTower",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "CoalingTower",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "RPC_Unload",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.MaxDistance(3f)]\r\nprivate void RPC_Unload(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"OnCoalingTowerStart\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::CoalingTower.ActionAttemptStatus actionAttemptStatus;\r\n\tif (!this.TryUnloadActiveWagon(out actionAttemptStatus) && msg.player != null)\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnCoalingTowerGather",
      "HookName": "OnCoalingTowerGather",
      "ReturnBehavior": 0,
      "TargetType": "CoalingTower",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "EmptyTenPercent",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tif (this.tcUnloadingNow.wagonType == global::TrainCarUnloadable.WagonType.Lootboxes)\r\n\t\t\t{\r\n\t\t\t\tcurrent.Remove(0f);\r\n\t\t\t}\r\n\t\t\telse if (Interface.CallHook(\"OnCoalingTowerGather\", this, current) != null)\r\n\t\t\t{\r\n\t\t\t\tcurrent.Remove(0f);\r\n\t\t\t}\r\n\t\t\telse\r\n\t\t\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPatrolHelicopterKill",
      "HookName": "OnPatrolHelicopterKill",
      "HookParameters": {
        "instance": "PatrolHelicopter",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "PatrolHelicopter",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\treturn;\r\n\t}\r\n\tbool flag = false;\r\n\tif (info.damageTypes.Total() >= base.health)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnPatrolHelicopterKill\", this, info) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tbase.health = 10000f;\r\n\t\tthis.myAI.CriticalDamage();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDig",
      "HookName": "OnPlayerDig",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "BaseDiggableEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "BaseDiggableEntity",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Dig",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void Dig(global::BasePlayer player)\r\n{\r\n\tif (Interface.CallHook(\"OnPlayerDig\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.digsRemaining == this.RequiredDigCount)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPoweredLightsPointAdd",
      "HookName": "OnPoweredLightsPointAdd",
      "HookParameters": {
        "instance": "PoweredLightsDeployer",
        "player": "BasePlayer",
        "vector": "Vector3",
        "vector2": "Vector3"
      },
      "ReturnBehavior": 1,
      "TargetType": "PoweredLightsDeployer",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "AddPoint",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CheckValidPlacement(vector, 0.1f, 10551297))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPoweredLightsPointAdd\", this, player, vector, vector2) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num2;\r\n\tif (this.active == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSignContentCopied",
      "HookName": "OnSignContentCopied",
      "HookParameters": {
        "instance": "SignContent",
        "s": "ISignage",
        "b": "IUGCBrowserEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "SignContent",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "CopyInfoToSign",
        "ReturnType": "void",
        "Arguments": {
          "s": "ISignage",
          "b": "IUGCBrowserEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\tb.EditingHistory.Clear();\r\n\tforeach (ulong current in this.editHistory)\r\n\t{\r\n\t\tb.EditingHistory.Add(current);\r\n\t}\r\n\tInterface.CallHook(\"OnSignContentCopied\", this, s, b);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNearbyTurretsScan",
      "HookName": "OnNearbyTurretsScan",
      "ReturnBehavior": 0,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "UpdateNearbyTurrets",
        "ReturnType": "void",
        "Arguments": {
          "created": "bool"
        }
      },
      "CodeAfterInjection": "private void UpdateNearbyTurrets(bool created)\r\n{\r\n\tList<global::AutoTurret> list = Facepunch.Pool.Get<List<global::AutoTurret>>();\r\n\tif (Interface.CallHook(\"OnNearbyTurretsScan\", this, list, created) == null)\r\n\t{\r\n\t\tglobal::Vis.Entities<global::AutoTurret>(base.transform.position, ConVar.Sentry.interferenceradius, list, 256, QueryTriggerInteraction.Ignore);\r\n\t}\r\n\tforeach (global::AutoTurret current in list)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQuarryToggle [on]",
      "HookName": "OnQuarryToggle",
      "HookParameters": {
        "miningQuarry": "MiningQuarry",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StartEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\npublic void StartEngine(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tglobal::MiningQuarry miningQuarry = base.GetParentEntity() as global::MiningQuarry;\r\n\tif (miningQuarry)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnQuarryToggle\", miningQuarry, msg.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tminingQuarry.EngineSwitch(true);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQuarryToggle [off]",
      "HookName": "OnQuarryToggle",
      "HookParameters": {
        "miningQuarry": "MiningQuarry",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\npublic void StopEngine(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tglobal::MiningQuarry miningQuarry = base.GetParentEntity() as global::MiningQuarry;\r\n\tif (miningQuarry)\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnQuarryToggle\", miningQuarry, msg.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tminingQuarry.EngineSwitch(false);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryToggled [off] [patch]",
      "HookName": "OnQuarryToggled",
      "ReturnBehavior": 0,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!miningQuarry || Interface.CallHook(\"OnQuarryToggle\", miningQuarry, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tminingQuarry.EngineSwitch(false);\r\n\tInterface.CallHook(\"OnQuarryToggled\", miningQuarry, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQuarryToggled [off]",
      "HookName": "OnQuarryToggled",
      "HookParameters": {
        "miningQuarry": "MiningQuarry",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StopEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tminingQuarry.EngineSwitch(false);\r\n\t}\r\n\tInterface.CallHook(\"OnQuarryToggled\", miningQuarry, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnQuarryToggled [on]",
      "HookName": "OnQuarryToggled",
      "HookParameters": {
        "miningQuarry": "MiningQuarry",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StartEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tminingQuarry.EngineSwitch(true);\r\n\t}\r\n\tInterface.CallHook(\"OnQuarryToggled\", miningQuarry, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnQuarryToggled [on] [patch]",
      "HookName": "OnQuarryToggled",
      "ReturnBehavior": 0,
      "TargetType": "EngineSwitch",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "StartEngine",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!miningQuarry || Interface.CallHook(\"OnQuarryToggle\", miningQuarry, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tminingQuarry.EngineSwitch(true);\r\n\tInterface.CallHook(\"OnQuarryToggled\", miningQuarry, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationEnded",
      "HookName": "OnNpcConversationEnded",
      "HookParameters": {
        "instance": "NPCTalking",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "OnConversationEnded",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public virtual void OnConversationEnded(global::BasePlayer player)\r\n{\r\n\tInterface.CallHook(\"OnNpcConversationEnded\", this, player);\r\n\tif (this.conversingPlayers.Contains(player))\r\n\t{\r\n\t\tthis.conversingPlayers.Remove(player);\r\n\t}\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNpcConversationStart",
      "HookName": "OnNpcConversationStart",
      "HookParameters": {
        "instance": "NPCTalking",
        "ply": "BasePlayer",
        "conversationFor": "ConversationData"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCTalking",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "Server_BeginTalking",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tif (this.conversingPlayers.Contains(ply))\r\n\t\t{\r\n\t\t\tthis.OnConversationEnded(ply);\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnNpcConversationStart\", this, ply, conversationFor) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.conversingPlayers.Add(ply);\r\n\t\tthis.UpdateFlags();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDispenserGathered",
      "HookName": "OnDispenserGathered",
      "HookParameters": {
        "instance": "ResourceDispenser",
        "entity": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResourceDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "GiveResourceFromItem",
        "ReturnType": "void",
        "Arguments": {
          "entity": "BasePlayer",
          "itemAmt": "ItemAmount",
          "gatherDamage": "float",
          "destroyFraction": "float",
          "attackWeapon": "AttackEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.ApplyItemOwnership(entity, item);\r\n\t\tthis.OverrideOwnership(item, attackWeapon);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, entity, attackWeapon);\r\n\t\tInterface.CallHook(\"OnDispenserGathered\", this, entity, item);\r\n\t\twhile (item.amount > item.MaxStackable())\r\n\t\t{\r\n\t\t\tglobal::Item item2 = item.SplitItem(item.MaxStackable());\r\n\t\t\tentity.GiveItem(item2, global::BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCollectiblePickedup",
      "HookName": "OnCollectiblePickedup",
      "HookParameters": {
        "instance": "CollectibleEntity",
        "reciever": "BasePlayer",
        "component": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "CollectibleEntity",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "DoPickup",
        "ReturnType": "void",
        "Arguments": {
          "reciever": "BasePlayer",
          "eat": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t}\r\n\t\t\t\t}\r\n\t\t\t\tif (reciever)\r\n\t\t\t\t{\r\n\t\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, this, reciever, null);\r\n\t\t\t\t\tInterface.CallHook(\"OnCollectiblePickedup\", this, reciever, item);\r\n\t\t\t\t\treciever.GiveItem(item, global::BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\titem.Drop(base.transform.position + Vector3.up * 0.5f, Vector3.up, default(Quaternion));\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDispenserBonusReceived",
      "HookName": "OnDispenserBonusReceived",
      "HookParameters": {
        "instance": "ResourceDispenser",
        "player": "BasePlayer",
        "item": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "ResourceDispenser",
      "Category": "Resource",
      "MethodData": {
        "MethodName": "AssignFinishBonus",
        "ReturnType": "void",
        "Arguments": {
          "player": "BasePlayer",
          "fraction": "float",
          "weapon": "AttackEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t{\r\n\t\t\t\t\titem = (global::Item)returnvar;\r\n\t\t\t\t}\r\n\t\t\t\tthis.ApplyItemOwnership(player, item);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnGatherItem(item.info.shortname, item.amount, base.baseEntity, player, weapon);\r\n\t\t\t\tInterface.CallHook(\"OnDispenserBonusReceived\", this, player, item);\r\n\t\t\t\twhile (item.amount > item.MaxStackable())\r\n\t\t\t\t{\r\n\t\t\t\t\tglobal::Item item2 = item.SplitItem(item.MaxStackable());\r\n\t\t\t\t\tplayer.GiveItem(item2, global::BaseEntity.GiveItemReason.ResourceHarvested);\r\n\t\t\t\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnItemFilter",
      "HookName": "OnItemFilter",
      "HookParameters": {
        "item": "Item",
        "instance": "StorageContainer",
        "targetSlot": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "StorageContainer",
      "Category": "Item",
      "MethodData": {
        "MethodName": "ItemFilter",
        "ReturnType": "bool",
        "Arguments": {
          "item": "Item",
          "targetSlot": "int"
        }
      },
      "CodeAfterInjection": "public virtual bool ItemFilter(global::Item item, int targetSlot)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnItemFilter\", item, this, targetSlot);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.onlyAcceptCategory == global::ItemCategory.All || item.info.category == this.onlyAcceptCategory;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlanterBoxFertilize",
      "HookName": "OnPlanterBoxFertilize",
      "HookDescription": "",
      "HookParameters": {
        "instance": "PlanterBox"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlanterBox",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "FertilizeGrowables",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public void FertilizeGrowables()\r\n{\r\n\tif (Interface.CallHook(\"OnPlanterBoxFertilize\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tint num = this.GetFertilizerCount();\r\n\tif (num <= 0)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerMarkersSend",
      "HookName": "OnPlayerMarkersSend",
      "HookDescription": "Called before map markers are sent to the client.\r\nAllows adding new or manipulating existing markers.",
      "HookParameters": {
        "instance": "BasePlayer",
        "mapNoteList": "MapNoteList"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendMarkersToClient",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tif (this.State.pointsOfInterest != null)\r\n\t\t{\r\n\t\t\tmapNoteList.notes.AddRange(this.State.pointsOfInterest);\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnPlayerMarkersSend\", this, mapNoteList);\r\n\t\tbase.ClientRPC(global::RpcTarget.Player(\"Client_ReceiveMarkers\", this), mapNoteList);\r\n\t\tmapNoteList.notes.Clear();\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerPingsSend",
      "HookName": "OnPlayerPingsSend",
      "HookDescription": "Called before ping markers are sent to the client.\r\nAllows adding new or manipulating existing markers",
      "HookParameters": {
        "instance": "BasePlayer",
        "mapNoteList": "MapNoteList"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SendPingsToClient",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tusing (MapNoteList mapNoteList = Pool.Get<MapNoteList>())\r\n\t{\r\n\t\tmapNoteList.notes = Pool.Get<List<MapNote>>();\r\n\t\tmapNoteList.notes.AddRange(this.State.pings);\r\n\t\tInterface.CallHook(\"OnPlayerPingsSend\", this, mapNoteList);\r\n\t\tbase.ClientRPC(global::RpcTarget.Player(\"Client_ReceivePings\", this), mapNoteList);\r\n\t\tmapNoteList.notes.Clear();\r\n\t}\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBoomboxStationValidate",
      "HookName": "OnBoomboxStationValidate",
      "HookParameters": {
        "url": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "BoomBox",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "IsStationValid",
        "ReturnType": "bool",
        "Arguments": {
          "url": "string"
        }
      },
      "CodeAfterInjection": "private static bool IsStationValid(string url)\r\n{\r\n\tglobal::BoomBox.ParseServerUrlList();\r\n\tobject returnvar = Interface.CallHook(\"OnBoomboxStationValidate\", url);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tglobal::ShoutcastStreamer.CheckBuiltInRadios();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBoomboxToggle",
      "HookName": "OnBoomboxToggle",
      "HookParameters": {
        "instance": "BoomBox",
        "player": "BasePlayer",
        "flag": "bool"
      },
      "ReturnBehavior": 4,
      "TargetType": "BoomBox",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "ServerTogglePlay",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage",
          "bypassPower": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.IsPowered() && !bypassPower)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbool flag = msg.read.ReadByte() == 1;\r\n\tif (Interface.CallHook(\"OnBoomboxToggle\", this, msg.player, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ServerTogglePlay(flag);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBoomboxStationUpdate",
      "HookName": "OnBoomboxStationUpdate",
      "HookParameters": {
        "instance": "BoomBox",
        "text": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "BoomBox",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "Server_UpdateRadioIP",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "public void Server_UpdateRadioIP(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tstring text = msg.read.String(256, false);\r\n\tif (Interface.CallHook(\"OnBoomboxStationUpdate\", this, text, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (global::BoomBox.IsStationValid(text))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnBoomboxStationUpdated",
      "HookName": "OnBoomboxStationUpdated",
      "HookParameters": {
        "instance": "BoomBox",
        "text": "string",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BoomBox",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "Server_UpdateRadioIP",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\tulong assignedRadioBy = msg.player.userID.Get();\r\n\t\t\tthis.AssignedRadioBy = assignedRadioBy;\r\n\t\t}\r\n\t\tthis.CurrentRadioIp = text;\r\n\t\tbase.baseEntity.ClientRPC(global::RpcTarget.NetworkGroup(\"OnRadioIPChanged\"), this.CurrentRadioIp);\r\n\t\tInterface.CallHook(\"OnBoomboxStationUpdated\", this, text, msg.player);\r\n\t\tif (this.IsOn())\r\n\t\t{\r\n\t\t\tthis.ServerTogglePlay(false);\r\n\t\t}\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAIBrainStateSwitch",
      "HookName": "OnAIBrainStateSwitch",
      "HookParameters": {
        "instance": "BaseAIBrain",
        "CurrentState": "BasicAIState",
        "newState": "BasicAIState"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseAIBrain",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "SwitchToState",
        "ReturnType": "bool",
        "Arguments": {
          "newState": "BaseAIBrain/BasicAIState",
          "stateContainerID": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\tif (this.CurrentState == newState && !this.UseAIDesign)\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t\tobject returnvar = Interface.CallHook(\"OnAIBrainStateSwitch\", this, this.CurrentState, newState);\r\n\t\tif (returnvar != null)\r\n\t\t{\r\n\t\t\treturn returnvar is bool && (bool)returnvar;\r\n\t\t}\r\n\t\tthis.CurrentState.StateLeave(this, this.GetBaseEntity());\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAIBrainStateSwitched",
      "HookName": "OnAIBrainStateSwitched",
      "HookParameters": {
        "instance": "BaseAIBrain",
        "CurrentState": "BasicAIState"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseAIBrain",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "SwitchToState",
        "ReturnType": "bool",
        "Arguments": {
          "newState": "BaseAIBrain/BasicAIState",
          "stateContainerID": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tthis.AddEvents(stateContainerID);\r\n\tthis.CurrentState = newState;\r\n\tthis.CurrentState.StateEnter(this, this.GetBaseEntity());\r\n\tthis.currentStateContainerID = stateContainerID;\r\n\tInterface.CallHook(\"OnAIBrainStateSwitched\", this, this.CurrentState);\r\n\treturn true;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateLaptopAttack",
      "HookName": "OnCrateLaptopAttack",
      "HookParameters": {
        "instance": "HackableLockedCrate",
        "info": "HitInfo"
      },
      "ReturnBehavior": 1,
      "TargetType": "HackableLockedCrate",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnAttacked",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (base.isServer)\r\n\t{\r\n\t\tif (global::StringPool.Get(info.HitBone) == \"laptopcollision\")\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnCrateLaptopAttack\", this, info) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tglobal::Effect.server.Run(this.shockEffect.resourcePath, this, info.HitBone, info.HitPositionLocal, Vector3.up, null, false, null);\r\n\t\t\tthis.hackSeconds -= 8f * (info.damageTypes.Total() / 50f);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanSeeStash",
      "HookName": "CanSeeStash",
      "HookParameters": {
        "instance": "BasePlayer",
        "Entity": "StashContainer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CheckStashRevealInvoke",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\telse if (nearbyStash.Entity.IsHidden() && nearbyStash.Entity.PlayerInRange(this))\r\n\t\t{\r\n\t\t\tnearbyStash.LookingAtTime += global::StashContainer.PlayerDetectionTickRate;\r\n\t\t\tif (nearbyStash.LookingAtTime >= nearbyStash.Entity.uncoverTime)\r\n\t\t\t{\r\n\t\t\t\tif (Interface.CallHook(\"CanSeeStash\", this, nearbyStash.Entity) != null)\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tnearbyStash.Entity.SetHidden(false);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStashExposed",
      "HookName": "OnStashExposed",
      "HookParameters": {
        "Entity": "StashContainer",
        "instance": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CheckStashRevealInvoke",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t{\r\n\t\t\t\t\treturn;\r\n\t\t\t\t}\r\n\t\t\t\tnearbyStash.Entity.SetHidden(false);\r\n\t\t\t\tFacepunch.Rust.Analytics.Azure.OnStashRevealed(this, nearbyStash.Entity);\r\n\t\t\t\tInterface.CallHook(\"OnStashExposed\", nearbyStash.Entity, this);\r\n\t\t\t}\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tnearbyStash.LookingAtTime = 0f;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnMetalDetectorFlagRequest",
      "HookName": "OnMetalDetectorFlagRequest",
      "HookDescription": "",
      "HookParameters": {
        "instance": "BaseMetalDetector",
        "vector": "Vector3",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "BaseMetalDetector",
      "Category": "Player",
      "MethodData": {
        "MethodName": "RPC_RequestFlag",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (this.nearestSource == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 vector = rpc.read.Vector3();\r\n\tInterface.CallHook(\"OnMetalDetectorFlagRequest\", this, vector, player);\r\n\tVector3 pos;\r\n\tif (this.nearestSource.VerifyScanPosition(player.transform.position, vector, out pos))\r\n\t{\r\n\t\tthis.nearestSource.Detected(pos);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipHarborApproach",
      "HookName": "OnCargoShipHarborApproach",
      "HookParameters": {
        "instance": "CargoShip",
        "cn": "CargoNotifier"
      },
      "ReturnBehavior": 1,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "StartHarborApproach",
        "ReturnType": "void",
        "Arguments": {
          "cn": "CargoNotifier"
        }
      },
      "CodeAfterInjection": "private void StartHarborApproach(global::CargoNotifier cn)\r\n{\r\n\tif (Interface.CallHook(\"OnCargoShipHarborApproach\", this, cn) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.PlayHorn();\r\n\tthis.isDoingHarborApproach = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipHarborArrived",
      "HookName": "OnCargoShipHarborArrived",
      "HookParameters": {
        "instance": "CargoShip"
      },
      "ReturnBehavior": 0,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnArrivedAtHarbor",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\telse if (this.harborIndex == 1)\r\n\t{\r\n\t\tbase.SetFlag(global::BaseEntity.Flags.Reserved4, true, false, true);\r\n\t}\r\n\tbase.Invoke(new Action(this.LeaveHarbor), global::CargoShip.dock_time);\r\n\tInterface.CallHook(\"OnCargoShipHarborArrived\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCargoShipHarborLeave",
      "HookName": "OnCargoShipHarborLeave",
      "HookParameters": {
        "instance": "CargoShip"
      },
      "ReturnBehavior": 0,
      "TargetType": "CargoShip",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "LeaveHarbor",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tthis.PlayHorn();\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved1, false, false, true);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved2, true, false, true);\r\n\tthis.currentHarborApproachNode++;\r\n\tInterface.CallHook(\"OnCargoShipHarborLeave\", this);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnNoGoZoneAdded",
      "HookName": "OnNoGoZoneAdded",
      "HookParameters": {
        "instance": "PatrolHelicopterAI",
        "zone": "DangerZone"
      },
      "ReturnBehavior": 4,
      "TargetType": "PatrolHelicopterAI",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "NoGoZoneAdded",
        "ReturnType": "void",
        "Arguments": {
          "zone": "PatrolHelicopterAI/DangerZone"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!global::PatrolHelicopterAI.use_danger_zones)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnNoGoZoneAdded\", this, zone) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (zone.IsInMonument)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanUseHBHFSensor",
      "HookName": "CanUseHBHFSensor",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "HBHFSensor"
      },
      "ReturnBehavior": 1,
      "TargetType": "HBHFSensor",
      "Category": "Player",
      "MethodData": {
        "MethodName": "CanUse",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public bool CanUse(global::BasePlayer player)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanUseHBHFSensor\", player, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn player.CanBuild();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnElevatorButtonPress",
      "HookName": "OnElevatorButtonPress",
      "HookParameters": {
        "instance": "ElevatorLift",
        "player": "BasePlayer",
        "direction": "Direction",
        "flag": "bool"
      },
      "ReturnBehavior": 4,
      "TargetType": "ElevatorLift",
      "Category": "Elevator",
      "MethodData": {
        "MethodName": "Server_RaiseLowerFloor",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void Server_RaiseLowerFloor(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tglobal::Elevator.Direction direction = (global::Elevator.Direction)msg.read.Int32();\r\n\tbool flag = msg.read.Unread > 0 && msg.read.Bit();\r\n\tif (Interface.CallHook(\"OnElevatorButtonPress\", this, msg.player, direction, flag) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.SetFlag((direction == global::Elevator.Direction.Up) ? global::BaseEntity.Flags.Reserved1 : global::BaseEntity.Flags.Reserved2, true, false, true);\r\n\tbase.SetFlag(global::BaseEntity.Flags.Reserved6, flag, false, true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnEventTrigger",
      "HookName": "OnEventTrigger",
      "HookParameters": {
        "instance": "TriggeredEventPrefab"
      },
      "ReturnBehavior": 1,
      "TargetType": "TriggeredEventPrefab",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RunEvent",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public override void RunEvent()\r\n{\r\n\tif (Interface.CallHook(\"OnEventTrigger\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDebug.Log(\"[event] \" + this.targetPrefab.resourcePath);\r\n\tglobal::BaseEntity baseEntity = global::GameManager.server.CreateEntity(this.targetPrefab.resourcePath, default(Vector3), default(Quaternion), true);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnWildlifeTrap [SurvivalFishTrap]",
      "HookName": "OnWildlifeTrap",
      "HookParameters": {
        "instance": "SurvivalFishTrap",
        "itemDefinition": "ItemDefinition"
      },
      "ReturnBehavior": 1,
      "TargetType": "SurvivalFishTrap",
      "Category": "Traps",
      "MethodData": {
        "MethodName": "TrapThink",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tif (itemDefinition != null)\r\n\t{\r\n\t\ttry\r\n\t\t{\r\n\t\t\tthis.bypassItemFilter = true;\r\n\t\t\tif (Interface.CallHook(\"OnWildlifeTrap\", this, itemDefinition) != null)\r\n\t\t\t{\r\n\t\t\t\treturn;\r\n\t\t\t}\r\n\t\t\tglobal::Item item2 = global::ItemManager.Create(itemDefinition, 1, 0uL, true);\r\n\t\t\tif (base.LastLootedByPlayer != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerPveDamage [BuildingBlock]",
      "HookName": "OnPlayerPveDamage",
      "HookParameters": {
        "Initiator": "BaseEntity",
        "info": "HitInfo",
        "instance": "BuildingBlock"
      },
      "ReturnBehavior": 4,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "Hurt",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t}\r\n\t\t}\r\n\t\tbase.Hurt(info);\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerPveDamage\", info.Initiator, info, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\t(info.Initiator as global::BasePlayer).Hurt(info.damageTypes.Total(), Rust.DamageType.Generic, null, true);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnCupboardAuthorize [BuildingPrivlidge]",
      "HookName": "IOnCupboardAuthorize",
      "HookParameters": {
        "num": "ulong",
        "player": "BasePlayer",
        "instance": "BuildingPrivlidge"
      },
      "ReturnBehavior": 4,
      "TargetType": "BuildingPrivlidge",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "AddAuthorize",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.CanAdministrate(rpc.player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tulong num = rpc.read.UInt64();\r\n\tif (Interface.CallHook(\"IOnCupboardAuthorize\", num, rpc.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.AddPlayer(rpc.player, num);\r\n\tbase.SendNetworkUpdate(global::BasePlayer.NetworkQueue.Update);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnStructureUpgraded",
      "HookName": "OnStructureUpgraded",
      "HookParameters": {
        "instance": "BuildingBlock",
        "player": "BasePlayer",
        "type": "Enum",
        "skin": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "BuildingBlock",
      "Category": "Structure",
      "MethodData": {
        "MethodName": "DoUpgradeToGrade",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tNetworkIdentifier = this.net.ID,\r\n\t\t\tIntIdentifier = (int)constructionGrade.gradeBase.type\r\n\t\t}, 1f);\r\n\t}\r\n\tInterface.CallHook(\"OnStructureUpgraded\", this, msg.player, constructionGrade.gradeBase.type, constructionGrade.gradeBase.skin);\r\n\tthis.timePlaced = this.GetNetworkTime();\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDeployScientists [BradleyAPC]",
      "HookName": "CanDeployScientists",
      "HookParameters": {
        "instance": "BradleyAPC",
        "attacker": "BaseEntity",
        "scientistPrefabs": "List`1",
        "spawnPositions": "List`1"
      },
      "ReturnBehavior": 1,
      "TargetType": "BradleyAPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CanDeployScientists",
        "ReturnType": "bool",
        "Arguments": {
          "attacker": "BaseEntity",
          "scientistPrefabs": "System.Collections.Generic.List`1<GameObjectRef>",
          "spawnPositions": "System.Collections.Generic.List`1<UnityEngine.Vector3>"
        }
      },
      "CodeAfterInjection": "private bool CanDeployScientists(global::BaseEntity attacker, List<global::GameObjectRef> scientistPrefabs, List<Vector3> spawnPositions)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanDeployScientists\", this, attacker, scientistPrefabs, spawnPositions);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tint count = scientistPrefabs.Count;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnScientistInitialized [BradleyAPC]",
      "HookName": "OnScientistInitialized",
      "HookParameters": {
        "instance": "BradleyAPC",
        "scientist": "ScientistNPC",
        "spawnPos": "Vector3"
      },
      "ReturnBehavior": 0,
      "TargetType": "BradleyAPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "InitScientist",
        "ReturnType": "void",
        "Arguments": {
          "scientist": "ScientistNPC",
          "spawnPos": "UnityEngine.Vector3",
          "triggerPlayer": "BasePlayer",
          "roadSpawned": "bool",
          "startChasing": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tscientist.Brain.SwitchToState(global::AIState.TakeCover, 4);\r\n\t\t}\r\n\t\tscientist.Brain.Think(0f);\r\n\t}\r\n\tInterface.CallHook(\"OnScientistInitialized\", this, scientist, spawnPos);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnScientistRecalled [BradleyAPC]",
      "HookName": "OnScientistRecalled",
      "HookParameters": {
        "instance": "BradleyAPC",
        "scientist": "ScientistNPC"
      },
      "ReturnBehavior": 0,
      "TargetType": "BradleyAPC",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "OnScientistMounted",
        "ReturnType": "void",
        "Arguments": {
          "scientist": "ScientistNPC"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\tthis.mountedScientistPrefabs.Add(item);\r\n\t}\r\n\tthis.activeScientists.Remove(scientist);\r\n\tthis.numberOfScientistsToSpawn++;\r\n\tInterface.CallHook(\"OnScientistRecalled\", this, scientist);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnLockRemove",
      "HookName": "OnLockRemove",
      "HookParameters": {
        "carOccupant": "ModularCar",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_RequestRemoveLock",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.carOccupant.CarLock.HasALock)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnLockRemove\", this.carOccupant, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.carOccupant.CarLock.RemoveLock();\r\n\tglobal::Effect.server.Run(this.addRemoveLockEffect.resourcePath, this, 0u, Vector3.zero, Vector3.zero, null, false, null);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCodeChange",
      "HookName": "OnCodeChange",
      "HookParameters": {
        "carOccupant": "ModularCar",
        "player": "BasePlayer",
        "text": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarGarage",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "RPC_RequestNewCode",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (player == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tstring text = msg.read.String(256, false);\r\n\tif (Interface.CallHook(\"OnCodeChange\", this.carOccupant, player, text) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (this.carOccupant.CarLock.TrySetNewCode(text, player.userID))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanDestroyLock",
      "HookName": "CanDestroyLock",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "ModularCar",
        "viaModule": "BaseVehicleModule"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCar",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "PlayerCanDestroyLock",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer",
          "viaModule": "BaseVehicleModule"
        }
      },
      "CodeAfterInjection": "public bool PlayerCanDestroyLock(global::BasePlayer player, global::BaseVehicleModule viaModule)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"CanDestroyLock\", player, this, viaModule);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.CarLock.PlayerCanDestroyLock(viaModule);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLock",
      "HookName": "CanLock",
      "HookParameters": {
        "player": "BasePlayer",
        "owner": "ModularCar",
        "instance": "ModularCarCodeLock"
      },
      "ReturnBehavior": 1,
      "TargetType": "ModularCarCodeLock",
      "Category": "Vehicle",
      "MethodData": {
        "MethodName": "HasLockPermission",
        "ReturnType": "bool",
        "Arguments": {
          "player": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (!player.IsValid() || player.IsDead())\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"CanLock\", player, this.owner, this);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\treturn this.HasLockPermission(player.userID);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnDebrisSpawn",
      "HookName": "OnDebrisSpawn",
      "HookParameters": {
        "instance": "DecayEntity",
        "localPos": "Vector3",
        "rot": "Quaternion",
        "dropToTerrain": "bool"
      },
      "ReturnBehavior": 1,
      "TargetType": "DecayEntity",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "SpawnDebris",
        "ReturnType": "void",
        "Arguments": {
          "localPos": "UnityEngine.Vector3",
          "rot": "UnityEngine.Quaternion",
          "dropToTerrain": "bool"
        }
      },
      "CodeAfterInjection": "private void SpawnDebris(Vector3 localPos, Quaternion rot, bool dropToTerrain)\r\n{\r\n\tif (Interface.CallHook(\"OnDebrisSpawn\", this, localPos, rot, dropToTerrain) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tVector3 vector = base.transform.TransformPoint(localPos);\r\n\tRaycastHit raycastHit;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretModeToggle [AttackAll]",
      "HookName": "OnTurretModeToggle",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "SERVER_AttackAll",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\nprivate void SERVER_AttackAll(global::BaseEntity.RPCMessage rpc)\r\n{\r\n\tif (this.IsAuthed(rpc.player))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTurretModeToggle\", this, rpc.player) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tthis.SetPeacekeepermode(false);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTurretIdentifierSet",
      "HookName": "OnTurretIdentifierSet",
      "HookParameters": {
        "instance": "AutoTurret",
        "player": "BasePlayer",
        "text2": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "AutoTurret",
      "Category": "Turret",
      "MethodData": {
        "MethodName": "Server_SetID",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (text == this.GetIdentifier())\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTurretIdentifierSet\", this, msg.player, text2) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tDebug.Log(\"SetID success!\");\r\n\t\tthis.UpdateIdentifier(text2, false);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpen [TravellingVendor]",
      "HookName": "OnVendingShopOpen",
      "HookParameters": {
        "vendingMachine": "NPCVendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "TravellingVendor",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "SV_OpenMenu",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (this.vendingMachine == null)\r\n\t{\r\n\t\tthis.vendingMachine = base.GetComponentInChildren<global::NPCVendingMachine>();\r\n\t}\r\n\tif (Interface.CallHook(\"OnVendingShopOpen\", this.vendingMachine, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.vendingMachine.OpenShop(msg.player);\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnVendingShopOpened [TravellingVendor]",
      "HookName": "OnVendingShopOpened",
      "HookParameters": {
        "vendingMachine": "NPCVendingMachine",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "TravellingVendor",
      "Category": "Vending",
      "MethodData": {
        "MethodName": "SV_OpenMenu",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (Interface.CallHook(\"OnVendingShopOpen\", this.vendingMachine, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.vendingMachine.OpenShop(msg.player);\r\n\tInterface.CallHook(\"OnVendingShopOpened\", this.vendingMachine, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "CanLootEntity",
      "HookName": "CanLootEntity",
      "HookDescription": "Called when a player tries to loot a WorldItem",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "WorldItem"
      },
      "ReturnBehavior": 1,
      "TargetType": "WorldItem",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_OpenLoot",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanOpenInSafeZone(player))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"CanLootEntity\", player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (player.inventory.loot.StartLootingEntity(this, true))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCorpsePopulate",
      "HookName": "OnCorpsePopulate",
      "HookParameters": {
        "instance": "NPCPlayer",
        "nPCPlayerCorpse": "NPCPlayerCorpse"
      },
      "ReturnBehavior": 1,
      "TargetType": "NPCPlayer",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CreateCorpse",
        "ReturnType": "BaseCorpse",
        "Arguments": {
          "flagsOnDeath": "BasePlayer/PlayerFlags",
          "posOnDeath": "UnityEngine.Vector3",
          "rotOnDeath": "UnityEngine.Quaternion",
          "triggersOnDeath": "System.Collections.Generic.List`1<TriggerBase>",
          "forceServerSide": "bool"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\tif (!this.KeepCorpseClothingIntact || i != 1)\r\n\t\t\t\t{\r\n\t\t\t\t\titemContainer.Clear();\r\n\t\t\t\t}\r\n\t\t\t}\r\n\t\t\tobject returnvar = Interface.CallHook(\"OnCorpsePopulate\", this, nPCPlayerCorpse);\r\n\t\t\tif (returnvar is global::BaseCorpse)\r\n\t\t\t{\r\n\t\t\t\treturn (global::BaseCorpse)returnvar;\r\n\t\t\t}\r\n\t\t\tthis.ApplyLoot(nPCPlayerCorpse);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryItemFind",
      "HookName": "OnInventoryItemFind",
      "HookParameters": {
        "instance": "PlayerInventory",
        "id": "int"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindItemByItemID",
        "ReturnType": "Item",
        "Arguments": {
          "id": "int"
        }
      },
      "CodeAfterInjection": "public global::Item FindItemByItemID(int id)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryItemFind\", this, id);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tif (this.containerMain != null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnInventoryAmmoItemFind [PlayerInventory]",
      "HookName": "OnInventoryAmmoItemFind",
      "HookParameters": {
        "instance": "PlayerInventory",
        "ammoType": "AmmoTypes"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerInventory",
      "Category": "Item",
      "MethodData": {
        "MethodName": "FindAmmo",
        "ReturnType": "Item",
        "Arguments": {
          "ammoType": "Rust.AmmoTypes"
        }
      },
      "CodeAfterInjection": "public global::Item FindAmmo(AmmoTypes ammoType)\r\n{\r\n\tobject returnvar = Interface.CallHook(\"OnInventoryAmmoItemFind\", this, ammoType);\r\n\tif (returnvar is global::Item)\r\n\t{\r\n\t\treturn (global::Item)returnvar;\r\n\t}\r\n\tglobal::ItemContainer expr_28 = this.containerMain;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerHandcuff",
      "HookName": "OnPlayerHandcuff",
      "HookParameters": {
        "victim": "BasePlayer",
        "handcuffer": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "Handcuffs",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SV_HandcuffVictim",
        "ReturnType": "void",
        "Arguments": {
          "victim": "BasePlayer",
          "handcuffer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::Item ownerItem = base.GetOwnerItem();\r\n\tif (ownerItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerHandcuff\", victim, handcuffer) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tvictim.SetPlayerFlag(global::BasePlayer.PlayerFlags.IsRestrained, true);\r\n\tvictim.SendNetworkUpdateImmediate(false);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerHandcuffed",
      "HookName": "OnPlayerHandcuffed",
      "HookParameters": {
        "victim": "BasePlayer",
        "handcuffer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "Handcuffs",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SV_HandcuffVictim",
        "ReturnType": "void",
        "Arguments": {
          "victim": "BasePlayer",
          "handcuffer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tConVar.Inventory.EquipItemInSlot(victim, 0);\r\n\t}\r\n\tvictim.ClientRPC(global::RpcTarget.Player(\"SetActiveBeltSlot\", victim), ownerItem.position, ownerItem.uid);\r\n\tthis.SetLocked(true, victim, ownerItem);\r\n\tglobal::Effect.server.Run(this.lockEffect.resourcePath, victim, 0u, Vector3.zero, Vector3.zero, null, false, null);\r\n\tInterface.CallHook(\"OnPlayerHandcuffed\", victim, handcuffer);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRfListenerRemoved [patch]",
      "HookName": "OnRfListenerRemoved [patch]",
      "ReturnBehavior": 0,
      "TargetType": "RFManager",
      "Category": "Radio",
      "MethodData": {
        "MethodName": "RemoveListener",
        "ReturnType": "void",
        "Arguments": {
          "frequency": "int",
          "obj": "IRFObject"
        }
      }
    },
    {
      "Type": 1,
      "Name": "OnItemSubmit [patch]",
      "HookName": "OnItemSubmit",
      "ReturnBehavior": 0,
      "TargetType": "Mailbox",
      "Category": "Item",
      "MethodData": {
        "MethodName": "SubmitInputItems",
        "ReturnType": "void",
        "Arguments": {
          "fromPlayer": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tfor (int i = 0; i < this.InputContainer.capacity; i++)\r\n\t{\r\n\t\tglobal::Item slot = this.InputContainer.GetSlot(i);\r\n\t\tif (slot != null)\r\n\t\t{\r\n\t\t\tif (Interface.CallHook(\"OnItemSubmit\", slot, this, fromPlayer) == null)\r\n\t\t\t{\r\n\t\t\t\tif (slot.MoveToContainer(base.inventory, -1, true, false, null, true))\r\n\t\t\t\t{\r\n\t\t\t\t\tglobal::Effect.server.Run(this.mailDropSound.resourcePath, this.GetDropPosition(), default(Vector3), null, false, null);\r\n\t\t\t\t\tif (fromPlayer != null && !this.PlayerIsOwner(fromPlayer))\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnNpcTarget [SenseComponent]",
      "HookName": "IOnNpcTarget",
      "HookParameters": {
        "instance": "SenseComponent",
        "entity": "BaseEntity"
      },
      "ReturnBehavior": 1,
      "TargetType": "Rust.Ai.Gen2.SenseComponent",
      "Category": "NPC",
      "MethodData": {
        "MethodName": "CanTarget",
        "ReturnType": "bool",
        "Arguments": {
          "entity": "BaseEntity"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tif (SimpleAIMemory.PlayerIgnoreList.Contains(basePlayer))\r\n\t\t{\r\n\t\t\treturn false;\r\n\t\t}\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"IOnNpcTarget\", this, entity);\r\n\treturn !(returnvar is bool) || (bool)returnvar;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerVanish",
      "HookName": "OnPlayerVanish",
      "HookParameters": {
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ConVar.Debugging",
      "Category": "Player",
      "MethodData": {
        "MethodName": "invis",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\texpr_64.SetHeld(false);\r\n\t\t}\r\n\t\tbasePlayer.DisablePlayerCollider();\r\n\t\tRust.Ai.SimpleAIMemory.AddIgnorePlayer(basePlayer);\r\n\t\tglobal::BaseEntity.Query.Server.RemovePlayer(basePlayer);\r\n\t\tInterface.CallHook(\"OnPlayerVanish\", basePlayer);\r\n\t\tif (!Global.Runner.IsInvoking(new Action(Debugging.TickInvis)))\r\n\t\t{\r\n\t\t\tGlobal.Runner.InvokeRepeating(new Action(Debugging.TickInvis), 0f, 0f);\r\n\t\t}\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerUnvanish",
      "HookName": "OnPlayerUnvanish",
      "HookParameters": {
        "basePlayer": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "ConVar.Debugging",
      "Category": "Player",
      "MethodData": {
        "MethodName": "invis",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tbasePlayer.syncPosition = true;\r\n\t\tbasePlayer.EnablePlayerCollider();\r\n\t\tRust.Ai.SimpleAIMemory.RemoveIgnorePlayer(basePlayer);\r\n\t\tglobal::BaseEntity.Query.Server.RemovePlayer(basePlayer);\r\n\t\tglobal::BaseEntity.Query.Server.AddPlayer(basePlayer);\r\n\t\tInterface.CallHook(\"OnPlayerUnvanish\", basePlayer);\r\n\t\tif (Debugging.invisiblePlayers.Count == 0)\r\n\t\t{\r\n\t\t\tGlobal.Runner.CancelInvoke(new Action(Debugging.TickInvis));\r\n\t\t}\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerDropActiveItem",
      "HookName": "OnPlayerDropActiveItem",
      "HookParameters": {
        "player": "BasePlayer",
        "droppedItem": "Item"
      },
      "ReturnBehavior": 1,
      "TargetType": "PlayerBelt",
      "Category": "Player",
      "MethodData": {
        "MethodName": "DropActive",
        "ReturnType": "void",
        "Arguments": {
          "position": "UnityEngine.Vector3",
          "velocity": "UnityEngine.Vector3"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::Item activeItem = this.player.GetActiveItem();\r\n\tif (activeItem == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnPlayerDropActiveItem\", this.player, activeItem) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tusing (TimeWarning.New(\"PlayerBelt.DropActive\", 0))\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFrankensteinPetWake [FrankensteinTable]",
      "HookName": "OnFrankensteinPetWake",
      "HookParameters": {
        "instance": "FrankensteinTable",
        "owner": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "FrankensteinTable",
      "Category": "Pet",
      "MethodData": {
        "MethodName": "WakeFrankenstein",
        "ReturnType": "void",
        "Arguments": {
          "owner": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanStartCreating(owner))\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnFrankensteinPetWake\", this, owner) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.waking = true;\r\n\tbase.inventory.SetLocked(true, false);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFrankensteinPetSleep [FrankensteinTable]",
      "HookName": "OnFrankensteinPetSleep",
      "HookParameters": {
        "frankensteinPet": "FrankensteinPet",
        "instance": "FrankensteinTable",
        "owner": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "FrankensteinTable",
      "Category": "Pet",
      "MethodData": {
        "MethodName": "SleepFrankenstein",
        "ReturnType": "void",
        "Arguments": {
          "owner": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (Vector3.Distance(base.transform.position, frankensteinPet.transform.position) >= 5f)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnFrankensteinPetSleep\", frankensteinPet, this, owner) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.ReturnFrankensteinItems(frankensteinPet);\r\n\tglobal::ItemManager.DoRemoves();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFreeableContainerRelease",
      "HookName": "OnFreeableContainerRelease",
      "HookParameters": {
        "instance": "FreeableLootContainer",
        "ply": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "FreeableLootContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Release",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "public void Release(global::BasePlayer ply)\r\n{\r\n\tif (Interface.CallHook(\"OnFreeableContainerRelease\", this, ply) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.GetRB().isKinematic = false;\r\n\tthis.buoyancy.enabled = true;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFreeableContainerReleased",
      "HookName": "OnFreeableContainerReleased",
      "HookParameters": {
        "instance": "FreeableLootContainer",
        "ply": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "FreeableLootContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "Release",
        "ReturnType": "void",
        "Arguments": {
          "ply": "BasePlayer"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (ply != null && !ply.IsNpc && ply.IsConnected && this.net != null)\r\n\t{\r\n\t\tply.ProcessMissionEvent(global::BaseMission.MissionEventType.FREE_CRATE, this.net.ID, 1f);\r\n\t\tFacepunch.Rust.Analytics.Azure.OnFreeUnderwaterCrate(ply, this);\r\n\t}\r\n\tInterface.CallHook(\"OnFreeableContainerReleased\", this, ply);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFreeableContainerReleaseStarted",
      "HookName": "OnFreeableContainerReleaseStarted",
      "HookParameters": {
        "instance": "FreeableLootContainer",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 0,
      "TargetType": "FreeableLootContainer",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "RPC_FreeCrateTimer",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tif (!this.IsTiedDown())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.startUntieTime = Time.realtimeSinceStartup;\r\n\tInterface.CallHook(\"OnFreeableContainerReleaseStarted\", this, msg.player);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSiegeWeaponFire [Catapult]",
      "HookName": "OnSiegeWeaponFire",
      "HookParameters": {
        "instance": "Catapult",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "Catapult",
      "Category": "Primitive",
      "MethodData": {
        "MethodName": "SERVER_WantsFire",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\tglobal::BasePlayer player = msg.player;\r\n\tif (!this.CanFire())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSiegeWeaponFire\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tfloat force = this.reloadProgress;\r\n\tthis.Fire(player, force);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSiegeWeaponFire [BatteringRam]",
      "HookName": "OnSiegeWeaponFire",
      "HookParameters": {
        "instance": "BatteringRam",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BatteringRam",
      "Category": "Primitive",
      "MethodData": {
        "MethodName": "SERVER_WantsAttack",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (driver.InSafeZone())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSiegeWeaponFire\", this, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tbase.ClientRPC(global::RpcTarget.NetworkGroup(\"CLIENT_Attack\"));\r\n\tbase.Invoke(delegate\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSiegeWeaponFire [Ballista]",
      "HookName": "OnSiegeWeaponFire",
      "HookParameters": {
        "ballistaOwner": "Ballista",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 1,
      "TargetType": "BallistaGun",
      "Category": "Primitive",
      "MethodData": {
        "MethodName": "SERVER_FireClientProjectile",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (player.InSafeZone())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSiegeWeaponFire\", this.ballistaOwner, player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tglobal::ItemDefinition ammoType = this.magazine.ammoType;\r\n\tif (ammoType == null)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnAnimalDungProduce [RidableHorse]",
      "HookName": "OnAnimalDungProduce",
      "HookParameters": {
        "instance": "RidableHorse"
      },
      "ReturnBehavior": 4,
      "TargetType": "RidableHorse",
      "Category": "Animal",
      "MethodData": {
        "MethodName": "DoDung",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "private void DoDung()\r\n{\r\n\tthis.dungProduction -= 1f;\r\n\tif (Interface.CallHook(\"OnAnimalDungProduce\", this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tQuaternion rotation = Quaternion.Euler(UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f), UnityEngine.Random.Range(-180f, 180f));\r\n\tVector3 vVelocity = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-1f, -3f), UnityEngine.Random.Range(-0.5f, 0.5f));\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnAnimalDungProduced [RidableHorse] [Variable]",
      "HookName": "OnAnimalDungProduced",
      "ReturnBehavior": 0,
      "TargetType": "RidableHorse",
      "Category": "Animal",
      "MethodData": {
        "MethodName": "DoDung",
        "ReturnType": "void",
        "Arguments": {}
      }
    },
    {
      "Type": 0,
      "Name": "OnAnimalDungProduced [RidableHorse]",
      "HookName": "OnAnimalDungProduced",
      "HookParameters": {
        "instance": "RidableHorse",
        "OxideGen_2": "Item"
      },
      "ReturnBehavior": 0,
      "TargetType": "RidableHorse",
      "Category": "Animal",
      "MethodData": {
        "MethodName": "DoDung",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\tVector3 vVelocity = new Vector3(UnityEngine.Random.Range(-0.5f, 0.5f), UnityEngine.Random.Range(-1f, -3f), UnityEngine.Random.Range(-0.5f, 0.5f));\r\n\tglobal::Item OxideGen_2 = global::ItemManager.Create(this.dungItem, 1, 0uL, true);\r\n\tglobal::Item expr_99 = OxideGen_2;\r\n\texpr_99.SetItemOwnership(this.currentBreed.breedName.english, global::ItemOwnershipPhrases.Pooped);\r\n\texpr_99.Drop(this.dungSpawnPoint.position + UnityEngine.Random.insideUnitSphere * 0.1f, vVelocity, rotation);\r\n\tInterface.CallHook(\"OnAnimalDungProduced\", this, OxideGen_2);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnActiveTelephoneUpdated [BasePlayer]",
      "HookName": "OnActiveTelephoneUpdated",
      "HookParameters": {
        "instance": "BasePlayer",
        "t": "PhoneController"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer",
      "Category": "Player",
      "MethodData": {
        "MethodName": "SetActiveTelephone",
        "ReturnType": "void",
        "Arguments": {
          "t": "PhoneController"
        }
      },
      "CodeAfterInjection": "public void SetActiveTelephone(global::PhoneController t)\r\n{\r\n\tthis.activeTelephone = t;\r\n\tInterface.CallHook(\"OnActiveTelephoneUpdated\", this, t);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSiegeWeaponDoorOpen [BatteringRam]",
      "HookName": "OnSiegeWeaponDoorOpen",
      "HookParameters": {
        "instance": "BatteringRam",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "BatteringRam",
      "Category": "Primitive",
      "MethodData": {
        "MethodName": "RPC_OpenDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanOpenDoor())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSiegeWeaponDoorOpen\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.OpenDoor();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSiegeWeaponDoorClose [BatteringRam]",
      "HookName": "OnSiegeWeaponDoorClose",
      "HookParameters": {
        "instance": "BatteringRam",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "BatteringRam",
      "Category": "Primitive",
      "MethodData": {
        "MethodName": "RPC_CloseDoor",
        "ReturnType": "void",
        "Arguments": {
          "rpc": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (!this.CanCloseDoor())\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSiegeWeaponDoorClose\", this, rpc.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tthis.CloseDoor();\r\n}\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSiegeWeaponPull",
      "HookName": "OnSiegeWeaponPull",
      "HookParameters": {
        "instance": "BaseSiegeWeapon",
        "player": "BasePlayer"
      },
      "ReturnBehavior": 4,
      "TargetType": "BaseSiegeWeapon",
      "Category": "Primitive",
      "MethodData": {
        "MethodName": "SERVER_StartPulling",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "//---\r\n\t}\r\n\tif (this.rigidBody == null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (Interface.CallHook(\"OnSiegeWeaponPull\", this, msg.player) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (base.OnlyOwnerAccessible() && player != this.creatorEntity)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnGibsSpawned",
      "HookName": "OnGibsSpawned",
      "HookParameters": {
        "list": "List`1",
        "creator": "GameObject"
      },
      "ReturnBehavior": 0,
      "TargetType": "ServerGib",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "CreateGibs",
        "ReturnType": "System.Collections.Generic.List`1<ServerGib>",
        "Arguments": {
          "entityToCreatePath": "string",
          "creator": "UnityEngine.GameObject",
          "gibSource": "UnityEngine.GameObject",
          "inheritVelocity": "UnityEngine.Vector3",
          "spreadVelocity": "float"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t\t{\r\n\t\t\t\tPhysics.IgnoreCollision(current2.GetCollider(), current.GetCollider(), true);\r\n\t\t\t}\r\n\t\t}\r\n\t}\r\n\tInterface.CallHook(\"OnGibsSpawned\", list, creator);\r\n\treturn list;\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateSpawned [PatrolHelicopter]",
      "HookName": "OnCrateSpawned",
      "HookParameters": {
        "instance": "PatrolHelicopter",
        "baseEntity2": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "PatrolHelicopter",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnDied",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tbaseEntity2.SendMessage(\"SetLockingEnt\", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);\r\n\t\tforeach (global::ServerGib current2 in list)\r\n\t\t{\r\n\t\t\tPhysics.IgnoreCollision(component2, current2.GetCollider(), true);\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnCrateSpawned\", this, baseEntity2);\r\n\t}\r\n\tbase.OnDied(info);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnCrateSpawned [BradleyAPC]",
      "HookName": "OnCrateSpawned",
      "HookParameters": {
        "instance": "BradleyAPC",
        "baseEntity2": "BaseEntity"
      },
      "ReturnBehavior": 0,
      "TargetType": "BradleyAPC",
      "Category": "Entity",
      "MethodData": {
        "MethodName": "OnDied",
        "ReturnType": "void",
        "Arguments": {
          "info": "HitInfo"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tbaseEntity2.SendMessage(\"SetLockingEnt\", fireBall.gameObject, SendMessageOptions.DontRequireReceiver);\r\n\t\tforeach (global::ServerGib current2 in list)\r\n\t\t{\r\n\t\t\tPhysics.IgnoreCollision(component2, current2.GetCollider(), true);\r\n\t\t}\r\n\t\tInterface.CallHook(\"OnCrateSpawned\", this, baseEntity2);\r\n\t}\r\n\tthis.KillSpawnedScientists();\r\n\tif (info != null && info.InitiatorPlayer != null && info.InitiatorPlayer.serverClan != null)\r\n\t{\r\n\t\tinfo.InitiatorPlayer.AddClanScore(ClanScoreEventType.DestroyedBradley, 1, null, null, null, null);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "ICanPickupEntity [RFTimedExplosive]",
      "HookName": "ICanPickupEntity",
      "HookParameters": {
        "player": "BasePlayer",
        "instance": "RFTimedExplosive"
      },
      "ReturnBehavior": 4,
      "TargetType": "RFTimedExplosive",
      "Category": "Player",
      "MethodData": {
        "MethodName": "Pickup",
        "ReturnType": "void",
        "Arguments": {
          "msg": "BaseEntity/RPCMessage"
        }
      },
      "CodeAfterInjection": "[global::BaseEntity.RPC_Server, global::BaseEntity.RPC_Server.IsVisible(3f)]\r\npublic void Pickup(global::BaseEntity.RPCMessage msg)\r\n{\r\n\tif (Interface.CallHook(\"ICanPickupEntity\", msg.player, this) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (!msg.player.CanInteract())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnFeedbackReported",
      "HookName": "OnFeedbackReported",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "text": "string",
        "text2": "string",
        "reportType": "ReportType"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer/<OnFeedbackReport>d__609",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t\tSubject = text,\r\n\t\t\t\t\t\tMessage = text3,\r\n\t\t\t\t\t\tType = reportType\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tInterface.CallHook(\"OnFeedbackReported\", basePlayer, text, text2, reportType);\r\n\t\t\t\tif (string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))\r\n\t\t\t\t{\r\n\t\t\t\t\tgoto IL_1DF;\r\n\t\t\t\t}\r\n\t\t\t\tstring image = this.msg.read.StringMultiLine(60000, false);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnFeedbackReported [patch]",
      "HookName": "OnFeedbackReported",
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer/<OnFeedbackReport>d__609",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\t\tSubject = text,\r\n\t\t\t\t\t\tMessage = text3,\r\n\t\t\t\t\t\tType = reportType\r\n\t\t\t\t\t});\r\n\t\t\t\t}\r\n\t\t\t\tInterface.CallHook(\"OnFeedbackReported\", basePlayer, text, text2, reportType);\r\n\t\t\t\tif (string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))\r\n\t\t\t\t{\r\n\t\t\t\t\tgoto IL_1C7;\r\n\t\t\t\t}\r\n\t\t\t\tstring image = this.msg.read.StringMultiLine(60000, false);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnPlayerReported",
      "HookName": "OnPlayerReported",
      "HookParameters": {
        "basePlayer": "BasePlayer",
        "text4": "string",
        "<targetId>5__2": "string",
        "text": "string",
        "text2": "string",
        "text3": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "BasePlayer/<OnPlayerReported>d__608",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\tTargetName = text4,\r\n\t\t\t\t\tSubject = text,\r\n\t\t\t\t\tMessage = message,\r\n\t\t\t\t\tType = text3\r\n\t\t\t\t});\r\n\t\t\t\tInterface.CallHook(\"OnPlayerReported\", basePlayer, text4, this.<targetId>5__2, text, text2, text3);\r\n\t\t\t\tif (string.IsNullOrEmpty(ConVar.Server.reportsServerEndpoint))\r\n\t\t\t\t{\r\n\t\t\t\t\tgoto IL_21B;\r\n\t\t\t\t}\r\n\t\t\t\tReportType type = ReportType.Abuse;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamMemberPromote",
      "HookName": "OnTeamMemberPromote",
      "HookParameters": {
        "instance": "PlayerTeam",
        "newTeamLeader": "ulong"
      },
      "ReturnBehavior": 4,
      "TargetType": "RelationshipManager/PlayerTeam",
      "Category": "Team",
      "MethodData": {
        "MethodName": "SetTeamLeader",
        "ReturnType": "void",
        "Arguments": {
          "newTeamLeader": "ulong"
        }
      },
      "CodeAfterInjection": "public void SetTeamLeader(ulong newTeamLeader)\r\n{\r\n\tif (Interface.CallHook(\"OnTeamMemberPromote\", this, newTeamLeader) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tFacepunch.Rust.Analytics.Azure.OnTeamChanged(\"promoted\", this.teamID, this.teamLeader, newTeamLeader, this.members);\r\n\tthis.teamLeader = newTeamLeader;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnSteamInventoryUpdated",
      "HookName": "OnSteamInventoryUpdated",
      "HookParameters": {
        "steamInventory": "SteamInventory"
      },
      "ReturnBehavior": 0,
      "TargetType": "SteamInventory/<UpdateSteamInventory>d__3",
      "Category": "Player",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\tDebug.LogWarning(string.Format(\"UpdateSteamPlayer: inventory belongs to someone else (userID={0})\", steamInventory.baseEntity.userID.Get()));\r\n\t\t}\r\n\t\telse if (steamInventory.gameObject)\r\n\t\t{\r\n\t\t\tsteamInventory.Items = result.Items.ToArray<IPlayerItem>();\r\n\t\t\tInterface.CallHook(\"OnSteamInventoryUpdated\", steamInventory);\r\n\t\t\tresult.Dispose();\r\n\t\t}\r\n\t}\r\n\tcatch (Exception exception)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnTeamMemberInvite [sendofflineinvite]",
      "HookName": "OnTeamMemberInvite",
      "HookParameters": {
        "playerTeam": "PlayerTeam",
        "basePlayer": "BasePlayer",
        "uLong": "ulong"
      },
      "ReturnBehavior": 1,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "sendofflineinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tbasePlayer.ShowToast(global::GameTip.Styles.Error, global::RelationshipManager.RemoteInvitesBlocked, false, Array.Empty<string>());\r\n\t\treturn;\r\n\t}\r\n\tif (basePlayer2 == null || (!basePlayer2.IsNpc && basePlayer2.currentTeam == 0uL))\r\n\t{\r\n\t\tif (Interface.CallHook(\"OnTeamMemberInvite\", playerTeam, basePlayer, uLong) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayerTeam.SendInvite(basePlayer2, uLong);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnTeamMemberInvite [sendinvite]",
      "HookName": "OnTeamMemberInvite",
      "ReturnBehavior": 0,
      "TargetType": "RelationshipManager",
      "Category": "Team",
      "MethodData": {
        "MethodName": "sendinvite",
        "ReturnType": "void",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tDateTime hookExpireDate = new DateTime(2025, 12, 31);\r\n\t\tif (Interface.CallDeprecatedHook(\"OnTeamInvite\", \"OnTeamMemberInvite( PlayerTeam playerTeam, BasePlayer basePlayer, ulong PlayerID )\", hookExpireDate, basePlayer, basePlayer2) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tif (Interface.CallHook(\"OnTeamMemberInvite\", playerTeam, basePlayer, basePlayer2.userID.Get()) != null)\r\n\t\t{\r\n\t\t\treturn;\r\n\t\t}\r\n\t\tplayerTeam.SendInvite(basePlayer2);\r\n\t}\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "IOnServerCommand",
      "HookName": "IOnServerCommand",
      "HookParameters": {
        "arg": "Arg"
      },
      "ReturnBehavior": 1,
      "TargetType": "ConsoleSystem",
      "Category": "Server",
      "MethodData": {
        "MethodName": "Internal",
        "ReturnType": "bool",
        "Arguments": {
          "arg": "ConsoleSystem/Arg"
        }
      },
      "CodeAfterInjection": "//---\r\n{\r\n\tif (arg.Invalid)\r\n\t{\r\n\t\treturn false;\r\n\t}\r\n\tobject returnvar = Interface.CallHook(\"IOnServerCommand\", arg);\r\n\tif (returnvar is bool)\r\n\t{\r\n\t\treturn (bool)returnvar;\r\n\t}\r\n\tif (!arg.HasPermission())\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "SingleCharCmdPrefix [patch]",
      "HookName": "SingleCharCmdPrefix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ConsoleSystem/Arg",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "BuildCommand",
        "ReturnType": "void",
        "Arguments": {
          "command": "string"
        }
      }
    },
    {
      "Type": 0,
      "Name": "IOnRunCommandLine",
      "HookName": "IOnRunCommandLine",
      "HookParameters": {},
      "ReturnBehavior": 1,
      "TargetType": "ConsoleSystem",
      "Category": "Server",
      "MethodData": {
        "MethodName": "UpdateValuesFromCommandLine",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "public static void UpdateValuesFromCommandLine()\r\n{\r\n\tif (Interface.CallHook(\"IOnRunCommandLine\") != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tforeach (KeyValuePair<string, string> current in Facepunch.CommandLine.GetSwitches())\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "SingleCharCmdSuffix [patch]",
      "HookName": "SingleCharCmdSuffix [patch]",
      "ReturnBehavior": 0,
      "TargetType": "ConsoleSystem/Arg",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "BuildCommand",
        "ReturnType": "void",
        "Arguments": {
          "command": "string"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnRconConnection [web]",
      "HookName": "OnRconConnection",
      "HookParameters": {
        "ClientIpAddress": "IPAddress"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass30_0",
      "Category": "Server",
      "MethodData": {
        "MethodName": "<Start>b__0",
        "ReturnType": "void",
        "Arguments": {
          "socket": "Fleck.IWebSocketConnection"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tDebug.Log(string.Format(\"RCON: CRITICAL - Banned IP {0} supplied the correct password. Access was still denied.\", <>c__DisplayClass30_.socket.ConnectionInfo.ClientIpAddress));\r\n\t\t}\r\n\t\t<>c__DisplayClass30_.socket.Close();\r\n\t}\r\n\tif (Interface.CallHook(\"OnRconConnection\", socket.ConnectionInfo.ClientIpAddress) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tif (<>c__DisplayClass30_.socket.ConnectionInfo.Path != this.requiredPath)\r\n\t{\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnRconConnection [web, patch]",
      "HookName": "OnRconConnection [web, patch]",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass30_0",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "<Start>b__0",
        "ReturnType": "void",
        "Arguments": {
          "socket": "Fleck.IWebSocketConnection"
        }
      }
    },
    {
      "Type": 0,
      "Name": "IOnRconMessage",
      "HookName": "IOnRconMessage",
      "HookParameters": {
        "ClientIpAddress": "IPAddress",
        "s": "string"
      },
      "ReturnBehavior": 1,
      "TargetType": "Facepunch.Rcon.Listener/<>c__DisplayClass30_1",
      "Category": "Server",
      "MethodData": {
        "MethodName": "<Start>b__3",
        "ReturnType": "void",
        "Arguments": {
          "s": "string"
        }
      },
      "CodeAfterInjection": "internal void <Start>b__3(string s)\r\n{\r\n\tif (Interface.CallHook(\"IOnRconMessage\", this.socket.ConnectionInfo.ClientIpAddress, s) != null)\r\n\t{\r\n\t\treturn;\r\n\t}\r\n\tDictionary<int, RconConnection> clients = this.CS$<>8__locals1.<>4__this.clients;\r\n\tlock (clients)\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClientDisconnected",
      "HookName": "OnClientDisconnected",
      "HookParameters": {
        "cn": "Connection",
        "strReason": "string"
      },
      "ReturnBehavior": 0,
      "TargetType": "Network.Server",
      "Category": "Player",
      "MethodData": {
        "MethodName": "OnDisconnected",
        "ReturnType": "void",
        "Arguments": {
          "strReason": "string",
          "cn": "Network.Connection"
        }
      },
      "CodeAfterInjection": "//---\r\n\tcn.active = false;\r\n\tif (this.callbackHandler != null)\r\n\t{\r\n\t\tthis.callbackHandler.OnDisconnected(strReason, cn);\r\n\t}\r\n\tInterface.CallHook(\"OnClientDisconnected\", cn, strReason);\r\n\tthis.RemoveConnection(cn);\r\n}\r\n\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNetworkSubscriptionsUpdate",
      "HookName": "OnNetworkSubscriptionsUpdate",
      "ReturnBehavior": 0,
      "TargetType": "Network.Networkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "UpdateSubscriptions",
        "ReturnType": "bool",
        "Arguments": {
          "removeLimit": "int",
          "addLimit": "int"
        }
      },
      "CodeAfterInjection": "//---\r\n\t\tList<Group> list2 = Pool.Get<List<Group>>();\r\n\t\tListHashSet<Group> listHashSet = Pool.Get<ListHashSet<Group>>();\r\n\t\tthis.sv.visibility.GetVisibleFromFar(this.group, listHashSet);\r\n\t\tthis.AddVisibleFromNear(this.secondaryGroup, listHashSet);\r\n\t\tListHashSet<Group>.Compare(this.subscriber.subscribed, listHashSet, list, list2, null);\r\n\t\tif (Interface.CallHook(\"OnNetworkSubscriptionsUpdate\", this, list, list2) == null)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < list2.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tGroup group = list2[i];\r\n\t\t\t\tif (removeLimit > 0)\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnNetworkSubscriptionsUpdate [2]",
      "HookName": "OnNetworkSubscriptionsUpdate",
      "ReturnBehavior": 0,
      "TargetType": "Network.Networkable",
      "Category": "Network",
      "MethodData": {
        "MethodName": "UpdateHighPrioritySubscriptions",
        "ReturnType": "bool",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tList<Group> list = Pool.Get<List<Group>>();\r\n\t\tListHashSet<Group> listHashSet = Pool.Get<ListHashSet<Group>>();\r\n\t\tthis.sv.visibility.GetVisibleFromNear(this.group, listHashSet);\r\n\t\tthis.AddVisibleFromNear(this.secondaryGroup, listHashSet);\r\n\t\tListHashSet<Group>.Compare(this.subscriber.subscribed, listHashSet, list, null, null);\r\n\t\tif (Interface.CallHook(\"OnNetworkSubscriptionsUpdate\", this, list, null) == null)\r\n\t\t{\r\n\t\t\tfor (int i = 0; i < list.Count; i++)\r\n\t\t\t{\r\n\t\t\t\tGroup group = list[i];\r\n\t\t\t\tthis.subscriber.Subscribe(group);\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "NoPragmaColumnExists [patch]",
      "HookName": "NoPragmaColumnExists",
      "ReturnBehavior": 0,
      "TargetType": "Facepunch.Sqlite.Database",
      "Category": "_Patches",
      "MethodData": {
        "MethodName": "ColumnExists",
        "ReturnType": "bool",
        "Arguments": {
          "tableName": "string",
          "columnName": "string"
        }
      }
    },
    {
      "Type": 0,
      "Name": "OnClanDisbanded",
      "HookName": "OnClanDisbanded",
      "HookParameters": {
        "localClan": "LocalClan",
        "bySteamId": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "LocalClan/<Disband>d__72",
      "Category": "Clan",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\tthis.<>1__state = -2;\r\n\t\tthis.<>t__builder.SetException(exception);\r\n\t\treturn;\r\n\t}\r\n\tint arg_DE_1 = -2;\r\n\tInterface.CallHook(\"OnClanDisbanded\", localClan, this.bySteamId);\r\n\tthis.<>1__state = arg_DE_1;\r\n\tthis.<>t__builder.SetResult(result);\r\n}\r\n\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClanCreated",
      "HookName": "OnClanCreated",
      "HookParameters": {
        "arg_49_0": "LocalClan",
        "leaderSteamId": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "LocalClanBackend/<Create>d__11",
      "Category": "Clan",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t{\r\n\t\t\tthrow new Exception(\"Couldn't find the clan we just created?\");\r\n\t\t}\r\n\t\tlocalClanBackend.MembershipChanged(this.leaderSteamId, new long?(localClan.ClanId));\r\n\t\tresult = localClan;\r\n\t\tInterface.CallHook(\"OnClanCreated\", localClan, this.leaderSteamId);\r\n\t}\r\n\tcatch (Exception exception)\r\n\t{\r\n\t\tthis.<>1__state = -2;\r\n\t\tthis.<>t__builder.SetException(exception);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClanMemberAdded",
      "HookName": "OnClanMemberAdded",
      "HookParameters": {
        "clanId": "long",
        "steamId": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "LocalClanDatabase",
      "Category": "Clan",
      "MethodData": {
        "MethodName": "AcceptInvite",
        "ReturnType": "bool",
        "Arguments": {
          "clanId": "long",
          "steamId": "ulong"
        }
      },
      "CodeAfterInjection": "//---\r\n\ttry\r\n\t{\r\n\t\tif (this.DeleteInvite(clanId, steamId) && this.CreateMember(clanId, steamId))\r\n\t\t{\r\n\t\t\tbase.Commit();\r\n\t\t\tInterface.CallHook(\"OnClanMemberAdded\", clanId, steamId);\r\n\t\t\tresult = true;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tbase.Rollback();\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClanMemberLeft",
      "HookName": "OnClanMemberLeft",
      "HookParameters": {
        "localClan": "LocalClan",
        "steamId": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "LocalClan/<Kick>d__65",
      "Category": "Clan",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t}\r\n\t\t\tif (localClan._backend.Database.DeleteMember(localClan.ClanId, this.steamId))\r\n\t\t\t{\r\n\t\t\t\tif (flag)\r\n\t\t\t\t{\r\n\t\t\t\t\tInterface.CallHook(\"OnClanMemberLeft\", localClan, this.steamId);\r\n\t\t\t\t\tlocalClan._backend.Database.AppendLog<ulong>(localClan.ClanId, \"leave\", this.steamId);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tlocalClan._backend.Database.AppendLog<ulong, ulong>(localClan.ClanId, \"kick\", this.bySteamId, this.steamId);\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClanMemberKicked",
      "HookName": "OnClanMemberKicked",
      "HookParameters": {
        "localClan": "LocalClan",
        "steamId": "ulong",
        "bySteamId": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "LocalClan/<Kick>d__65",
      "Category": "Clan",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t\t\t\tInterface.CallHook(\"OnClanMemberLeft\", localClan, this.steamId);\r\n\t\t\t\t\tlocalClan._backend.Database.AppendLog<ulong>(localClan.ClanId, \"leave\", this.steamId);\r\n\t\t\t\t}\r\n\t\t\t\telse\r\n\t\t\t\t{\r\n\t\t\t\t\tInterface.CallHook(\"OnClanMemberKicked\", localClan, this.steamId, this.bySteamId);\r\n\t\t\t\t\tlocalClan._backend.Database.AppendLog<ulong, ulong>(localClan.ClanId, \"kick\", this.bySteamId, this.steamId);\r\n\t\t\t\t}\r\n\t\t\t\tlocalClan.Changed(ClanDataSource.Members);\r\n\t\t\t\tlocalClan._backend.MembershipChanged(this.steamId, null);\r\n\t\t\t\tresult = ClanResult.Success;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClanColorChanged",
      "HookName": "OnClanColorChanged",
      "HookParameters": {
        "localClan": "LocalClan",
        "newColor": "Color32",
        "bySteamId": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "LocalClan/<SetColor>d__61",
      "Category": "Clan",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\telse if (localClan._backend.Database.UpdateClanColor(localClan.ClanId, this.newColor))\r\n\t\t{\r\n\t\t\tlocalClan._backend.Database.AppendLog<ulong, string>(localClan.ClanId, \"set_color\", this.bySteamId, this.newColor.ToHex());\r\n\t\t\tlocalClan.Changed(ClanDataSource.Basic);\r\n\t\t\tInterface.CallHook(\"OnClanColorChanged\", localClan, this.newColor, this.bySteamId);\r\n\t\t\tresult = ClanResult.Success;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tresult = ClanResult.Fail;\r\n//---\r\n"
    },
    {
      "Type": 0,
      "Name": "OnClanLogoChanged",
      "HookName": "OnClanLogoChanged",
      "HookParameters": {
        "localClan": "LocalClan",
        "newLogo": "byte",
        "bySteamId": "ulong"
      },
      "ReturnBehavior": 0,
      "TargetType": "LocalClan/<SetLogo>d__60",
      "Category": "Clan",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      },
      "CodeAfterInjection": "//---\r\n\t\t}\r\n\t\telse if (localClan._backend.Database.UpdateClanLogo(localClan.ClanId, this.newLogo))\r\n\t\t{\r\n\t\t\tlocalClan._backend.Database.AppendLog<ulong>(localClan.ClanId, \"set_logo\", this.bySteamId);\r\n\t\t\tlocalClan.Changed(ClanDataSource.Logo);\r\n\t\t\tInterface.CallHook(\"OnClanLogoChanged\", localClan, this.newLogo, this.bySteamId);\r\n\t\t\tresult = ClanResult.Success;\r\n\t\t}\r\n\t\telse\r\n\t\t{\r\n\t\t\tresult = ClanResult.Fail;\r\n//---\r\n"
    },
    {
      "Type": 1,
      "Name": "OnClanLogoChanged [patch]",
      "HookName": "OnClanLogoChanged [patch]",
      "ReturnBehavior": 0,
      "TargetType": "LocalClan/<SetLogo>d__60",
      "Category": "Clan",
      "MethodData": {
        "MethodName": "MoveNext",
        "ReturnType": "void",
        "Arguments": {}
      }
    }
  ]
}